
<!DOCTYPE html>
<!-- @MineKhan version Alpha 0.7.1

Recovered from https://web.archive.org/web/20220325200527/https://geeky-people.herokuapp.com/geekycraft.html

	NOTE:
The "Save" button saves your world to your local browser. Nobody else can see it. However, if you're on a public or shared computer, that save may be deleted unexpectedly. So it's a good idea to keep a safe copy of your save string somewhere where it won't be deleted.

To share your save with other people, copy your world string into the "loadString" variable on line 189.

	Controls:

 * Right-click (or ctrl + left-click): place block
 * Left-click: Remove block
 * Middle-click: Pick block
 * Q: Sprint
 * Shift: Sneak
 * W: Walk forward
 * S: Walk backward
 * A: Walk left
 * D: Walk right
 * E: Open inventory
 * B: Toggle super Breaker
 * Z: Zoom
 * L: Toggle Spectator mode
 * Enter: Toggle slab/stair mode
 * Arrow Keys: look around
 * P or Esc: pause/unpause
 * 1-9 navigate hotbar
 * Spacebar: jump
 * Double jump: toggle flight
 * Shift (flying): fly down
 * Space (flying): fly up
 * T: Reload textures
 * ; (semicolon): Release the pointer without pausing (for screenshots)
 * Backspace or delete: drops the item you're holding right now

	Notes and accreditation:

 * Chunks are kept in memory until you restart. So don't explore too far or memory usage will grow until it crashes unrecoverably.


	To-Do:
 * A lot. Check out the GitHub repo if you'd like to collaborate on this. Must use Discord.

	How it works:

The graphics in this project are done using WebGL, which is a web implementation of OpenGL ES 2.
It allows us to write shader programs that run right on the GPU, which means it can run as fast as any C++ game.
The infamous P3D mode in Processing.js uses WebGL behind the scenes, but it does it so inefficiently that it might as well not even being using the GPU.

To properly utilize WebGL like this program does, you need to make efficient use of Vertext Buffer Objects (VBOs).
A VBO is an array that contains a whole bunch of vertices. Since WebGL can only render triangles and lines, these vertices are stored in multiples of 3.
A vertex doesn't only include its world coordinates, though. It also includes its texture coordinates, and any other data you want the shaders to manipulate.
In my case, every vertex has an X, Y, Z, textureX, textureY, and shadowIntensity. So 6 values for every block vertex in the world.

A program can only draw 1 VBO per draw call. Since the texture data is attached to the vertex data, you can't switch textures between vertices.
That means you either have to make seperate draw calls for each texture, or only use 1 texture. I do the latter.
I make a single 256x256 pixel texture, and store each of the 16x16 block textures in a section of that big texture, and store the coordinates to it. This is informally called a "texture atlas".
Then when I'm preparing my VBO, I send the texture coordinates along with the block coordinates so the shader knows how to map the 256x256 pixel texture onto the 16x16 pixel block face.

I do this once for each chunk in the world, and store those VBOs so I can draw them every frame. If a block is edited in a chunk, then that VBO is replaced.
Drawing a chunk after the VBO has been created is as simple as binding the buffer and calling "gl.drawArrays" once per chunk. The GPU takes care of the rest.

I also use what's called Vertex Array Objects (VAOs) to re-use shared vertices. Since the GPU expects triangles, and I want to draw squares, I need to draw 2 triangles (6 vertices) per square.
That means 2 of them are being re-used. The VAO lets me tell the GPU to use the cached vertex data instead of looking for a new one, which offers a small inprovement to GPU performance.
This isn't entirely necessary, but it's considered best practice. Some OpenGL ES implementations require it, but WebGL 1 does not. I think WebGL 2 does, but that's not as well supported.
-->

<html>
	<head>
		<meta charset="utf-8">
		<title>Geekycraft</title>
    <base href="https://geeky-people.herokuapp.com/geekycraft.html">
    <!--Metadata-->
    <meta name="keywords" content="Geekycraft"> <!--search "Geekycraft" on Google-->
    <meta name="description" content="Geekycraft with survival and nether and many more features">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
		<link id="vtfont" href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>@font-face{font-family: 'VT323'; src:url('mojangles.otf');}</style>
		<link rel="shortcut icon" type="image/ico" href="mojangles.otf">
    <link rel="manifest" href="manifest.json">
	</head>
	<style>
		body {
			overflow: hidden; /* Hide scrollbars */
			-webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
		}
    button, #onscreenControls, canvas{
		  /*get rid of user select*/
		  font-family: 'VT323', 'Courier New', Courier, monospace;
			-webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
		}
		.world-select {
			width: 99vw;
			min-width: 300px;
			height: calc(100vh - 220px);
			position: absolute;
			bottom: 120px;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			margin: 0 auto;
		}canvas{
		user-select: none
		}
		.world {
			width: 250px;
			height: auto;
			border: 1px solid black;
			font-size: 16px;
			font-family: 'VT323', 'Courier New', Courier, monospace;
			color: rgb(180, 180, 180);
			margin: 0 auto;
			margin-top: 15px;
			padding: 5px;
			cursor: pointer;
		}
		strong {
			color: white;
		}

		.selected {
			border: 3px solid white;
			padding: 3px;
		}
		input[type=text] {
			font-family: 'VT323', 'Courier New', Courier, monospace;
			background-color: black;
			caret-color: white;
			border: 2px solid gray;
			color: white;
			font-size: 24px;
			padding-left: 12px;
		}
		input[type=text]:focus {
			border: 2px solid lightgray;
		}
		#boxcentertop {
			z-index: 1;
			width: 80vw;
			max-width: 400px;
			height: 50px;
			position: relative;
			top: 30px;
			display: block;
			margin: 0 auto;
		}
		.hidden {
			display: none !important;
		}
		#onhover {
			background-color: rgba(0, 0, 0, 0.9);
			color: rgb(200, 200, 200);
			font-family: 'Courier New', Courier, monospace;
			word-wrap: normal;
			width: auto;
			max-width: 400px;
			position: absolute;
			z-index: 1;
			padding: 10px;
			cursor: default;
		}
		#quota {
			display: block;
			position: absolute;
			width: 99vw;
			margin: 0 auto;
			bottom: 110px;
			z-index: 1;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			text-align: center;
			color: white;
		}
    #messagesHolder{
      position:absolute;
      z-index:2;
      top:0px;
      left:0px;
      background:#000a;
      color:white;
      font:18px 'VT323';
    }
    #messageInput{
      border:none;
      background:transparent;
      width:100%;
      min-width:100px;
      color:white;
      font:18px 'VT323';
    }
    #onscreenControls{
		    position:fixed;
		    font-family:monospace;
		    bottom:10px;
		    width:100%;
		}
		#onscreenControls button{
		    margin:0;
        min-width:calc(100% / 13);
        min-height:40px;
        border-radius:0px;
        background:#888;
        border-color:#aaa #666 #666 #aaa;
        border-width:2px;
        border-style:solid;
        color:white;
        outline:none;
		}
		#onscreenControls button:active{
	      background:#9a9a9a;
        border-color:#888 #aaa #aaa #888;
		}
		#onscreenControls #buttonsRight{
		    position:absolute;
		    bottom:10px;
		    right:10px;
		}
    #onscreenControls #buttonsTop{
		    position:absolute;
		    top:10px;
        left:10px;
        width:calc(100% - 20px);
        display:flex;
        align-items:center;
		}
    #loader{
      background:black;
      color:white;
      position:absolute;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      font-size:40px;
      font-family:Arial;
      display:flex;
      justify-content:center;
      align-items:center;
      flex-direction:column;
      z-index:2;
    }
    #loader .name{
      font-size:60px;
      font-family:VT323;
    }
	</style>
	<body>
	<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
	<input type="text" id="savebox" class="hidden" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;">
	<input type="text" id="boxcentertop" class="hidden" spellcheck="false">
	<div id="quota" class="hidden"></div>
	<div id="onhover" class="hidden"></div>
	<p id="savedirections" class="hidden" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
		To save your world, copy/paste the saveString<br>
		from this box into the code on line 189.<br>
		var loadString = "Your Code Here";<br>
		Then save the program as a Spin-off.
	</p>
	<div class="world-select hidden" id="worlds"></div>
  <div class="world-select hidden" id="servers">
    <div class="world"><strong>The One And Only Server</strong><br>Start if not started</div>
  </div>
  <div class="world-select hidden" id="marketplace"></div>
	<p id="message" class="hidden" style="position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"></p>
  <div id="messagesHolder" class="hidden">
    <input id="messageInput" class="hidden">
    <div id="messages"></div>
  </div>
  <div id="onscreenControls" class="hidden">
	  <button style="visibility:hidden;">&nbsp;</button><button id="controlW">W</button>
	  <br>
	  <button id="controlA">A</button><button style="visibility:hidden;">&nbsp;</button><button id="controlD">D</button>
	  <br>
	  <button style="visibility:hidden;">&nbsp;</button><button id="controlS">S</button>
    <div id="buttonsRight">
      <button id="controlSpace">space</button>
      <br>
      <button id="controlShift">shift</button>
    </div>
    <!--<div id="buttonsTop">
      <button id="controlPause">Pause</button>
    </div>-->
  </div>
  <div id="loader"></div>
	<script>
		// Code edits will erase the world.
		// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
		var loadString = ""
	</script>
  <!--url for parkour map: https://www.khanacademy.org/cs/i/4676725830008832-->
 	<script type="x-shader/vertex" id="blockVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		attribute float aShadow;
		attribute float aSkylight;
		attribute float aBlocklight;
		varying vec2  vTexture;
		varying float vShadow;
		varying float vFog;
		uniform mat4 uView;
		uniform float uDist;
		uniform vec3 uPos;
		uniform float uTime;
    uniform vec3 skyColor;

		void main() {
			vTexture = aTexture;
			// If you are going to change this final lightlevel calculation
			// you have to change line 4487 as well since it calculates lightlevel of entity based on this
			vShadow = aShadow * min(max(aSkylight * uTime, aBlocklight) * 0.9 + 0.1, 1.0);
			gl_Position = uView * vec4(aVertex, 1.0);

			float range = max(uDist / 5.0, 8.0);
			vFog = clamp((length(uPos.xz - aVertex.xz) - uDist + range) / range, 0.0, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="blockFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uTime;
    uniform vec3 skyColor;
		varying float vShadow;
		varying vec2 vTexture;
		varying float vFog;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(mix(color.rgb * vShadow, skyColor * uTime, vFog), color.a); //sky color here
			if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="x-shader/vertex" id="entityVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		varying vec2  vTexture;
		uniform mat4 uView;

		void main() {
			vTexture = aTexture;
			gl_Position = uView * vec4(aVertex, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="entityFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uLightLevel;
		varying vec2 vTexture;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * uLightLevel, color.a);
		}
	</script>
	<script type="x-shader/vertex" id="2dVertexShader">
		attribute vec2 aVertex;
		attribute vec2 aTexture;
		attribute float aShadow;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vTexture = aTexture;
			vShadow = aShadow;
			gl_Position = vec4(aVertex, 0.5, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="2dFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * vShadow, color.a);
			if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="application/javascript">
"use strict";
window.canvas = document.getElementById("overlay")
window.ctx = canvas.getContext("2d")
window.savebox = document.getElementById("savebox")
window.boxCenterTop = document.getElementById("boxcentertop")
window.saveDirections = document.getElementById("savedirections")
window.message = document.getElementById("message")
window.worlds = document.getElementById("worlds")
window.servers = document.getElementById("servers")
window.marketplace = document.getElementById("marketplace")
window.quota = document.getElementById("quota")
window.messages = document.getElementById("messages")
window.messageHolder = document.getElementById("messagesHolder")
window.messageInput = document.getElementById("messageInput")
var hoverbox = document.getElementById("onhover")
window.onscreenControls={
    w:document.getElementById("controlW"),
    a:document.getElementById("controlA"),
    s:document.getElementById("controlS"),
    d:document.getElementById("controlD"),
    " ":document.getElementById("controlSpace"),
    "shift":document.getElementById("controlShift"),
}
window.onscreenControl_Element = document.getElementById("onscreenControls")
canvas.width  = window.innerWidth
canvas.height = window.innerHeight
window.loader = document.getElementById("loader")

let touchScreen = "ontouchstart" in document
if(!touchScreen) onscreenControl_Element.style.display = "none"
function Geekycraft() {
	// cache Math object
	const { Math, performance, Date } = window;
	const { cos, sin, round, floor, ceil, min, max, abs, sqrt } = Math;
  Math.PI2 = Math.PI / 2

  // Shh don't tell anyone I'm override native objects
	String.prototype.hashCode = function() {
		var hash = 0, i, chr;
		if (this.length === 0) return hash;
		for (i = 0; i < this.length; i++) {
			chr   = this.charCodeAt(i);
			hash  = ((hash << 5) - hash) + chr;
			hash |= 0; // Convert to 32bit integer
		}
		return hash;
	}
  
	let setPixel, getPixels;

	const textures = {
		grassTop: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const d = Math.random() * 0.25 + 0.65;

					const r = 0x54 * d;
					const g = 0xa0 * d;
					const b = 0x48 * d;

					setPixel(n, x, y, r, g, b);
				}
			}
		},
		grassSide: n => {
			const pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");

			for (let i = 0; i < pix.length;i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}

			const { random } = Math;

			for (let x = 0; x < 16; ++x) {
				const m = random() * 4 + 1;
				for (let y = 0; y < m; ++y) {
					const d = random() * 0.25 + 0.65;
					const r = 0x54 * d;
					const g = 0xa0 * d;
					const b = 0x48 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
		leaves: n => {
			const { floor, random } = Math;

			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const r = 0;
					const g = floor(random() * 30 + 100);
					const b = floor(random() * 30);
 					const a = random() < 0.35
						? 0x0
						: 0xff;

					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		/*oakPlanks: n => {
			for (let y = 0; y < 16; ++y) {

				const a = 3 === (y & 3)
					? 0.7
					: 1.0;

				for (let x = 0; x < 16; ++x) {
					// these conditions are weird; can some comments be added here?
					const mid = x === 8 && (y & 7) > 3 && a === 1
						? 0.85
						: 1;

					const rit = x === 15 && (y & 7) < 3 && a === 1
						? 0.85
						: 1;

					const r = (Math.random() * 0.1 + 0.9) * a * mid * rit;

					setPixel(n, x, y, 190 * r, 154 * r, 96 * r);
				}
			}
		},*/
    oakPlanks: "0g0g70ru00lb0yicsfz156v7cv17fehvj1bvja4f1f7pou71hfxp8f5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		hitbox: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					setPixel(n, x, y, 0, 0, 0, 0xff)
				}
			}
		},
    crack1: "0g0g20000000000006o0000000000000000000000001000000000000000100000000000000010000000000000000000000000001000000000000000100000000000000010000110000000000000001000000000000000100000000011000000000000011000000000000000000000000000000000000000010000000000000001000000000000000011",
    crack2: "0g0g20000000000006o0000000000000000000000001000000011000000100000000000000010000000000100000001000000001000011000000000110110000000000010101110000000000000101000000111100010100000000011001111100000011000100000000000001110000000000011000010010000000000001101000000000000000011",
    crack3: "0g0g20000000000006o0001000000000000000100001000000011010000100000000000100010001000000101000001100000011110011010001111111110011000001110101111011000100000101111000111100010110000001011001111100001111000100001111110001111000000001011000110010000100000001101000100000000000011",
    crack4: "0g0g20000000000006o0001001000000000110100101000100011110010101100000110101010101000001101111001100100111110111011111111111111011000111111111111011000101111111111000111111110110000001011111111100001111010100001111110001111000000001011110110010000100001001101000100001100000011",
    none: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					setPixel(n, x, y, 0, 0, 0, 0)
				}
			}
		},
		dirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
		stone: "0g0g40sywflr0wb8hdr0zdjj0f13tzldr3333211210112222221212222220012121001110111222222233232233222111122111212333312223222222211010131223331331112222110010112211122233323223332222212232223332233332021211001212211122222332222233232111232112200101332112211122111321122222222233332222221123322122",
		logSide: "0g0g60fl1ssf0l5j1fj0qftm2n0wa7mdb14cs7wf16az8xr3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		logTop: "0g0g90l5j1fj0qftm2n0wa7mdb0z2esxr15quebj189da7z1cpma671f7ppfj1hzyayn1012101120110111077776768667777017334454555544811738877776777471164766666666756107576445544674601646636666466471165764655656756116576465464674610657646666566460164764434556756116576666666674610757767777787460175454444444447117776676686677711011101120110211",
		bedrock: "0g0g509gy58f0e7f7r30o8fd330rkrev31627mkf3111124324211212133434341443012110110111412224232433202422111112014111121134433112221221102211014432344323443410222122211011213234421122344344442110121213211143334134410144431102221123442334402111321134111112343420211101234433211211234421121011044312301123",
		glass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
		cobblestone: "0g0g60muaccf0r0pekf0un11q711vr5rz1a8mosf1ef1r0f2144011454313543145330554330132314342143342101321132113232134310021354131154443152453321033543234313433211243215332233213541231321542213533311021543232233121341323231101221044532211235411035532354215434213323154331432332113244323212332143111311232121135432",
		mossyCobble: "0g0gb0muaccf0mupnnj0p38xdr0r0pekf0rbmj9b0un11q70w1wkxr0y07svz11vr5rz1a8mosf1ef1r0f4199211276438a9619a8812764813858398951644251118533852182851464110531183233866642a176895308948428981498852118851988111851664158385117641484642305126244558824124185442111155214698112124761318998127651764653885847488164588511858685851588531841183352111338a984",
		stoneBricks: "0g0g70p2gyyn0rkrev30tj2nlr0xf9ou70zdjj0f12psrnj17g8flr5666666666665550645455555444445065454444445534406434554345434330632334544334324053244333345324302222222222222220110011000111111166666650566666663555544065455554544544306435354445544320634344454444343053345433332322305443344322222220222222221111110000111111",
		mossyStoneBricks: "0g0gc0mupnnj0p2gyyn0p38xdr0rbmj9b0rkrev30tj2nlr0w1wkxr0xf9ou70y07svz0zdjj0f12psrnj17g8flrab3668863b88a680b9a28683a9999332ba926363996a2931b9792a679a979721b737793993697591a72397773632297075225752332277924410441110000444886bbba1abbbb6883aaaa991ba9aaaa6a99a9971b97a7a399aa99351b797992a99997371a689a97777573371a897799755223791722757754000041110004400",
		bricks: "0g0g90vz62nz0yhavi712oqn7j13rinsv173m8lb193f4zj1b1w1rz1d7u7sv1j1u51b7742888777458777443513444435144410060033100503112256522225565222887747458777474214444315133333151341110600133105522225565522225677458887474588774435344444153444110511331106133325565222225652224777474287774745144444353444441501111106011111065222225655222566",
		coalOre: "0g0g70ehg7wf0hjr9j30j7xaf30sywflr0wb8hdr0zdjj0f13tzldr6556544543445666554536666553335454331453344511556665655105655644455443346545645556553215542143464552111065105555433556663334466661156543215455645565354100056665354514334663354455555666634106655443366412111054665105556005455554456665566544455555554655555566",
		ironOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1cpl2bj1gbvabj1o4exa71qwyvb33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217510131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167666421332542223442122221123332233211122222221322222233",
		goldOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1x01czj1y6gem71z13ncv1z141z33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217610131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167655421332642223442122221123332233211122222221322222233",
		diamondOre: "0g0g80h634zj0sagdtr0sywflr0wb8hdr0zdjj0f13tzldr1845xbz1ndl24f5445433432334555443425555442224343221342233461445554544604544533344332235434534445442764437632353447611054104444322445552223355556145432764344534454243600045554243413223552243344444555523605544332255367611043554604445004344443345554455433344444443544444455",
		redstoneOre: "0g0g90sywflr0wb8hdr0zdjj0f13oi67z13tzldr15wexa71b68mbj1f24cfz1yr4gsf4224211210112444221204444220002121005120011285224442422832422411122110014212412224220862218610141227655342532222100224440001144448524210862122412242021633324442021251001440021122222444401834422110044168655321442832224332122221124442244211122222221422222244",
		lapisOre: "0g0ga04hvenz04hvl6n04ihywv066fd3306r2ozj08z4sfz0sywflr0wb8hdr0zdjj0f13tzldr9889877876778999886669999886668787454386777813889889926329989977788776679867978889866428862576797861242398238888723679978767799993189872643386678998687222236258686627661237725788300799668893588779906612366339998700381039799887783339899877788888899888888899",
		emeraldOre: "0g0g7004swsf06mdmv30sywflr0wb8hdr0zdjj0f13tzldr1ohjdhb5445432232334555443445615442334343223310333422445555225555546133344361324555104445441061243255353445551054434444332232552323355555545461442244534444441053615224243433223310361344444556155551044223455103322553261334455444344441045554455433344554443544444455",
		coalBlock: "0g0g501e50xr03md24f05ul3b308mtq0v0bf3ri73322122002210012222121000210123321000122000022221001243222202210001233222100210020222221000001220132211001122222022210122343221002110123322210000012123221103200212122210002211232102112210012230002113432123322000123420023221000123210012221001222212212221000",
		ironBlock: "0g0gb1dawbnj1fj5rlr1hrdssf1m7r1mn1nlyvwf1pa4wsf1qe8xdr1s2ey9r1t6iyv31tqkz5r1ver01r32233333333222232aaaaa9998777772277777777777777105555555666444402aaaaaa999777771277777777777777105555566664444402aa9999977777771277777777777777105555555566644402aaaaaa999977771277777777777777105555556666444402aaaa9999777777127777777777777712222222112111111",
		goldBlock: "0g0g91kr8um71mphb0f1w77ain1xakkqn1ypvwu71yr43jz1yzk7pb1z0cef31z10mwv2222332223333221285577888776688125664877623324812564877462224471374777462264467137777462267762302877444667762330287444664462232037444664466222613744664466662461364667766666742032667762262776203267762332446261334462332666224132322332662264701101100011001100",
		diamondBlock: "0g0g90434min061d2in0h634zj0l2fpxb0sagdtr0vckf0f1845xbz1ndl24f1z141z33333223332222331378866777664477138445766432235713845766543335561265666543345546126666543346643203766555446643220376555445543323026555445544333412655445544443541245446644444653023446643343664302346643223554341225543223444335123233223443345601101100011001100",
		redstoneBlock: "0g0g50vx660v153407319j36671gh49a71runlz34444444444444444433433222334333443342202222232344332311001120234443211012011244443210000000042344302100000011134421100000000122442231000000111344324110210111234432110004001224443321101001110344322211111122224443124211022323443334433223333344444444444444444",
		lapisBlock: "0g0gd05lqqkf06zt0xr07js8hr07tw35r084kzr308e6ein08e99fj08yjpq708ys8ov0an2j270c0w4cf0dp94hr0fdf5kv98999989cb848484878b78736733677197b8867767623765967877377863366597687666378a63759a77776636a7736197a767676236763596763666a6233625c636636376632775c633687363332371963237873676327186672236338763619763722332677630877633332336667143766633633367708111111610220000",
		emeraldBlock: "0g0g606lfrb306mdmv307ei5fj07xmdbz0iaro5b10c5ptr0000000000000002055555454551144305000000200002430404555411114243050500000002425305050555445212130405054411421203040405451142120305040411020202130404041122120213042105410112420301212222222242030405510000441213012222222222224301011001110014532333333333333332",
		tntTop: "0g0g704qh5a70nyecxr13jyl8f14a4flr1d4tukf1otd8u71szz8jj5665566556655665622462246224622462136210012300234431403344004433566006655660566562246204121402246211120000231023443341000111403356651000000506656211020001140224621360200120112344331031140344335661560500611665621462146124612462236223622362234433443344334433",
		tntSides: "0g0ga07ipw5b0fbhzwf14a4flr1d4tukf1gwtvcv1ldqupr1otd8u71pk09vj1szz8jj1z141z38863886388638863663266326632663266326632663266326632663266326632663266326632663295775577755777799711071550711059745055115157177795717717115505479750571550550759444444444444444433223322332233226632663266326632663266326632663266326632663266323332333233323332",
		tntBottom: "0g0g413jyl8f14a4flr1d4tukf1otd8u72332233223322332300130013001300130013001300130011111111111111111233223322332233230013001300130013001300130013001111111111111111123322332233223323001300130013001300130013001300111111111111111112332233223322332300130013001300130013001300130011111111111111111",
		acaciaLogSide: "0g0g60ma181r0oi99fj0pcavi70t8nim70y9464f139ktmn3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		acaciaLogTop: "0g0gb0j7rlz30kvxmgv0ma2nen0o889hb0t8nim713rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf432332211231433449999898a889999329556676777766a2395aa999989996910869888888889782197986677668968318688588886886932879868778789784487986876868968448798688887886833869866567789782287988888888968219799899999a96811976766666666691099988988a8899933412233444322114",
		acaciaPlanks: "0g0g711t8qgv13rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466656666535455554333434332654433334444335300122100012110006556655366646566445533433555544443345432554333330110012221010000",
		birchLogSide: "0g0g80f1fcov0qqliwv1gxap6n1o60u7z1ptrf271uar6db1uum5mn1z141z36643366634663366346666777634443677744367666636777732100136777737366321101377631211336344363331001266344677766532343777777334556376336775577775777764455577766336336777766634477636777767777577634436633667553210026677763443100000133377761132116331677764336336",
		birchLogTop: "0g0ga0mk6h3316m5am719xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm71tgjy7z1z141z39818811001809889966665657556666816223343444433718627766665666360153655555555645106465334433563580535525555355368154653544545645995465354353563599546535555455358853653323445645115465555555563510646656666676350064343333333336016665565575566688901188999811009",
		birchPlanks: "0g0g717znmrj19xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm75456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		darkOakLogSide: "0g0g60besef30dcwlbz0e6y70f0hj7ev30klcs8v0oho0e73143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		darkOakLogTop: "0g0gb08ml79b0auqebj0dcmqdb0e6y70f0f117gf0g4r4730h8wirj0hj7ev30kb0idb0lz2akf0n393wf741441100140744779999898a889999419225565666655a1492aa999989995903859888888889681096985566558958408588288885885941869858668689687786985865858958778698588886885844859855256689681186988888888958109699899999a95800965655555555590399988988a8899944701144777411007",
		darkOakPlanks: "0g0g70bejy0v0dcmqdb0g4r4730h8wirj0kb0idb0lz2akf0n393wf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		jungleLogSide: "0g0g90h96cxr0htdywv0m9k4xr0ne277j0orqc5b0rkbldr0sxvim70wunksf0ys83cv4688422222666444444114414441001111137510011441866644668842422224146644411143573444422235311010006646442222444886101000466412222444688411068844441122575311222100755444666664355741100112241201661144866643341111623533422111444644111004661664444664122244442222",
		jungleLogTop: "0g0g90h96cxr0htdywv0rkbldr0ys83cv160fym7188mku71batekf1f77h1b1h5ei2n3212210011213223377776768667777217444454555544812748877776777470164766666666756107576445544674620646646666466472165764655656756336576465464674633657646666566462264764444556756106576666666674600757767777787460175454444444447117776676686677722310122333211013",
		junglePlanks: "0g0g70sxkd1b0xdxkov160fym7188mku71batekf1f77h1b1h5ei2n5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		spruceLogSide: "0g0g60csc9vj0cskpof0dmmb5r0geuxof0lf4i670nnb4sf3243304330342431325130513034233130113051323223314031323131302341423130315131324343234232514232431323411343433243130343143341314332053314314141433325331331424303333431303132430332343130533053235233414051303313532343324132333343243340323224334324234232332431",
		spruceLogTop: "0g0g80ix87pb0nnb4sf0p1n6db0qzu7zz0v5xypr0xy569r106bshr11ueyv31012101120110111066665657556666016223343444433711627766665666361153655555555645106465334433563501535525555355361154653533545645115465353353563510546535555455350153653323445645115465555555563510646656666676350164343333333336116665565575566611011101120110211",
		sprucePlanks: "0g0g80nnb4sf0p1n6db0qzu7zz0v5xypr0xe36rj0xy569r106bshr11ueyv36567777767777762665523566655663356665643333556622112210011010010673777737776553656653532355666653356555266655333001121000011121067765577777777636566665333535332765533335555336300122100012110007367766377737677556633533665655553356532665333330110012221010000",
		sand: "0g0g61m6x62n1nb9nnj1opn5dr1r80f7j1scbi0v1u0izgf4223213232132313122121130142502432011422222121122331213133132122125213232322122321223332123122121421151211022121212212212111242112322310131232124212221120212231202321232232012311223212331112121213132145321123323230232323221223235332323203223232332321223232",
		gravel: "0g0g80rufq4f0vqwlbz0zxiprz125i9rz15rvcan1627mkf1d0twqn1dackxr0341152512122521522122312102333522103133522351352232321522512322132741122210253202140133526552213104226515530122553253522311225353521223310256122311652152322132123553102521325022533562113225212132222537415525331025232422215235323311243310351274122232321212",
		blackConcrete: "0g0g40149on3028826702882yn028dp8f1330112022012232303130022112212111032203010022012122012222321221011223213030101033110011212233120230013131003200032022012002002112233122202312230200102211312102222122132011021201223320211021220121122122321331201102120210001220112022023302312210123220102110",
		blackWool: "0g0gf0149on3028826702882yn028dp8f03cc2rj03cc3jz03chptr04gg3cv04glqf305kk3y705kpr0f06oo4jj07ss54v08ww5q70a106bj46348b45ab13993299eebb7742570367bc77dc97bcbbdeb996bc768c47cc96ec9749bb115953bb31314c414641672547eebb8879bea7eeb966eebacc45bca9ccbb35ca4657528733577b117949ee7beeccbbecbacb799839349966bb445911796611cd318b9bee92badecb9717bc77cedc97c99beb559b6424c946cd76ac44bc",
		blueConcrete: "0g0g30c98pof0c98qgv0c9ecqn1000001101000201011001000101120101211111010200000001000110100100220110011001121111001100100100010200102101101000000011110001101010101011020111110000000101121111101100100100010110111010210111001101000100000111110100101111000120000010100000110001200110010002",
		blueWool: "0g0gj0c98pof0c98qgv0c9ecqn0c9edj30ddcr270ddidbz0ddie4f0ehgrnj0ehgsfz0ehmepr0ehmfi70flkt1b0flqfb30flqg3j0flw2db0flw35r0gpugov0gq02yn0gqbd3335237c44ac12992289iidc6632460256de67ge96cebbhic985ce657e46ee85ie9648cc114942cc21214e413541562436iidc7769dia6iic955iicaee34cea9eecb24ea4546427622466d116949ii7biieecciecaed699728249955cb344911695511eg217c9bii92bahiec9617be67eigf86e99cid449b5324e935eh65ae34de",
		brownConcrete: "0g0g30pl5gqn0qp3u9r0qp9hbz0211211202222221222122211211122121011102222222212211200222112101121111211111222121222122122221201212121222112122222221220222222122221201121212022122122110221211122221211011221212121010121011111212122221121221222212122112112112211010222111121211220222221122",
		brownWool: "0g0gi0qp3u9r0qp9hbz0rt7uv30rtdh4v0sxbunz0sxbvgf0u1a8zj0u1fv9b0v5e8sf0v5e9kv0v5jvun0w9i9dr0xdgmwv0xdm9z30yhkni70yhq9rz0zloo3j0zluadb35228d45bd12aa219bhhed7721570257ef77gfa7dfccghdb95df758f47ff95hfb749dd115a52dd21214f413541571526hhed887aehb7hhda55hhdbff25dfbbffdc25fb4557518722576e117b4bhh7chhffddhfdbfe7ab82924bb55dc245b116b5511fg218dachhb1cbghfda717cf77fhgg97fabdhe55ac5214fa25fg75bf24ef",
		cyanConcrete: "0g0g305objsv05obklb05oh6v31112010122111202100121222111122012212211101111202102221210222122211111211221111011021102021212212220211021022022201210110010212210211110202101010201110112020221222112102111202212110222110211221001010211001221212202222122111221102211100222112011211120220211",
		cyanWool: "0g0ge05obklb05oh6v305omt4v05omtxb05osg7305oy2gv05p3pj305p9bsv05p9clb05peyv305pkl4v05pklxb05pq87305pq8zj242269347912662167dda95521450145ab55cb659b88cd97649b546b35bb64db7536991146419921113b312431451424dda96656ad75dd9644dd97bb249b77bb9814b73445416521454a115737dd58ddbb99db97ba56762623774498234711474411bc116968dd7187cdb965158b55bdcc65b679da44684213b624bc547b23ab",
		grayConcrete: "0g0g20ehlvr30flk9a70000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000001000000010000",
		grayWool: "0g0gd0ehlvr30flk9a70flpvjz0flpwcf0flvim70gptwxr0gpzjzz0htxxj30hu3jsv0hu3klb0iy1y4f0iy7ke70iy7l6n333359337803663157cca85531350135ab55cb658b88cc87539b545b35bb53ca7535990036329930103b303330350335cc995556ac75cc8633cc87ba339b77ba8813a73435305532355a005737cc58ccab88cb87ba56753533773498333700574300ac205968cc7087cca865058b55bccc55b679ca33684313a634bc537a33ab",
		greenConcrete: "0g0g20k2mku70k2s73z0001000100111100101010100101101101101100111010010111001001011000100001100011000100101010110101111010000001011001001000100001010110101110010011010000101011110000010110101000000001010000110101011101000111110011101010011000111100001100011000000111101001101100",
		greenWool: "0g0gh0k2mku70k2s6bj0k2s73z0l6qjun0l6w64f0l71rlr0mb054v0mb5qm70mb5ren0nf9qf30nffcov0ojdq7z0ojjbpb0ojoxz30pnnbi70pnsxrz0rw0y6746447c45ab1499419aggcb8841580168ce88ee98bebbfgba96ce867e48ee96gda849cc125953cc41114e424642681546ggcc7789cga8ggb966ggbaed45ceaaedbb15da4658517843586c21894agg8bggdebbgebaec89a749449966cb445a116a6621de327c9bgga1bafgdb9828be88egee98e9acgc559b6414d946ef86ad44ce",
		lightBlueConcrete: "0g0g3090ti4f090z4e70a4xipr2120111111121222222121122112211121121211112221221111102221122212112021111111122111112111112121211222221111122121212121112021122112211121211211111121220111212121111121222001122211222221022122111011221111111021211221211211121112212111111122121111211112222111",
		lightBlueWool: "0g0gq090z4e70a4xipr0a534zj0a58r9b0b974sf0b9crun0b9ie4f0cdgrnj0cdmepr0cds0zj0dhqein0dhw0sf0dhw1kv0em01dr0em5nnj0fq9o8v0fqfain0gudou70gujb3z0hyhon30hynawv0hynbpb0j2lp8f0j2rbi70k6pptr0latpmn7b57fm89ik26ff63fippnkdd739d04benodepogdkojjppkifblodcfo8doofbpoie8fml21af95mm62428o817b81bd397cppmlffefnpidppkgbbppkioo79loiiookj4aoi8cad93fd55adcn22dh8ippejppookkpokiondfif6f68hhbcmj78ai22cicb22op51fmfjppi3jippokfd2ejoeeoppofdofilpn9agjc738og7copebio78no",
		lightGrayConcrete: "0g0g20yjgg730yjggzj1000110001001010100010000000011101100010001001011010001100101010001000000000000010100000000100010100000000001010100010001000000000100000110000100001100000011101110001001011001001001001011000000000011001001001001010000000010000000010100110000000001000001001",
		lightGrayWool: "0g0gi0yjgg730yjggzj0znkgsf0znkhkv10rohdr10roi6711vshz311vsirj11vy5tr12zwjcv12zwk5b1440jy7144670f1584kjj1584lbz16c8l4v16c8lxb17gclq745339e55bd1399329bhhfd7732570257ff78hfa7dfcchhdb95df769f57ff95hfb759ed115953ee31215f514551572537hhed9979fhb7hhda55hhdbff35dfbbgfdc25fb5657529733577f117b5bhh8chhfgddhfdbgf79b93935bb56ec355b117b6511fh319e9chhb2cbhhfd9718cf78fhhg97f9bdhf55ac6325fa36fh75bf35ff",
		limeConcrete: "0g0g30ppd5a70ppirjz0qth5331121111111100111111111110111110111010211100110111211111211101111112111111111111101110111011110211011011110111110102111110100111000110112112110211112112112111212111111111111111011111011100101111111111212111111111112010011011221111111110111120011110111101111",
		limeWool: "0g0gg0ppirjz0qth5330qtmrcv0rxl4vz0rxqr5r0t1p4ov0t1uqyn0u5t4hr0u5yqrj0v9x4an0va2qkf0we143j0xi53wf0ym3hfj0ym94hr10uh5of35237c44bb1299228affcb6632460257cd67ed96bdbbefba85bd657d46dd85fca748cb104942cc21214d403540562435ffcb7779cfb6ffb955ffbbdc34bdbaecbb24cb4546427622465c01694aff7bffcebbfdbbec69a728249955cb344a105a5501ce207c9bffa2bbefcb9607bd77dfee86d9abfc449b5324c935de75bc34cd",
		magentaConcrete: "0g0g419jw2rj1anugan1ao02kf1ao03cv2233313332221332333333233213322333223332331233333313323103121223222131233211303233130230322231223302323103002220333103232232223333313231221331233333231232212303302330122232333333332123320111033031332321233232303322232223332223231233212323332233222231230323",
		magentaWool: "0g0gs1ao02kf1ao03cv1brygvz1bs435r1bs43y71cw2hhb1cw83r31cw84jj1e06i2n1e0c4cf1e0c54v1f4ainz1f4g4xr1f4g5q71g8ej9b1g8k5j31g8k6bj1hcijun1hco64f1hco6wv1igmkfz1igs6pr1igs7i71jkw7b31jkw83j1kp08ov1lt49a71mxdwxr6945dl77ij14ff43ehrrmjba537a039cmoacqogajojjqrjhe9koa9do7booe9rnhc7elk118f74ll41317o7169719a275arrmkddcfmribrrjg99rrjion57koihonjj38ni798a72db448bam11bh7hrrcjrrnojjrojiomafhd4e47hh99lj578h11ah9911nq41dlfjrrh2jiqrnjfa1cjoccorqpebofhkrm78gj9537ng59oqc9in57mo",
		orangeConcrete: "0g0g21p59iwv1q97wfz1011110111101111111011111110000111101110100111111110011111011001001101110110111111111110111111011111101110111111110111111111111111011110111101111011101101101111010010111111110110101110010011101111111010101001101111111011111110111111111001111111101111111111",
		orangeWool: "0g0gm1q97wfz1rdbw8v1rdbx1b1rdhjb31shfwu71shfxmn1tljxfj1tljy7z1tlpkhr1upnytb1uptl331uptlvj1vtrzen1vtxlof1vtxmgv1wy1m9r1wy1n271wy79bz1wycwe71wyijgf1wyo5q71wytssf46239f55de02aa219dllhe8731570268hi79kib7eieelled96fi779i58ii96lhd859ff005a52ff20205i504650671537llgf998ahld8lleb66lledih35fiddihee25hd5757519822587h008c5dll9ellhieeliedih7ad92925cc67fe355d007d7600hk209faelld1edllhea709ei89ilkj98iadflh55be7315hb37il86dh35hi",
		pinkConcrete: "0g0g31ltks8v1mxj5rz1mxj6kf1122212121112211111211211211122112111221111111121211212111122211111112112121112111111111111112111212221121111111212211112101110212211211122111211112212111211110211211211211111111121212221211121111112212211121211111211212211111111111121112111211212122122111",
		pinkWool: "0g0gv1mxj6kf1o1hk3j1o1n6db1p5r6yn1q9v6rj1q9v7jz1rdz7cv1re4uf31si37y71si8u7z1tm78jj1tmcutb1tmcvlr1uqgven1uqmigv1uqs4qn1vuqj271vuw5bz1vuw64f1vv1se71vv7fgf1vvd1q71vvd2in1vviosf1vvipkv1vvobun1vvocn31vvtywv1vvzlz31vw588v1vw591b6a46em78jk25gg53fjuuokdc638c03adoqcesqhckqkktukjfalqcbeq7dqqfaupjd7fml219g83mm52327q716a71ac386buunleedgoujduukhaauukjqp68lqjjrpkk39pj7b9c83ed439dbo12di7juuekuuprkkuqkjrocgje5f57iiabmk679j22bjba12ps31emgkuuj3kjtupkgc1ekqdequssfdqgjluo89hkb637ph6bqtdajp67oq",
		purpleConcrete: "0g0g40qo16v30rrzke70rrzl6n0rs57gf3222322033323333333312320220233231302222232332333202332233033330333322320012333323333330233022223332223332223232323303323233332332021220323110033223333322032332312323332322322202232223033232221223233023333332022233332332233232023333233223032323332323323332",
		purpleWool: "0g0gm0rrzl6n0rs57gf0sw3kzj0sw3lrz0u01zb30u07lkv0u07mdb0v45zwf0w84dfj0w84e7z0xc8e0v0xc8etb0yg6scf0ygcem70zkasxr10o96gv10o979b10oetj311sd72711sd7un12wh8fz154uxhb47349e45ce13aa32acllfe8742570279fh79jhb7ehddkleca7eh779h48hha7lgc94aee116a52ee31214h414741771547llfe999aflc8lleb77llechg45ehcchged26gc4767519832687f118c4cll9dllgheelhechf7ac93a34cc77ed446c117c7711gj219eadllc1dcklgea719dh99hljia8hacelf56bd7424gb47hk97cg44fh",
		redConcrete: "0g0g112voa9r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		redWool: "0g0gd12voa9r13zmnsv153l1bz167jev3167p14v17bnenz18fls7319jprzz1ano5j31ano6bj1brmjun1brs64f1f3yku7241258227712662157cc9754212401459b45bb647b77bc77548b445b25bb54ca7525881036218821112b202420441224cc8855569c75cc7644cc77ba228b77ba7713a724342155113549015627cc57ccab77cb77b946752522664487223711474401ab105867cc7177bca764057b55bcbb55b678c923674212a624bb547a229b",
		whiteConcrete: "0g0g31ktui9r1ku04jj1lxyi2n1121212211221121111221111121122111211111121112111212112211111211212222111111221112211112101110211111122211211211111111212221111112212121212222111121122211111111222111111112121222121111111111211121221112221111121222121112212122111221211212111121221211221212",
		whiteWool: "0g0gn1lxyi2n1lxyiv31ly454v1n22inz1n22jgf1n285q71o66j9b1o66k1r1o6c6bj1paajun1qeekfz1ricyrj1riil1b1smgykf1smmlmn1tqkz5r1tqqm7z1uuozr31uuumtb1vyt0cf1vyynen1x2x0xr1y711j37a56dj89hi26ee63egmmliba639a04acllacmlfailiimmigeajlaadl8blleamlgc8ejj219e94jj62429l817a81aa396ammkjddcelmhbmmifaammihll69jlhgllii49lh8a9a93db549bal12bg8gmmcimmlliimlihllaegd6e68ggaaji689g22agaa12lm41djeimmg3ihmmliea1cilcclmmmeblegjml99fia638lf6almcahl68ll",
		yellowConcrete: "0g0g41to1w5b1us09of1us5vy71us5wqn2111111122222221232021021213122222211020112110121211022201012212122222312211221122213110202011133121132211112221221211211111112120231210211111201132001211212111211102220222021102211223011100222121202222222132111211111112111112021121120222221222011012122121",
		yellowWool: "0g0gj1us5vy71usbj0f1vw9wjj1vwfitb1vwfjlr1vwl5vj1vwl6nz1vwqsxr1x0p6gv1x0utj31x10fsv1x10glb1x163nj1y54h6n1y5a48v1y5a51b1y5frb31y5fs3j1y5lf5r45239e44bc0299219biiec7731470158eg78hga7cgcchicb95dg759g47gg95ifb849ed005942ee20104g404540571436iied9989eib7iica55iicbgf34dgbbgfcc15fb4557419722576e007b4bii8ciifgccigcbge79b92924bb55ec345b006b5500fh209e9ciib1cbhifc9708cg88gihh97g9bdie45ac5314fa35gh85bf34eg",
		bookshelf: "0g0gt03fxnnj04laqdb0a0ot1b0b6j6db0c8r6db0deww730df88ov0egz6rj0gpo9330ht5kov0k20av30nf40zj0pnc1dr0qoh8fz0sy416n0w8kcn30wc5n9b0yicu0v11vb08v11vskcf13z03jz16atkvz17fehvj1as1ce71czhmv31e50qv31g6nvgf1gbtpfj1ks44qnommllhlllmmmmlmoo44477444772534oo799kk999ni9637olkffqk99gpjk631lsqffqk64gnik631soqfdqf6gcngf651ookd9kf3c7igf350mlorrsssroorrroolollmmhmllmmmllhoo77227cb7427724ooqk763gck99cb97olpj063gckq4gc10hsqk063a8fqkgcpjsoqf065a87kqgc10omkfe35ccefkcb03oorrsssroorrrrooo",
		netherBricks: "0g0g706o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		redNetherBricks: "0g0g70c7i51b0efew3j0fjiwov0ive1a70nbiubj0svgd1b0v3ir5r0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		netherQuartzOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330u2845b0v4m7sv10p0npb1bug2671e4e1vj1n1fv9b1smb9xb1312426644044643344320246610442164643068a921424676466baa866314246766ba8674662643166895678a8544641466565ba95146866310289856642b9742469b814466ab862467ba624646b952364a950268665602426852108b61623214642649a9164941364667689238976124667423804646442246624630246644",
		netherrack: "0g0g70hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1312425544044543344320245210442154543012432142456545423545531424565424566455254315431566554244541452054554214565531024541154246642454221445541452456540245455112354554025655200242254210254102321454254122154541354556512234565124556423204545442245524530245544",
		netherWartBlock: "0g0g60of09vj0suze9r0xana4f1539r7j1brbain1g7rcvz0122001222532010222235202110022112111222202202320122201003202242042220021211122103224300222201201022220122252002210210211223102220000221222200222022221132210202012201104100222102201012211021042230122022012022212012022002220222202202220234022205220322022302",
		quartzBlockBottom: "0g0g31sm5mv31tq9ngf1tqfbb32222221111000222121111000002222111100000012222110000001122221110001111000110000011100000110000011111222200001111222222211111111222211000112222220110012222222211222222222210000022222211000000222222110110112222111100112222221100101122222111101222222222210000",
		quartzBlockSide: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzBlockTop: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzPillar: "0g0g41qe37y71sm5mv31tqfbb31uujcov0202031312130212020302130313031202131313120313020313130213031313131303120302121313020312031203131302131313020303120313031303130312130303131303120213131302131212131312130202120313021213120302031302120313031303130202130303131303120313031213120212131302121202",
		quartzPillarTop: "0g0g51p9z6kf1qe37y71sm5mv31tqfbb31uujcov1021223242413020222122211221122002223434434322223123443344443211113412222221431242442344443244222243242222424423423324244142441222442424324234143244242211423322224423334432442421341222222143111123444444443213222234444443222002211222122112221203142423220200",
		chiseledQuartzBlock: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov0444404333022440043331222204444003322111000444300222223004443331023011101110022103315544432202200110441100220000554444144033344544433204314444440111230011441101054044444432154104400110111004401444454005544440133321100004443002323155440333300444414444132220",
		chiseledQuartzBlockTop: "0g0g51p9z6kf1qe37y71tq9ngf1tqfbb31uujcov0334314232133420021100022000112002044203204421200204120420412021020113032020003102233304212233200000000421110000323433442223344422222222222222220000001321000001044343142143222104011204214110201302130420313020120234032023403002111003201100400222314222133420",
		chiseledStoneBricks: "0g0g70oigd8f0qqoef30sz21vj0xf6vpb0yjgikf11vskcf17g711b6666655666566562644424444224444054110000111123205206665566561530640654434442154064064322334315405205430005421630540632000643062052054300053206306215435655420630641644545432053064163232322215406421110000011530556655666655543053343234433232202000000000000000",
		smoothStone: "0g0g70wb8hdr0yjgikf12zwkxr17gcnb318kgnwf1asop331d0wq9r1011002200220121054556666553445204334454444555501666455566655442255444545666645006555555554343412556664665545550243343443434466116656545555455620555554566656661054544334454454215555666665566622444566454433452165445556555455104456665566544401022112221000121",
		soulSand: "0g0g60egz94v0ht5n270k181z30oho3jz0sxyiv30xeekfz3130033202100434433135531100234004241451321012411423432542212230032442154212211332234104322433212002314322315332220023322345513032322211233445304302332013540423202342330242132302341043213032020354044321232020431445421112202350345131123302354202432103212415",
		glowstone: "0g0g80u1fugv0v5phbz10pn01r11uj6db1kqv1tr1x1ncov1y6jzlr1y711j35420045440276423654011240346654024032201131054033034542017510033014766405664136502566552454236751004554020132450531024010352320465230213276501576442654346640335420454220452013000320356304012311354016754036520357660354215764034654201003242013154216521100013",
		andesite: "0g0g60sywflr0wb8hdr0yjgikf11vsl4v17gcnb31asolxb2114332104423221245323445330122411334410122443224410133445433231235442223333211433323243210013432324542104543333423310154332333433114143343224533143342221154333332321101544332201331254422332333443443233212331543333334533112233301244323223541321322323234432",
		diorite: "0g0g60xfchz311vskcf19of1fj1gd8su71ktouf31smgykf1222352233524355201322135345543151355101325543235255312553213225351243153532255245355541332335235332455214554102243123234555521232203255443244250155213551234541244310134335513055510144221512352542543554223223212343125454353242115521455321245235554124421255",
		granite: "0g0ga0l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n1qczoxr7434244344046445431548244224422341444335249241464143446145532344234232113754334244255342143347242445524442555322424474302155243346344255522344245535242552464245557314243844212555415442024425030323244424324439435524312355344448553215435547245544733324244425",
		polishedAndesite: "0g0g90oilzi70sz23gf0v7a3270yjgjcv10ru60v11vyakf11w3ugv19okmwv1e4v30f7878888888788785843334442443134084444443376644307416763343446440844442456433334083344333424433318444634666554320833433332123444184562444466776608434433443344540844667633366444081444444664466208466654333134760844433334465334083333664444334406100000000110000",
		polishedDiorite: "0g0g80qqu0ov0xfi5tr11vy6m71asubcv1f94t1b1jpkttr1o60w731ri7bpb7776677777666774764556657643564166764466577434506565333565454441675334576435457176544567733456607566767655346450744765756564534063556655467534516566544565544761664334655465666075673555775644517557654375466340745654576435744072445566545654512101110001100110",
		polishedGranite: "0g0g90l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n8888786866866565843344345444334374744554442446418444243334553342844444453344443262343344443734428345543644444431844444423445544263422344554433636444433443344442734444444464334284473344244442318455444445543341633443264434455264443444334447412111001110111100",
    portal: "0g0gu0dbgv7j0dbgvzz0dbgwsf0dbgxkv0dbgydb0dbgz5r0dbgzy70dbh0qn0dbh1j30eff7y70eff8qn0efffun0effgn30fjdu670fjduyn0fjdvr30gnc9a70gnca2n0hranlr0hraoe70iv92pr0jz7h1b0l35vcv0m748vz0m749of0nb2n7j0of11j30pizfun0qn3fnj0qn3gfzjpked8bed36jh512kjjk5a8ci77h53656dj318mfpheof3ab1b418pl4662eqe014418mk311821dme1h8cpj4a67ef13crglbil3a5hkfoe12hkb1bb5677tjhrg248e47b54348bml724im8hm41322bdjh8dob46pn4a686cpj44bb616mo76bdqk3abfhq725pmccqm51bqjcor6a6lhgl43ctlbcbqm4187769bsj686ljgd8hhe88mh426",
		obsidian: "0g0g50000073013yfb304gainz0a0p1q70fksanz1000012104311343101202104211342100443013322023010432231212001210032220000001110122200211114311002212344310301001102422020000043000432223310032223200213321021211211011121100210302112012144322221442022234212421332111022211103103112131122010012102012320111111",
    redstoneDust: "0g0g4000006w11qgs8o13ydjaw1jpkttk2220000220000222220000022000002220000022222000020003332222233300000333222223330000032222222233000002222222222300222000200200222222202020220222220020002002002200000222202102230000032222222223000003322222223300200332222333330222000022200000222220000220000222",
    redstoneDustOn: "0g0g5000006w1f1xam01jpkttk1nxkauw1wt7b3s0000000440000000000000044000000000000044444000000002224334422200000222444442220000024444144222000004433313444200444441131134444444443314114144440044341114144400000433433434420000024434144442000002244444442200000224444222220000000044400000000000000440000000",
    bufferMiddle:"0g0g502881dk0v31t6g11qs2d41cubto81x2x0xk4444444004444444444444400444444444444440044444444444444004444444444444400444444444444440044444444400000000000044444011233210044444400112210044444444001121044444444440121004444444444002204444444444440000444444444444400444444444444440044444444444444004444444",
    bufferTop:"0g0g802881dk0zivbaw13yotfc18eibjs1cubto81ha5bso1nxvkzc1x2x0xk7777777007777777777777700777777777777770077777777777770000777777777770011007777777770011210077777770011322100077000013363321100077001146631110007770013531100077777701331100777777770011100777777777700100777777777777000777777777777770077777777777777007777777",
    soup:"0g0ga0mewxrs0t3w8ag1jkvsag1jkw9o81job7y01smg9a01ullu601uunpx41x2kgzc1x2x0xk6666666626366666655666666666666666666666663663666666666366666666656666966666366666566666666666666565666766666666666166666666364665666666666636666661606666766666666666666666666666667667636666666561768673666666656660666966666666666666666636666666666666666666",
    soup2:"0g0gy08x7gmo090n2ls0b3ve9c0b96fhs0mav8xc0mewoa80mexbzk0qotmuo0qsjto00qskfsg0quq7zk0quqvow0qur5680v6iink0v7qghc0v8dxww0zotckw1apuuwg1atwxyo1cxrp4g1cxsb8w1cznca81d1ueb41f8631s1jkvsag1jkw9o81jne7lc1job7y01siecj41wt7b3s1wt7qq01wtiji01x0f4l41x2kws0tt54pm4p67460g0pt44tamaaa704gg0pkc67bbtma7a4gtr0m771bmbm9ta4qpt0a7acc45mo7qaq333m7bcaabm7h4i38r0aamccc477c4hh8r0mbaa7cdc774th8r07777jbdma7ibshs0dkk7j7am6babi8rpkk4jb7ccb7abtpu0ccf4775c7mm4mtts88lc1777mmmm6p0x82fmm87338v4tpss8m7q6gin934wts0xep4g62i0i322ss0x",
    soup3:"0g0gs00000000b3k0t40b46jhk0b6cwds0b6d8vk0b6d8zk0b7awx40b7m74g0b7x33k0m904m00mfk40o0mfk76g0ofo0mg0ofo0mw0ofo0qo0om805c1czc0ew1f2v0681f78bs01f78btc1f78rh41f78rm81f799001f79dqo1f79ic81lqabs81lu0ve81q7ozdkp0e440ece08ejj0000ee4l008f3ee99940404empfjf52509elm04pdfddee5pc0peee4c09bbgf8ph934edo4e35d0m86p633mel4e8n6h6bmp0b33lce46a45m0m003dj49e485a006j77m3pefee5dmb73cgjp3226p9447749007bpbf65ai4868620210q552fi48b33j4g13536ah2442f8ffm45455qm748437gfk0fff954762bjir0p",
    soup4:"0g0ga000006o0deayuo0v8z9ww0v9lr0011qgs8g1jkl90w1jnou0g1o6ay281ulak1c1urujg02222222222222222223222553322333222325233522222122232222222221222222003252332112222277322243331212277732224213322227772228482212222777232888222222277773288822322223777722322332226222332299232222222222299993222336362229999223226223322299222332262232222222222",
    randomSoup:function(n) {
			let r = 0, g = 0, b = 0
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					r = Math.random()*255
					g = Math.random()*255
					b = Math.random()*255
					setPixel(n, x, y, r, g, b)
				}
			}
		},
    redStain:"0g0gg1wt7ax41wt7axs1wt7ay01wt7ay81wt7ayo1wt7az41wt7azc1wt7azs1wt7b081wt7b0g1wt7b0w1wt7b141wt7b1c1wt7b1s1wt7b2o1wt7b3kfedb863102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acd",
    invis:"0g0g20000000009ppts0000000000000000000000000000000000110000000000000011111000000000010000111000000010000000100000001000000110111100100111110011110010111111110111111111110101100000111110001000000011110111111000001111111110000000111111101001011111001111111000010000011000000000",
    "poision potion":"0g0g40000000000006o18ikd0w1ulbvg00000000000000000000000000000000000000002200000000000001221000000000000100100000000000013310000000000001331000000000001330310000000001333303100000000133330310000000013333331000000000133331000000000001111000000000000000000000000000000000000000000000000000000",
    darkLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 10 + 100);
					b = Math.floor(Math.random() * 10);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		redBerryLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.10) {
						r = 255;
						g = 50;
						b = 0;
					} else {
						r = 0;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		blueBerryLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.10) {
						r = 0;
						g = 0;
						b = 255;
					} else {
						b = Math.floor(Math.random() * 30);
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		autumnLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 250;
					g = Math.floor(Math.random() * 80 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.30) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		pinkLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 255;
					g = 205;
					b = 226;
					if (Math.random() < 0.30) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.30) {
						r = 255;
						g = 185;
						b = 196;
					} else {
						r = 255;
						g = 225;
						b = 236;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
    flowerOftheValley: "0g0g800000000ekeqdb0mcq0hr0qtshkv0ym3u2n1o60w731smgykf1y711j30000000000000000000000000000000000000000000000000000000000000000000443000000000000760020000000000075020200000000000076020002000000657541002300000065000210330000000000011243000000000001143100000000000123200000000000013210000000000001110000000000000100000000",
		poppy: "0g0gd000000004jkcu704k17nj04k6txb05oxatb0fjd9mn0iv8e7z0qmx1q712uf5rz13ydk3j1f22ygv1lpt7nj1vpem7z0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa000000000000a78ab0000000000bb56990000000000ccb99000000000000b310000000000000004000000000000000400000000000000040000000000003404044000000000030230000000000000313000000",
		dandelion: "0g0g70000000017p88v03h660v143zt331e5azun1ktyynz1uuywvz0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000560646000000000005563000000000006643350000000000002200000000000000212100000000001221100000000000012100000000000000210000000",
    blueOrchid: "0g0gj000000004l4jjz05oxatb05p2x3306s98u706svocf06tdo8v06tdp1b07w7mdb07w7n5r07xc2kf0a6ccn30baaq670baaqyn0bax81r0djgfen0gsmpz30gssbgf0gssc8v0000000000000000000000000000007000000000000009f00000ec0ce000hac00000760cc00gc00000000ii900g7fd000007c4009020c000000eb00008ec00000000000003760000000000000i000000000000000190000000000000005000000000000000g00000000000000020000000000000099000000000000000000000",
    pinkTulip: "0g0gc00000000dfzitb0ek94vz0hwfl6n0j0p81r0l92txb0mcq1a70nhavwf0nhgi671p83v9b1skr5kv1utlnun00000000000000000000000000000000000000b0b0000000000000aba00000000000009a9000000000000009000000000004800104000000000073080840000000003708082000000000250626200000000024248200000000000684620000000000023820000000000000262000000000000002000000000000000000000000",
    orangeTulip: "0g0gg00000000cc14hr0ekeqdb0hwl6nz0j0p81r0l8rmyn0l92txb0mdchkv0nhm4fz1kpag3j1lt385b1mxo3jz1p61r0f1q9uj271qa5rlr1rdstfj00000000000000000000000000000000000000f0e0000000000000bcb00000000000009d900000000000000a000000000000800104000000000048050540000000002702082000000000264225200000000023248420000000000534520000000000083820000000000008352000000000000002000000000000000000000000",
    redTulip: "0g0gd00000000gssem70k4yuwv0md19tr0ol9b0f0olkhz30ppojcv0qty5fj1hb8m4f1ifclxb1lrj0n31mv641r1mvn18f00000000000000000000000000000000000000b0c00000000000009a900000000000008c8000000000000009000000000000030407000000000034010730000000001714061000000000171415100000000003731200000000000143240000000000001727000000000000142700000000000001000000000000000000000000",
    whiteTulip: "0g0gd00000000b7x3wf0cc6pz30fod69r0hwl6nz0k4nmdb0k4ysjj0l98gzj0mdcgsf1lxsv0f1pa4wsf1smgykf1uuozr300000000000000000000000000000000000000c0c0000000000000bcb0000000000000aba000000000000009000000000000040100080000000048050074000000002802073200000000252506200000000024842320000000000254350000000000002838000000000000253000000000000002000000000000000000000000",
    azureBluet: "0g0g700000000gruprz0j0e0an0ngu1331o66ku71riimm71uuoj5r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000006564000000000000432056000000006504553400000000530146200000000001320305600000000056230340000000005433300000000000003200000000000000300000000",
    cornFlower: "0g0gb00000000b6jldr0cbkf7j0gs0hkv0ht0npb0izbr3z0ngiyv30ol3u9r0qry3gf0v88hz312ynx1b000000000000000000000000000000000000000000000000000000000000000000000909580000000000599585500000000008114510000000000002a000000000000006600000000000000020000000000060006000000000000600700000000000036070000000000000367000000000000002700000000000000020000000",
    purpleFlower: "0g0g80000000003qupr0199eyn0l3bf9b0ohifpb17aa1of1e0teyn1mz9kvz0000000000000000000000000000000000000000000000000000000000000000000000000000000000000005500000000000005376700000000007775300000000000056337000000000007210000000000000040000000000000042000000000000000120000000000000002400000000000004100000000000000010000000",
    oxeyeDaisy: "0g0gb00000000dfzitb0ek94vz0j0p81r0mcq1a70nhgi671lxgm4f1pa4wsf1smb0fz1tqkz5r1vyt0cf000000000000000000000000000000000000000a0000000000000a7a7a00000000000986870000000000aa666aa00000000007868900000000000a7a7a0000000000000a400000000000000510000000000000040000000000000143000000000000001301000000000000051000000000000004100000000000000200000000",
    allium: "0g0gg00000000ppdce70rxldkv0t1pbsv0u5terj0ym3u2n11ya8sf1e1fw1r1f5v4e71ga4qgv1gafz0f1iiz75r1jn8t8f1n079q71p8qhvj1qd03y700000000000000000000000000000000000000a8a000000000000c89e80000000000aeae87b00000000077de8b70000000000fa8ea00000000000072ae00000000000006000000000000000400000000000000020000000000000004000000000000000500000000000000060000000000000003000000000000000100000000",
    lilacTop: "0g0gj000000002cqxof03gpb7j0j0uubj0k4nlkv0k4t7un0md191b0mdtblr0mdtce70nhrpxb17e0d8f17e0e0v18hyrjz1e21ywv1f60d8f1luohkv1mymvwf1p7bvun1qba9dr0000000000000000000000000000000000gh0000000dg00000dgd00000hgd000000hda000dgd00000000ae000bd0000000000690c300000000000042300000000000006900bdhf000fhg0009051id00000gdb00620c00000000b1c0g3000fg000000c37id00ghd000000000da0c1b0000000f000b02c0000000fh00086000000",
    lilacBottom: "0g0gl000000002cqxof03gpb7j04knoqn0j0p81r0j0uubj0k4nlkv0k4t7un0md191b0mdtce70nhrpxb17e0d8f17e0e0v18hyrjz1e21ywv1f60d8f1luohkv1mymvwf1p7bvun1qba9dr1qbaa67000ehe02800ehh00000f1d0a60chi0000000d298271c0000000000hk50d00000000000ebf00000000000000bc00ehig00000hj00502ceh000000f1f0a2db00000hhe0d5480000000hgic200a4000000000eed26a000000000000bd0800ehg000000000085dbeig000000000722d0000000000000300000000000000030000000",
    peonyTop: "0g0gq000000003dqnzz04hp1j304hp2bj04huolb05m9xq706q8b9b06q8c1r06qdybj07v4ef307vfmyn08z2sqn08ze0hr08ze1a71p769kv1qb4n3z1qba9dr1qbaa671qbr4zj1rgbytb1rgbzlr1skad4v1sl2i2n1tp0vlr1tp6hvj1vy6ku700000000000000000000000000000000000000000000000000000000000000000000000000j00000000nnn000jnj000000jijmn09hnpin0000njipf6c5hnjj0000jnnkh6cb1gg000000eh16cb480ab0000009b4b74bd70000bcd38264b440000007ba1ok147da9000000kkinl6c9nk000000jnnph282nn0000000jeg18480000",
    peonyBottom: "0g0gv000000003dqnzz04hp1j304hunsv04huolb05m9xq706q8b9b06q8c1r06qdybj07v4dmn07v4ef307vfm6707vfmyn08z2ry708z2sqn08ze0hr08ze1a708zjnjz1p769kv1qb4n3z1qba9dr1qbaa671qbr4zj1rgbytb1rgbzlr1skad4v1skadxb1tp0vlr1tp6hvj1vy6ku71x24ydb0000ag4e743k000000e0r547f83k000000gaoq64e200000000a7aag45prn000000l947e2prmn000000kl6446ltrrce0004acd84e1ljo60000044h48482ac0000000822e484gal0000egbru17e47ga000006omrla46c44800000rnlb71ur60000000002e2smi000000000084e5po0000000000048460000000000004440000000",
    roseBushTop: "0g0go000000006q8c1r06qdybj08z2ry708z2sqn0900j5r0a3taf30a3ywov0c9ujun0de9szj0j0uubj0k4t7un0v3tuyn0w7s8hr167835r17b6gov1g6z6db1g6z75r1haxjwf1haxkov1hb36yn1tiwl4v1tj27en1xznwu700000000000000000000000gk0000000000000jmem000000000000dnmg00000000kg002dd00gk0000memg07000dmem000gmn00a1300nmg0000cf00ij001fc00000070gmej0710000003b00nl500b00000000730d1007100000000100b3007100000000137000017000mhg001100070000meemd9b006b000000hmn04b80700000",
    roseBushBottom: "0g0gx000000005m9yin05mfksf06q8c1r06qdybj07v4ef308yx5of08z2ry708z2sqn0a3taf30a3ywov0de9s730j0p81r0j0uubj0k4t7un0mdtce70nhrpxb0v3o8ov0v3tuyn0w7mm7z0w7s8hr167835r17b6gov1g6z6db1g6z75r1haxjwf1haxkov1hb36yn1tiwkcf1tiwl4v1tj26m71tj27en1xznwu7000k400a703500000000030aba2qov0000003a03e3qvlov000e3a073a3jwvvl0000e30e3a3djil000n0d73ga3ge30000ovvlg3dppd3adpn0llstf9quwm2dpwvlqvwhdflvnvmfpvimiqs29gjlvmde1mr00k003edjk47a3800000739gea3ea300000003ae63ea3a000000ea3ae373aec000000ea373e379000000a9a3e3e3aaa00",
    witherRose: "0g0ga00000000000073015ikfz015o6pr015zf9b029s6in029xssf04ibenz08vn0fz0l5c2kf0000000000000000000000000000000000000000000000000000000000000000000000000000000000000009910000000000009191800000000000118110000000000001110000000000000010000000000000005720000000000027527700000000077240070000000007005000000000000000300000000000000436000000",
    TallGrass: "0g0ga000000006qdtkv07uhtdr08yrfgf08yx2in08z2osf0a312bj0a36olb0b7lwxr0dggef30000070000000000000009000006000000900300906000010031033030103091903303103013003381030310313390309103031013109030881313331310301008131330333337300810113310113130081010141013313001801014101331000118131718131300058813175813132002218215151111202821211212221210",
    
    warpedDoorTop: "0g0gc04i0ge707u6vwf07uz2f3092ophb0a5jpj30a60p330b7xmv30cb3t330fodrlr0fouosf0k1jhmn0pmetxb3353533535353338588828883662488653362665666264539775445768827227b867476768628882a886566288629992988328829962999683362997998298839667299698827537576629968862577636882998633276643888288654636646389929936772356298992993772227727899288576139912b898286466098607",
    warpedDoorBottom: "0g0gb04i0ge707uz2f3092ophb0a5jpj30a60p330b7xmv30cb3t330fodrlr0fouosf0k1jhmn0pmetxb9724153655100061825533667751157125551676885158812577177688515886278815568851577647881776775122754775188677625547854418865521611642752576564155757566255566315775a65512256311624695551114316125648777166165514655487717757534657148881775735157715115151115616111",
    spruceDoorTop: "0g0gc0ehg7wf0gpo9330l50ohr0nd8pof0ohnzlr0rtudj30sxyewv0sywflr0u30g730xe36db0zm5jpb16anym7bab4bb4bb4bb4bb4aaa39a3a939a4962ba94aa3a649a4962ba94a6356469469201741741741741728564563564563562b6a36a4aa36a4952b6a36946a36a3a52b6a3994563963a62b993964564953962a963994653a53992ba54a93653a64692ba64a64a54a945a2ba94a63a64a945929aa4653aa4aa35620173173174173172",
    spruceDoorBottom: "0g0gh0ehg7wf0gpo9330l50ohr0nd8pof0ohnzlr0rtudj30sxyewv0sywflr0u30g730xe36db0xfchz30zm5jpb10rojr312zwkxr16anym717gcnb318kgnwf85645645645gd562b6b3b635b3g53db2e6949635b4fb3ab2e6b46936b45ca5b2e6b4b94994653b62e6b4b93b64963b62b9639b4b639b4662b9636b4b53b93652eb635b49536539529b6356465455395201731741731731728564563563564562e9b4bb45649b4bb2e9b4bb35b49b4b92b994bb36b4993b622553553554553552",
    oakDoorTop: "0g0gb00000000m9fzzz0ru00lb0sz251b0u30g730yicsfz0znvvnj156v7cv19n5mnz1e3g0e71f7pou7a88aaaa8aaaa8aa78777777777777772a712222712222772a720000820000871672000092000097547200008200008728758998858998872a712222712222771a7200008200008758720000920000972a720000820000872a758998858998871a788875588875575a71222271222277287277778277663726525555825531551",
    oakDoorBottom: "0g0g90m9fzzz0ru00lb0sz251b0yicsfz0znvvnj156v7cv19n5mnz1e3g0e71f7pou72515533715500753653677763677765165665533555335518501111501111650851555561555565385155537155537518515533715533751853677763677763065666533566533338501111531111651451555561555565125155537155537506515533715533753653677763677763183356653356653311000000000000000",
    jungleDoorTop: "0g0ge00000000ddc7b30ehg7wf0k20av30sxhjb30sywflr0u30g730xdxk3j156edbz18ikr9b1buwttr1f738jj1hfgvzz1lw2kn3ccddddccdddddcc4c8abb8bbbb8bba94d9bb97877879bba7dbba87700448abb72bb8708008078bb76b8700d00d007bb7dab700d00d007bb7d8a700b00c007a84c777cdbcdbcd7444dccc99777799ccc8c9bba800008abaa4c9bb87b00c8ab9b4cabb97accb8abab7db9b97aaaa8abba7db7ba78aab7531a72b8ba8bbbb718aa4",
    jungleDoorBottom: "0g0ga0ehg7wf0sxhjb30u30g730xdxk3j156edbz18ikr9b1buwttr1f738jj1hfgvzz1lw2kn32777647777147741967664777714775186665466661577618666634444367763856763888847777384776167654665738477516775366463947751777635656394774175763477610467436476147751255554637715555193113455764431318477434776467743875761477515757395455155543554539333111333311133",
    ironDoorTop: "0g0gc00000000hts9of0l64bgf0znkj5r18kgnwf19okohr1d0wq9r1gd8s1r1ktj7cv1lxsv0f1o60w731ricxz3a99aaaa9aaaa9aa89888888888888884a846666846666884a8600009600009842860000b60000b8438600009600009849879bb9979bb9984a846666846666884a8600009600009849860000b60000b84a860000960000984a879bb9979bb9984a899987799987784a84666684666688498688889688133842767777967714775",
    ironDoorBottom: "0g0ga0c986pr0hts9of18kgnwf19okohr1d0wq9r1gd8s1r1ktj7cv1lxsv0f1o60w731ricxz30646655946644962765799975799976276776655666556628624444624444762864666674666676286466659466659628646655946655962865799975799975276777655677655538624444654444762164666674666676306466659466659627646655946655962765799975799975385567765567765234233333333333333",
    darkOakDoorTop: "0g0gf0b4hji70dcpj3z0egnxfj0ehg7wf0govx1b0hsuakf0k12ayn0m94p330ohiewv0qpf4e70u30g730v5jv2719mocu71krh2bj1y61y4f88888888888888828776667777776664875000077500006486044496704449643604549670454964a7045596704559748705559670555964870565b660565b74870666b560666b74870666b560666b64860667b760667b64860677b760677b64861777b761777b64861777b661777b7486199b967199b97436676677776edc74",
    darkOakDoorBottom: "0g0gc0b4hji70dcpj3z0ehg7wf0govx1b0hsuakf0k12ayn0m94p330ohiewv0qpf4e70u30g730v5jv271krh2bj95666666665b556375400005640000637503338560333863750343856034386375034485603448537604448550444853760454a550454a53750555a550555a53750555a650555a63750556a650556a63250566a660566a53951666a661666a53751666a561666a5376188a855188a85375555555665655536111111111111113",
    crimsonDoorTop: "0g0ga0iwhlvj0k0lmgv0m9g6bj0pkufb30swv7r30sy9wxr0ygss1r10ov667140vym71bsvx1b6998899988989984844434444443444396473646464364739676367776737764533333333333333128887888888888848677667777677773967766777747777396663467764664449444334433333333611111111111111183331333333133319443144434314431964414644443444176663666461886135766366666086403",
    crimsonDoorBottom: "0g0ga0iwhlvj0k0lmgv0m9g6bj0pkufb30swv7r30sy9wxr0ygss1r10ov667140vym71bsvx1b2777367667400033878737867761666387883887876166838888388888718881033333333333333198887888888888869777667777677774877766777747777477663467764664443444334433333333511111111111111124441434443134439644364466434463976637687763677377873788787387836343134443313131",
    birchDoorTop: "0g0ge0iwyb5r0ohcphb17fk83j19nxurj1f8hwxr1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v1y6vain677777777777777675566665556665537542222233333453752bbbabbabbb853052bbbabbabbb8531529999aa9999863762bc9cccc9cb763762cc9cbbc9cc763763999baab999863763ccabaabacc863763cdacaacadc86376399a9999a99863753bb9cbbc9bb863753bb9cbbc9bb752763ab9cbbc9ba702063ab9cbbc9ba712",
    birchDoorBottom: "0g0ge0iwyb5r0ohcphb17fk83j19nxurj1f8hwxr1josanz1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v173bbaddddabb852873aaaaaaaaaa972873dccdaadccd972873dbbcaacbbd972874999998899995286567557577575628557555756755673856756576675667385775767756576738677677775667773077667677557777317765757675776728775575657567662867566555755756285667656565565525222222222222223",
    acaciaDoorTop: "0g0ge00000000ehg7wf0ma8c1r0u0yyv30u30g730v74gsf0zlddz3155rt3317du7zz1btnojj1cxgglb1f5itxb1ii651b1jma5mndcccddddddccccc6ca999bb99bb99998da33673367336798da300c300c300c961a600c600c300c964a600c700c600cb6ba700c700c700cb6ba700d600d700db6da600d600d600db6da700d600d600d93db700d700d700d93cb700d700d700db3db600d700d700db6db600d700d600db3c9700d700d700db619acddacddac1256",
    acaciaDoorBottom: "0g0gc00000000ehg7wf0neccn30u0yyv30u30g730zlddz3155rt331btnojj1cxgglb1f5itxb1ii651b1jma5mn473356335633562599300a300a30076599300a300a300975a9500a500a500a75b9600a600a600a93b7500b500b600b93b7600b500b600b93b9600b500b600b93b9600b600b600b95a9600b600b500b9517600b600b500b7647500b500b500b7697600b600b600b75998abb8abb8abb75a9997779997777755633335555556665",
    
    torch: "0g0gd00000000egz6rj0fl37cv0gp77y70htb8jj0ndpnnj0u22fi7156v85b17f3a4f1y2mc5b1y5l3b31y70gzj1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a900000000000000bc000000000000008600000000000000750000000000000084000000000000008500000000000000750000000000000063000000000000008200000000000000610000000",
    soulTorch: "0g0gd0000000006fbb30dkjoxr0egz6rj0fl37cv0gp77y70htb8jj0ndpnnj0u22fi70xkd0qn156v85b17f3a4f1y711j3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021000000000000009c00000000000000b800000000000000a700000000000000b600000000000000b700000000000000a7000000000000008500000000000000b400000000000000830000000",
    
    lantern: "0g0gc000000008x7i7z0gptzb30hu3nr30iy7p4v0zkwgsf12xjrwf1ihjf9b1uqx79b1x10sfz1y70fen1y70tmn0244200000000000065560000004220024444200000201005788750000020100689986000001210069ba96000000000069ab960000020100589985000001210024444200000000002233220000000000234432000004220034444300000201003444430000000000234432000000000022332200000000000000000000000000",
    soulLantern: "0g0gb0000000005sq9r07z7enz08x7i7z0a7fgn30gptzb30hu3nr30iy7p4v0u80yyn1inns3j1vyyo730577500000000000075570000007550057777500000503005144150000050300728827000003530078a9870000000000789a870000050300528825000003530057777500000000005566550000000000567765000007550067777600000503006777760000000000567765000000000055665500000000000000000000000000",
    
    beaconGlass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
    beaconObsidian: "0g0g50000073013yfb304gainz0a0p1q70fksanz1000012104311343101202104211342100443013322023010432231212001210032220000001110122200211114311002212344310301001102422020000043000432223310032223200213321021211211011121100210302112012144322221442022234212421332111022211103103112131122010012102012320111111",
    beacon: "0g0ga0bar6rj0bbdr0f0k7hofz0u7k07317jn2tb1inns3j1kuxzpb1n3ha7z1tr7jen1y711j39999999999999999900000111111000690011112211110069011222322221106911222333322211691122345543221169012345775432116902235788753321691233578875322069112345775432116911223455432211691122233332221069011222232221106901111122111110690000011110000066666666666666666",
    
    cactusTop: "0g0g900000000fmt0cf0hv6n0f0hv6nsv0mbxwcf0okh5a70rwt69r17gnmdb1f9a6m70000000000000000013331337313311003444344444444100345735565355430034564586546543001345665658444100375655666555430034664466666643003466846656654300345666668547430014456656654441003456455664554300345547555357430014443144424441001133133331331100000000000000000",
    cactusSide: "0g0g900000000fmt0cf0hv6nsv0k3k9of0mbxwcf0okh5a70rwt69r17gnmdb1f9a6m70156534665156410024548456516658087454144653665100155514565756420015662466414541001665146641455808166414864146510016651465415651001564245441664200146524644166420024657565416547802455156541644108745515665265410014641566426541001465145658554100156614455146410",
    cactusBottom: "0g0g7000000002aeqrj03fm41r131ary718ljny71jppypr1lxsdmn0000000000000000012222111222211002555566555566100265334444335520026455666655352001535566665536200253555435554610025456466365461001646646646645100164665345664520026456666555452002535565555545200255434444336520015555666666661001122212222221100000000000000000",
    
    glassPaneSide: "0g0g400000001d2bim71hje60v1y711j30000000320000000000000031000000000000003200000000000000220000000000000023000000000000003100000000000000210000000000000021000000000000003100000000000000210000000000000032000000000000003100000000000000320000000000000032000000000000003100000000000000310000000",
    glassPaneTop: "0g0g400000001d2bim71hje60v1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000333333232232233311221211111322120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    
    ladder: "0g0g700000000fl385b0m9fzzz0ru00lb0yicsfz156v7cv1e3g0e70052000000005200046456566665646003432333333243300021000000002100005200000000520006645666565564600343233333324330002100000000210000520000000052000664566666656440034323333332433000210000000021000052000000005200066456566665646003432333333243300021000000002100",
		vine: "0g0g500000000ok5z3z0qse0an0u4q22n0zpa51b0002143113023440033213000202134044312000004311004321000004432100002100000112320003221002210032111332331230032100200234403032440000001340000234000000210000321330000031000021000000132130044100001332133004321021043110300302111303211000001220020021232021013300",
    
    Water: function(n) {
			let r = 0, g = 0, b = 0, a = 0;
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
				    a = 200;
					r = 0;
					g = 0;
					b = random(200, 255);
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
    Lava: "0g0gp1jjxhbz1jjxi4f1jk33lr1knvuv31ko1hxb1lsrytb1lsrzlr1mwqd4v1o1mhvj1o1minz1p5kven1p5kw731p67ev31p6io731qa5se71qabfgf1qaxxbz1qaxy4f1rewbnj1sjmuwv1sjmvpb1to7sov1ut3zsv1ut9m2n1y687b3965ckke60666999cf996f8c66cd69fjddd96606669f67hold967629c96669lll966666dhc9969jfh97666chh69df699c96999kk969kd69f99696dlnf069536669ha66fh960066456hhk97690017ll66chgl96000009ml5696969hg63066862666666kl7066c60068li69990669d6609knldh66046699hb6hefckh960656fhd69",
    
    craftingTableTop: "0g0g903c6e4f06oif3z0hsj18f0k0r37j0nd8r9b0v4xd6n17dojcv1bu4kxr1gbtpfj1001255555521011088267777776288008277777777772801274344433334721267467477377476257747736746747755774434434434775577477477477477557747747747747755773334334434775577367376377477526746737736747621274434444444721082777777777728018826777777628811101255555521001",
    craftingTableSide: "0g0gh04gaepr06oif3z0a0ufb30b4n4zj0fkmbr30hsj18f0k0r37j0ru00lb0v4xd6n0yicsfz156v7cv17fehvj1bvja4f1e50qv31f7pou71hfxp8f1o60w731ceff486684fffe11eccab4664cceeb11eeecec22bbccee1199aa971197977911fbffff66ffeccb11ee5b5b44cceeee11bc3c3c44eeccbb11799g97117999a911ffgcgf66fffffe11cededc44bcbcbb11eccbbb44cccbbe1179aa97009a997711beffee66ffbfef11ceebbc44eececc11bbcecb44ecbbbb1199779a119797771",
    craftingTableFront: "0g0gh04gaepr06oif3z0b4n4zj0fkmbr30hsj18f0k0r37j0ru00lb0v4xd6n0yicsfz156v7cv17fehvj1bvja4f1e50qv31f7pou71hfxp8f1o60w731y711j31bdee375573eeed11dbb9a3553bbdda11dddbdb33aabbdd118899861186444811eaeeee55ee2b2a11dd4aba33bb222d11ab2bbb33ddccca116829861168gff811ee2bbe55eegffd11bfffdb33abaffa11dcfgaa33bbbgfd11689986008988f611adeedd55eeaege11bddaab33ddbdbb11aabdba33dbaaaa11886689118686661",
    
    crimsonNyliumTop: "0g0gb0rs4iyn0rsa60v0v4gkqn0v4m7sv0xana4f0yelnnj10p0npb152yh331br00e71g7lptr1hbk3cv665022781508847275526677572777880356a2357825787420153555726274776351871536a625293557027508476266575376488726530535326787982a205776357474843262155557532671535783753a62635150735530762355175784375788774726357820557536726663777553017357a62743152625305526787057",
    crimsonNyliumSide: "0g0gl0gnskcf0l3m2gv0l3xclb0m7kfzz0nbzqpr0nc5drz0of09vj0rs4iyn0rsa60v0sutrzz0v4gkqn0v4m7sv0w8ey9r0w8klbz0xana4f0yelnnj10p0npb152yh331br00e71g7lptr1hbk3cvhihiheijhhhihijifhijehijjihjjih99fehfhhe99ekef96f6f9f9ff69hf696636966696639f66333336346653666344348f0d474563547ac49627cb99b76fb7727a7229f6aa797b67aga7067a7ac1964c7aa706bgac2002726b72302a71024237b96b73223d7a734c7aaga32247aga327aag724207a7a77227aa27c4027aa77",
    warpedNyliumTop: "0g0gf01a28e702e0lxb02eybjz02eyccf03fmgov03gq1a703gq22n03gvocf03iwp330gqauwv0hvcjjz0hvi5tr0izax330izgjcv0ng7r3zee49aa519491146c744aee6646c655119d4e3cc460c45154a994c4447cea7465ec490794ce3ea4c2c4479c749046eaee474c6e4115ce4b94c4cae61580c3c9476ec4746414caea9444464cae694c460c74c2eaea49497c44c96eac44974714c747106647aea450c94474ce7ceeec65744c997c462ea64c94aea4c944ce616946",
    warpedNyliumSide: "0g0gn02e0lxb02eybjz03fmgov03fmhhb03gq1a703gq22n03gvocf03iwp330b5qosf0c9p2bj0gnskcf0gqauwv0gqavpb0l3m2gv0l3rpj30l3xclb0m7kfzz0nbzqpr0rs4iyn0v4gkqn0w8ey9r0w8klbz10p0npb40406b0744404070b507b607704770522bb6b66b22b1bb29c9b2b2bc936b9399g93999398g3c99ggggg8gh98hg998ghhghicalhihh8ghhijkh38fikk33ki8ckiifikife3c8kji3ik8ijmjia9ikijkg38hkijjia8kmjkfaafie8kifgafjidafhfgik38kigffglijighkikjmjgffhijmjgfijjmifhfaijijiiffijjfikhafijjii",
    warpedStemTop: "0g0gk01a28e703fmgov03gvocf06r0ovz0900vsv0b75erj0dhkflr0dhq1vj0ekl0cf0ekl14v0ekwb9b0el1xj30hs7z0f0hsp3b30hsupkv0iwng1r0iwngu70iwt33z0k0fzen0k0g073cce1ii2f0hcic2ecebbbb9b8689bbabe2b33554544445562cb366aaaa8aab5bcj95a88888888a49jcb4a85544558b59ch9588398895885bd084a85944848a480f94a85945958b59f284a859998488582i95a85535448a49ii94a88888888a59i1b4ba8baaaa6b591eb454555555555becbbb99b98799babccce1ii2f0gcjc2ec",
    warpedStemSide: "0g0gp018yq6702bzev302c514v02cx3pb02dp9fj02duvpb03fmgov03fmhhb03gk7wf03gk8ov03hnmyn04lar5r0gp1ybj0gp7klb0hs7y7z0hs7z0f0hsdm2n0hsunzz0hsuosf0hsupkv0iwng1r0iwngu70k0fzen0k0g0730ncmewvffjann6j3jfnf2jfffj3fn6j3jnnj6jfj26jjnj22fofjj2jafn6jffj2jon6j33jnoj6jnj6jnoj23jfooj6jonj6jnfj2jj6ooj6nooj6jj2jn2nomj6fmooj66jmm2ffjfj6jfnnj6fooj0f2nmj66jf66jonk50jeoofj6l6knne0jnfjnoof66j1ffj2nm6jenok6jf0kekjmi2j6fn2ifnj4i2fj1jf7lfj0kmnk0jff9cnf6gdb8hf2jf",
    crimsonStemTop: "0g0gh0hs7z0f0l3rn5r0m7q0ov0ogqepr0ogqfi70pkot1b0swplhb0yelnnj0ygn5rz0zkljb310ov66711stjpb140qccf152yh33154opvj154uc5b1br00e7002700d1g2000d202bbbb9a8c89bbab2da004464666644ed0b0feaaaa8aab4b0094a88888888a6900b6a85466448a49029488098894884b2g86a85866868a68g196a84864948a491d86a84999868848d094a84505668a690096a88888888a4907a6ba8aaaaaeb4872b636444444444b20bba99a98f99bab0002700d1g2000d20",
    crimsonStemSide: "0g0gj0hs7y7z0hs7z0f0k0fzen0k0g0730l3rn5r0m7q0ov0m7q1hb0nboe7z0ncmewv0xana4f0yelnnj11qmfb313yughr13yuha7152su0v166r7jz1ancwzj1cv9o1r1dz81kv115h33a5e5131b51115e13a5e5335a515ba5535bb18155b5h13a5115b583a5ee5385a535a5385be51885a5835a5315b55a885a3885a55b53b3835a13885aa522b11515a51335a1885e1b325aa51aa5834if518815a4a4331e53153881aa5b115b33951384a51f414535b5a13b5135h5b15b51a415e4334f511c731a07gd61b51",
    warpedWartBlock: "0g0g702e0lxb03gq1a703gq22n03gvocf03iwp3304jkwlb04k1s731111656111151116116604151665511666116111151351015611156550153141541115536166611650114055111156356511115611142551165365366110651115555116111155111511116601165351561156654625613651156563666626541105613512561531161561511651115111151151115104511154165011511051",
    shroomlight: "0g0gh1dzj3sv1mwkohr1o0j20v1o0ooan1rdsr271rdydbz1y2bd331y2bdvj1y2h05b1y3vvnj1y3vwfz1y41ipr1y4tp8f1y4zbi71y5rl6n1y5x7gf1y6perj303518843009ee7105444199852de9d838899dc991879dc92489eeed94996998519eg9d819cc96a4249f99719cgge9841811dda19cgg998484ff14481de994a88aec7eed84dd819984d96eg9d4811b984847dd99d8a99444884d44dd944eefa184fc9a48129eg9451dc9a4ddb1a97843489844d9834444304414424200352300",
    polishedBlackstoneBricks: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj3554554554554430343435443223334034544423224424404343433443432120443333433332112023441233212212302243232221132330110011000011111154554440124555453343434034344544234544402355444343343420443443344343232045432323323221104432121221121210332211110011100000101100",
    gildedBlackstone: "0g0ga05k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70iw63un0l5yqrj0yh98n31o36n0f1y6dkvz2332220233343553308750023334435308122103389432107233332334791121133444244662812544643213222271253443222533225211122225732133211311233034318752233331013215133225222378112364433713344192114664383344438211113472446622272222255244631125011103313221112022235322",
    chiseledPolishedBlackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj5554555555554452534344333334334053111212222215315315555555452541541544444434244144253433333425315413555555431541542451555153254154235154414315315323444444432431542533222234154154244443443315314312222121111531335554555545453123334344333333322212100000102121",
    blackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj2332220233343113300110023334431301122103344432100233332334451121133444244552112144543213222211213443222133221211122220032133211311233034310112233331013210133220222320112354433013344102114554313344431211113412445522212222210244531120011103313221112022232322",
    blackstoneTop: "0g0g505k8ttr07sb8qn0a0uhof0dd6ltr0gpioe72344331234322300044332111232103404342234311134231232033442144342220002442003433122242013000033211244343012100211134343314422013322342024333302342201122443320011400234324421012343233444200134244034402321024442124432121102343213342323432023223211332344400430",
    netheriteBlock: "0g0ga0a0oven0c92jnj0dd0x6n0flk8hr0gp7bwf0hts9of0k1uolb0l5ne9r0l5yp6n0oiaqyn4244444444424420269999999998998049366888567766804956778868875380496578788886546049565768988854624955568889666360496538888865638049688886685653624988985556556362288878555533448049878763353341802836665335341180283433341111148228666888688888602000022000220000",
    basaltSide: "0g0g506p53b30ddc9of0flkbnj0l5yp6n0pmkdtr3023343444343313101134344434332201133444443432330033444434341233203434323322330221144322343231021114242344323123113122334341313213343243444102331333434444441244113343443443034411344344234403413334433213432321133123231332342213234244313224333033434443432343",
    basaltTop: "0g0g706p53b30ehga9r0gpoc8v0l5yp6n0pmkdtr0wb8hdr11vskcf4455351155441441456511331442211325311344412652343145234531556413056542441155542004544221451442440044001444512332511033244551032544133442550001542223454220155144344044144154451344550145545444014555224533144100054145233100144001144450155145541443445056434544",
    polishedBasaltSide: "0g0g606p53b30ddc9of0flkbnj0l5yp6n0pmkdtr0wb8hdr1235443544334421023545354543342202354545454534221335555545554422123455454555433222344545455543321234355543544321113335555354432101353545545353210135354555545320014545455554431012444545555543101345453555453321234545355545433123454535454543312345443545444432",
    polishedBasaltTop: "0g0g70ddc9of0ehga9r0gpoc8v0l5yp6n0pmkdtr0wb8hdr11vskcf0255331155431320054464436445343225656554655654443453434433333553244366665555333226546434434535442433636565354664566363634545354444435364353636532563545555364665345354343346354444535555566635523554333434333653246653645644555225565455564545420245443555434520",
    chain: "0g0g400000000a1bitb0gpzlkv0k2boxr0001010000000000322112000000000020100000000000001123220000000000000201000000000000010100000000003221120000000000201000000000000010100000000000001122220000000000000201000000000000010100000000003221120000000000201000000000000011232200000000000002010000000000",
    warpedTrapdoor: "0g0g7000000007uz2f30b7xmv30cb3t330elit4v0fodrlr0fouosf3111131113113111165456464444656315335333345332513630540036200351166024600600045315200240045024631422006002405661344200600040365116400450004033511620462000402543352062000550044115305500052002411630252005050363163325422442334336446544444444533111133131113331",
    warpedPlanks: "0g0g704i0ge707u6vwf07uz2f30b7xmv30cb3t330fodrlr0fouosf5356666656666652553324355533554435553534444335522112210011010010564666646665334535534342433555534435333255533444001121000011121056653366666666545355553444343442653344443333445400122100012110006456655466646566335544344553533334435342553444440110012221010000",
    warpedFungus: "0g0gc000000004lrqpr05nj7r305omscf05qtg5b0gqavpb0iwhlvj0k0lmgv0ncs16n1sfq5fj1y125fj1y3kmbj00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a4444ab41000000314444aa13000000233a913332000000222995522200000000006600000000000000760000000000000087000000000000007800000000000000870000000",
    magma: "0g1ca0hs27zz0m81d6n0rsft330v4m7sv1jkpkov1rdbzen1vu37y71vueiv31wzat4v1wzrrwf042101272002542133100025210374129953225412381257531745425784212451245421223520124002731001127321201382310003845742328755212742447445432452542125215220124742102712721001252002820387210025210272413252102712315274125122585784242455788733215312154223731012472005210125200247313310003521025512599323771225125553174883455731244124473122383013400253100113723120127121000255745221755731245387777542388345213521532013755210271242100135200272025421002421025371225210341231425812712385457524387445783221831214522243101348300521012720027421231000282102841259932274122812555318457257742125712644212225201280025310011252212013723100037445522154452138835754554225427831272152201245531025128310012420025203853100252103735122731037123283751251235887583524544458333173121572225210124520",
    crimsonFungus: "0g0gg00000000jz6rr30k181z30m81blr0m81d6n0oho3jz0v2w6wv0v4m7sv0xeekfz10p0npb1539r7j19jk7b31hbe96n1iftrsv1y125fj1y3kmbj0000000000000000000000000000000000000000000000000000000000000000000000ddbf00000000000fedbba0000000000eedefa00000000006aaee6000000003bddb633c60000001366633661000000013311331000000000004200000000000000570000000000000098000000000000008900000000000000970000000",
    warpedRoots: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000044100000000000004410000000000000132044100004410002004430000443040300332000033201410102000000201310010140000410303303001000003020030300110000303001030410000430310142010000010003001003000003003203300300000320200322020000002020220202000",
    twistingVines: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000003300000000000003130000000000000143140000000000044421300000000004412000000000001441200000000000141120000000004134130000000003134432000000000002113200000000000213300000000000034320000000000044432000000000004412200000000000241220000000",
    twistingVinesPlant: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000211320000000000002112014000000000231413130000000002144300000000000211410000000000023111300000000000231130000000000021132000000000004132200000000003443200000000410443320000000313444320000000000014322000000000031132000000000001132200000000000233220000000",
    netherSprouts: "0g0g4000000004lrqpr05omscf05qtg5b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000010300301003000001031030101300002101201020230100220120202021020",
    crimsonRoots: "0g0g500000000m79czj0rr17un13yjfun1bqosn30000000000000000000000000000000000000000000000000000000000000000000002002000000000004020202000000001443020020000002043403020200000203241303003000003244320232400320414203241042020040310404000403003003040300130030310223023131000303121021341000010310101013000",
    weepingVines: "0g0g400000000of09vj0suze9r0xana4f0000233002210000000013300221000000001210002300000000011000330000000001000231000000000000012000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    weepingVinesPlant: "0g0g800000000of09vj0suze9r0xana4f1539r7j19jk7b31iftrsv1y125fj0000232000320000000033100032670006513300001455606751310000111000001130000022200000233000002230000023156600033560000315756002210000001110000032000000033000012300000003320763220000000222001220000000665103220000000665440335600000000110033476000000223002310000",
    spruceTrapdoor: "0g0g90ehg7wf0gpo9330nd8pof0ohnzlr0rtudj30sxyewv0sywflr0xe36db0zm5jpb4873882853783754487385245357357445827734527528540163163163163160445345245345245445825735825828444582773452752854477275345374275447527735428427744843872542853574485385384387348448835428838824540162162163162160485385384387348448738828537837544873852453573574",
    oakTrapdoor: "0g0g700000000k1j85b0qq1m9r0v6c0sf11uughr17exm9r1czhmv31111111111111111245445554544545213122235512223412520006542000642242000654200064224200065420006521236565543666421254555454555555225554445545454422412223541222352252000655200065214100055420005412420006542000652253566554356664224555545455555421111111111111111",
    jungleTrapdoor: "0g0gb00000000ddc7b30k20av30sxhjb30sywflr0v5v6rj156edbz17emdq71cz0uf31f739bz1hfgvzz5533555355553555579989988999897339888768768768933789807007089873579800800a008975579000a0080009755780007007000875599a9a9aa9a9a995568767687686a8655787007007009875578800a008008875578870800807887537988878878889733798aa9888aa997557787122421787755535553533555335",
    ironTrapdoor: "0g0g800000731d0wq9r1f94rgf1hhcsn31lxn7y71n1wvlr1pa4wsf1ricxz31222333333322221244444455444444224233354423335422430005443000542343000544300054334300064430006433445567554567743354444555544445335444455554444533423335552333543343000544300054324300054430005432430006443000642244567744455674224444445544444421222233333322221",
    darkOakTrapdoor: "0g0g80b4hji70dcpj3z0govx1b0hsuakf0k12ayn0m94p330qpf4e70v5jv274455554554444444430000155300001440222275402222744024447440244475414445754144457541455575514555754166776551667764455455555455545444555545444555444300001543000015402222745022227540244475502444754144457551444575414555755145557441667764516677644445554455554444",
    crimsonTrapdoor: "0g0g700000000k0lmgv0pkufb30swv7r30ygss1r10ov667140vym72111121112112111154645656666545214223222233223412520000000000241151223211112214214556666556654521612211112322151262000000000024115200000000002411511121233221162244566664645546114122232112111611520000000000252152232233323226225665466666666422111122121112221",
    birchTrapdoor: "0g0ge0iwyb5r0ohcphb0sxn37j17fk83j19nxurj1f8hwxr1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v344433344434444336777766777766644733333333333374478bccbccaccb374478ccdaddbdcc374469abbaaabaaa374369cdcacdacdc374378cddbddaddc364379cdcbdcacdc363479bbaaabbaab374479cdcbddbcdc373479ccdaddadcc373379bc788999cb363378998666658836436776601206677733344433334444334",
    acaciaTrapdoor: "0g0ga00000000ehg7wf0ma8c1r0v74gsf11t4irj12xe4u7169evpb1btnnr31f5zoqn1jm4gzj4444444444444444466778888888877445558745587455844600974009740084460097400974008446009740097400844600974009740084460097400974008446009750097500844600975009750084460097500975008446009750097500844600975009750084477898778987789446898233332898644444412222144444",
    
    respawnAnchorTop1: "0g0gl000007307sgwlb08wkzjz09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k7b30b3kf7j0c7imf30c92oe70dbh0qn0dbh1j30efff270gnc7pb0l35s730ndeuwv0qn3ke70ziwirjicaiiiaiiiiiaicic222ccc222cck22ci21111111111112aaj100000000001cii2100000000001cii2100006700001ciic10005dfb0001kaic100677he90012ii210054589g0012iac1000433900012ii2100006800001ciic100000000001ciic100000000001jaa21111111111112ic22k2cc22c2cc22cicijiiiiiaiiiaci",
    respawnAnchorTop2: "0g0gr000007307sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c92oe70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjogcooocooooocogog222ggg222ggq22go21111111111112ccp100000000001goo2100053390001goo21006a78ef001goog105a6hjfie01qcog106788nibm012oo21066569blk012ocg1063544bdi012oo21006a797b001goog100087bd0001goog100000000001pcc21111111111112og22q2gg22g2gg22gogopooooocooocgo",
    respawnAnchorTop3: "0g0gv000007307sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c92oe70dbgzy70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0hral8f0hram0v0iv90cf0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjsgcssscssssscsgsg222ggg222ggu22gs21111111111112cct1000l6770001gss210mk5339e301gss210j6a78efo01gssg1b5a6ikfje31ucsg1b6788rjbqh12ss21m66569bml812scg1o63544bdji12ss210n6a797bo01gssg10mo87bdpk01gssg1000mbbp0001tcc21111111111112sg22u2gg22g2gg22gsgstssssscssscgs",
    respawnAnchorTop: "0g0gv07sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c7ipkv0c92oe70dbgzy70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0hral8f0hram0v0iv90cf0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjsgbsssbsssssbsgsg111ggg111ggu11gs10000000000001bbt028ol5663dp0gss108mk4228d2c0gss10oj5967deo40gssg0a495ikejd20ubsg0a5677rjaqh01ss10m55458aml701sbg0o52433acji01ss106n59686aoj0gssg03mo76acpk40gssg065omaapf520tbb10000000000001sg11u1gg11g1gg11gsgstsssssbsssbgs",
    respawnAnchorTopOff: "0g0g8013yfb307sgwlb08wkzjz0b3kf7j0c92oe70ndeuwv0qn3ke70ziwirj5435553555553545422244422244722452111111111111233610000000000145521000000000014552100000000001455410000000000173541000000000012552100000000001253410000000000125521000000000014554100000000001455410000000000163321111111111112542272442242442245456555553555345",
    respawnAnchorSide3: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd44749997144311ed34417911113391d933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide1: "0g0gf0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1x1ncov1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743d13479949994744de114474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorBottom: "0g0g80000073013yfb304gainz0a0p1q70b3kf7j0fksanz0qn3ke70ziwirj1000412105311353101204405216352100553013322723014532236212701640034244667701116122760211165311406712355410306004102522764006053000534723346032224260276321621264244671141100260302142612155322441552042235612421332161022264403103162131162040012106012324111411",
    respawnAnchorSide4: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd447499971443dfed3441791111339dd933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide2: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd4474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide0: "0g0gd0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirja9a6aaa99b9a9b9a7469a733337a69474499933333399944949974311347994999474411114474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    
    redBed: "0g0g600000000000008000006o0v5uwhc1ulak1c1uuozqo2200020002002555002000200200255522222222222225554444444444455555444444444455555544444444445555554444444444455555444444444444555533333333333333333333333333333333333333333333333333000001010000333300000111100033330001111111003333000111011100333300111000111033",
    oakSapling: "0g0g9000000004ixywv07vl8fz0hwqwvz0l50ohr0nhrtvj0ohcphb0v5v56n0yict8f0000000000000000000000000003000000000005002200000000103500187100000077231187660000535270177625000005378607705350000000774700055000000217530120000006762535276400003227678476423003330657746403300000053273500030000003547530000000000006745000000000000664000000",
    cryingObsidian: "0g0g80000073013yfb304gainz0a0p1q70b3kf7j0fksanz0qn3ke70ziwirj1000412105311353101204405216352100553013322723014532236212701640034244667701116122760211165311406712355410306004102522764006053000534723346032224260276321621264244671141100260302142612155322441552042235612421332161022264403103162131162040012106012324111411",
    netherGoldOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1cwijun1ihp1j31wzx4ov1y6dkvz1y70nb3131242554404454334432024521044215454771243914245654ab93545a814245659a45664552543154385665548445414520545542ba56553102454985894664245422744554145245ab40245455112354594025655270247254218254179321454254ba21545413545565a9834565124556423274545442245524530245544",
    
    potDirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
    flowerPot: "0g0g600000000rt2ayn0w91g5b0xd5gqn0zldh4v11tfugv0000000000000000000000000000000000000000000000000000000000000000000000000000000000000455321000000000050000200000000005000020000000000500002000000000050000300000000005443430000000000534423000000000054323100000000005443210000000000543421000000000053222100000",
		acaciaSapling: "0g0g700000000rvpou70sxskqn0wc5pmn0yi6z270ykjcan12yn0n30000000030000000000010035300000000015503405100000015355441561000000166364546510000001643526600000000543514431000000335512455110000003166446100000000064462100000000004354233000000033123121000000000314122400000000000464220000000000046420000000000002422000000",
    birchSapling: "0g0g700000000mbmpdr0ojuprz0u4vl6n1bxerr31jq1hj31qe337j0000000020000000000000033000000000000002422000000000032051330000000003325433200000003341651200000000302564412000000000231423200000000233543343000000233141241300000021346651020000033456663300000000303365030000000000233210000000000004210000000000000443000000",
    blueOrchidPot: "0g0g8000000005om32707xc2kf0a66pkv0bax81r0cfi2nz0k4nn5r0nhm4fz0000000000000000000000000000000000000000000000000000000000000000000000540000000000000343200003000000032630003440000000270000620000000000600700000003200020700000003436023430000000020070450000000000006720000000000000016000000000000000610000000000000010000000",
    crimsonRootsPot: "0g0g700000000m79czj0rr17un0yerif613yjfnm13yjfun1bqosn30000000000000000000000000000000000300000000000000003000000000000000042002052000000006020206000000000665020060000000005605020000000005261505000000000266520250000000016205261000000000510606000000000005060500000000000225020000000005121021500000000510101010000",
    darkOakSapling: "0g0g9000000004ixywv07vl8fz0hwqwvz0l50ohr0nhrtvj0ohcphb0v5v56n0yict8f0000000000000000000000000000000000000000000320000001233000130100000035213521320000132442521651000001412321431000000002111226640000003116221442000001106661441530000001326641000000003527674000000000147877600000000000787640000000000068674700000000066764660000",
    jungleSapling: "0g0g9000000006otm2n08x1lof0b6cyrj0c9dlvj0cbpz3z0ddhlof0ekev3z0flpm2n0000000000000000000007503000000000000573453000000000043647750000000057444347000000000378340300000000006853000000000534857430000000007737375000000000505863440000000000068457000000000035830300000000004387000000000005784530000000000058630000000000034214300000",
    spruceSapling: "0g0g7000000004g4qv308xo8an0c8liin0cabim70fmt6nz0m94p330000000000000000000000020000000000000021200000000000004150000000000005432400000000002426122000000000063245300000000003442552000000005442245000000000424522200000000003556254000000003546354500000002422635505000000004422244000000000023202000000000000110000000",
    warpedRootsPot: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000044100000000000004410000000000000132044100004410002004430000443040300332000033201410002000000200310013100000012303303000000000020030300000000003001030000000000310142000000000003001000000000003203300000000000200322000000000020220200000",
    
    pretty: "0g0g40001blc009d4hc009efw01ulak1c3300022112200033333022111122033303332112211233300033312222133300022333222233322022113330033311222112233333322112112220333302221111222033330222112112233333322112221133300333112202233322223332200033312222133300033321122112333033302211112203333300222112200033",
    
    pigFace: "0g0gr000006w14172ew1hejb3s1heul881luzbw81lvx4oo1o2w1dk1qb44541qbfcoo1sj0ws81sjc3qw1sjc5bs1sjndvc1sjnfg81sjynzs1sjypko1sk9y481skl9tk1ur8we01urk6ig1urvf201urvgmw1urvi7s1us6p6g1us6qrc1ustb081x2x0xkaa669999ddddbbddaa669999ddddbbdd7766ccii99kknnnn7766ccii99kknnnn88cceeeeddddeenn88cceeeeddddeenn00qqbbbbjjjjqq0000qqbbbbjjjjqq0099ddhhppppppggdd99ddhhppppppggddcccc11ddff11llllcccc11ddff11llll999922335544oomm999922335544oommbbbbddeellffffnnbbbbddeellffffnn",
    //*
    steveFace: "0g0gw08wkrnc0b4hipk0b4sr940dcpjw80fkxji00hs7rw80hsj0fs0hsuak80m9axh40sxbw8o0sxbxtk0xdgohk0zloo3c0zlopo811ta86w11twpa0141thx416a1hiw16acrnc16ao3co18i9h4o1aqhlh41aqsvlk1ar45q01cypmns1cz0ws81cz0yd41czc5bs1f78we01f78xyw1hfh0qg1x2x0xk221111110000111122111111000011111111113377441111111111337744111111rrttuuttttll3311rrttuuttttll33mmppmmnnjjttiiiimmppmmnnjjttiiiippvv88oott88vvmmppvv88oott88vvmmhhooqqaaaasskkcchhooqqaaaasskkccgggg66eeee66ffddgggg66eeee66ffdd999966556666ddbb999966556666ddbb",
    steveHeadTop: "0g0g406ocs1k08w9j3s08wkrnc0b4hipk3333223333222200333322333322221133223333332222223322333333222222333333223322222233333322332222222233332233333333223333223333333333333322223333333333332222333333333322223333333333332222333333333322333333113333332233332200333333333322222233333333222222223333",
    lexiFace: "0g0g6009pbso06oo3qw1urv2ew1utfnco1wxln201x2x0xk3333333333333333333333333333333333332222222233333333222222223333331111222211113333111122221111333355002222005533335500222200553333550022220055333355002222005533332222222222223333222222222222333322224444222233332222444422223333332222222233333333222222223333",
		lexiTop: "0g0g11utfnco0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    sarahFace: "0g0g6009ehh406o1hx406oo3qw1wugttk1x1114o1x2x0xk1111111111111111111111111111111111114411111111111111441111111111111122441111111111112244111111111155004444111111115500444411111111550044444411111155004444441111114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
		sarahTop: "0g0g106o1hx40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    sallyFace: "0g0g6000006w006lb0806oo3qw1sgim7s1wzrth41x2x0xk0000000000000000000000000000000000004444444400000000444444440000000022444422000000002244442200000000114444110000000011444411000000551144441155000055114444115500004444444444440000444444444444000044443333444400004444333344440000444444444444000044444444444400",
		sallyTop: "0g0g1000006w0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		face: "0g0g60077lrs0fkme480ohifp41unspvc1x1114o1x2x0xk1111111111111111111111111111111111114444444411111111444444441111112222444422221111222244442222111155004444005511115500444400551111550044440055111155004444005511114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
		faceTop: "0g0g10fkme480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    //*/
    
    cowSide:"0g0g400000000qoh7n40qoh7nc1uuozqw0000000000000000000000000000000000000000000000000000000000000000001111111111100011111111331111112233222333322322223332233332332222333222332233222233322222223322222222233322332222222222222222220220000000002200022000000000220002200000000022000220000000002200",
    cow: "0g0g20xd56go1uuozqw0000000000000000000100000001110000111000100111100011100000001111000110000000111100000001100001110010000111000000001100111100000000010011100110000000011100011000100001110000000011000000000001101100110000000100110011100011000010001111000110000000011100011100",
	}
  window.textures = textures

	const blockData = [
		{
			name: "air",
			id: 0,
			textures: [],
			transparent: true,
			shadow: false,
		},
		{
			name: "grass",
			textures: [ "dirt", "grassTop", "grassSide" ],
      breakTime: 10,
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
		{ name: "dirt", breakTime:40,
      digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
      stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"]
    },
		{ name: "stone", breakTime:80, stoneSound:true},
		{ name: "bedrock", breakTime:Infinity, stoneSound:true},
		{ name: "sand", breakTime:40,
      onupdate: function(x,y,z){
        if(world.getBlock(x,y-1,z)) return
        setTimeout(() => {
          world.setBlock(x,y,z, 0)
          world.addEntity(new BlockEntity(blockIds.sand, x,y,z, true))
        }, 100)
      },
      digSound: ["block.sand.dig1", "block.sand.dig2", "block.sand.dig3", "block.sand.dig4"],
      stepSound: ["block.sand.step1", "block.sand.step2","block.sand.step3","block.sand.step4","block.sand.step5"]},
		{ name: "gravel", breakTime:50,
      onupdate: function(x,y,z){
        if(world.getBlock(x,y-1,z)) return
        setTimeout(() => {
          world.setBlock(x,y,z, 0)
          world.addEntity(new BlockEntity(blockIds.gravel, x,y,z, true))
        }, 100)
      },
      digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
      stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"]},
		{
			name: "leaves",
			transparent: true,
      breakTime: 30,
      drop: "oakSapling",
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
		{
			name: "glass",
			transparent: true,
			shadow: false,
      breakTime: 60,
      glassSound: true
		},
		{ name: "cobblestone", breakTime:80, stoneSound:true},
		{ name: "mossyCobble", breakTime:80, stoneSound:true},
		{ name: "stoneBricks", breakTime:80, stoneSound:true},
		{ name: "mossyStoneBricks", breakTime:80, stoneSound:true},
		{ name: "bricks", breakTime:70, stoneSound:true},
		{ name: "coalOre", breakTime:80, stoneSound:true},
		{ name: "ironOre", breakTime:140, stoneSound:true},
		{ name: "goldOre", breakTime:240, stoneSound:true},
		{ name: "diamondOre", breakTime:420, stoneSound:true},
		{ name: "redstoneOre", breakTime:240, stoneSound:true},
		{ name: "lapisOre", breakTime:340, stoneSound:true},
		{ name: "emeraldOre", breakTime:340, stoneSound:true},
		{ name: "coalBlock", breakTime:80, stoneSound:true},
		{ name: "ironBlock", breakTime:140, stoneSound:true},
		{ name: "goldBlock", breakTime:240, stoneSound:true},
		{ name: "diamondBlock", breakTime:420, stoneSound:true},
		{ name: "redstoneBlock", breakTime:240, stoneSound:true},
		{ name: "lapisBlock", breakTime:340, stoneSound:true},
		{ name: "emeraldBlock", breakTime:340, stoneSound:true},
		{ name: "oakPlanks", breakTime:80, woodSound:true},
		{
			name: "oakLog",
			textures: [ "logTop", "logSide" ],
      breakTime:80,
      woodSound:true
		},
		{ name: "acaciaPlanks", breakTime:80, woodSound:true},
		{
			name: "acaciaLog",
			textures: [ "acaciaLogTop", "acaciaLogSide" ],
      breakTime:80,
      woodSound:true
		},
		{ name: "birchPlanks", breakTime:80, woodSound:true},
		{
			name: "birchLog",
			textures: [ "birchLogTop", "birchLogSide" ],
      breakTime:80,
      woodSound:true
		},
		{ name: "darkOakPlanks", breakTime:80, woodSound:true},
		{
			name: "darkOakLog",
			textures: [ "darkOakLogTop", "darkOakLogSide" ],
      breakTime:80,
      woodSound:true
		},
		{ name: "junglePlanks", breakTime:80,woodSound:true},
		{
			name: "jungleLog",
			textures: [ "jungleLogTop", "jungleLogSide" ],
      breakTime:80,
      woodSound:true
		},
		{ name: "sprucePlanks", breakTime:80, woodSound:true},
		{
			name: "spruceLog",
			textures: [ "spruceLogTop", "spruceLogSide" ],
      breakTime:80,
      woodSound:true
		},
		{ name: "whiteWool", breakTime:50, clothSound:true},
		{ name: "orangeWool", breakTime:50, clothSound:true},
		{ name: "magentaWool", breakTime:50, clothSound:true},
		{ name: "lightBlueWool", breakTime:50, clothSound:true},
		{ name: "yellowWool", breakTime:50, clothSound:true},
		{ name: "limeWool", breakTime:50, clothSound:true},
		{ name: "pinkWool", breakTime:50, clothSound:true},
		{ name: "grayWool", breakTime:50, clothSound:true},
		{ name: "lightGrayWool", breakTime:50, clothSound:true},
		{ name: "cyanWool", breakTime:50, clothSound:true},
		{ name: "purpleWool", breakTime:50, clothSound:true},
		{ name: "blueWool", breakTime:50, clothSound:true},
		{ name: "brownWool", breakTime:50, clothSound:true},
		{ name: "greenWool", breakTime:50, clothSound:true},
		{ name: "redWool", breakTime:50, clothSound:true},
		{ name: "blackWool", breakTime:50, clothSound:true},
		{ name: "whiteConcrete", breakTime:80, stoneSound:true},
		{ name: "orangeConcrete", breakTime:80, stoneSound:true},
		{ name: "magentaConcrete", breakTime:80, stoneSound:true},
		{ name: "lightBlueConcrete", breakTime:80, stoneSound:true},
		{ name: "yellowConcrete", breakTime:80, stoneSound:true},
		{ name: "limeConcrete", breakTime:80, stoneSound:true},
		{ name: "pinkConcrete", breakTime:80, stoneSound:true},
		{ name: "grayConcrete", breakTime:80, stoneSound:true},
		{ name: "lightGrayConcrete", breakTime:80, stoneSound:true},
		{ name: "cyanConcrete", breakTime:80, stoneSound:true},
		{ name: "purpleConcrete", breakTime:80, stoneSound:true},
		{ name: "blueConcrete", breakTime:80, stoneSound:true},
		{ name: "brownConcrete", breakTime:80, stoneSound:true},
		{ name: "greenConcrete", breakTime:80, stoneSound:true},
		{ name: "redConcrete", breakTime:80, stoneSound:true},
		{ name: "blackConcrete", breakTime:80, stoneSound:true},
		{
			name: "bookshelf",
			textures: [ "oakPlanks", "bookshelf" ],
      stoneSound: true
		},
		{ name: "netherrack",
      digSound: ["block.netherrack.dig1", "block.netherrack.dig2", "block.netherrack.dig3", "block.netherrack.dig4", "block.netherrack.dig5", "block.netherrack.dig6"],
      stepSound: ["block.netherrack.step1", "block.netherrack.step2","block.netherrack.step3","block.netherrack.step4","block.netherrack.step5","block.netherrack.step6"]},
		{ name: "soulSand",
      digSound: ["block.soul_sand.dig1", "block.soul_sand.dig2", "block.soul_sand.dig3", "block.soul_sand.dig4", "block.soul_sand.dig5", "block.soul_sand.dig6","block.soul_sand.step7","block.soul_sand.step8","block.soul_sand.step9"],
      stepSound: ["block.soul_sand.step1", "block.soul_sand.step2","block.soul_sand.step3","block.soul_sand.step4","block.soul_sand.step5","block.soul_sand.step6"]},
		{
			name: "glowstone",
			lightLevel: 15,
      glassSound: true
		},
		{ name: "netherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
		{ name: "redNetherBricks" ,
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
		{ name: "netherQuartzOre", 
      digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
      stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"]},
		{
			name: "quartzBlock",
			textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"],
      stoneSound: true
		},
		{
			name: "quartzPillar",
			textures: ["quartzPillarTop", "quartzPillar"],
      stoneSound: true
		},
		{
			name: "chiseledQuartzBlock",
			textures: ["chiseledQuartzBlock", "chiseledQuartzBlockTop"],
        stoneSound: true
		},
		{ name: "chiseledStoneBricks", stoneSound:true},
		{ name: "smoothStone", stoneSound:true},
		{ name: "andesite", stoneSound:true},
		{ name: "polishedAndesite", stoneSound:true},
		{ name: "diorite", stoneSound:true},
		{ name: "polishedDiorite", stoneSound:true},
		{ name: "granite", stoneSound:true},
		{ name: "polishedGranite", stoneSound:true},
		{ // I swear, if y'all don't stop asking about TNT every 5 minutes!
		  name: "tnt",
		  textures: ["tntBottom", "tntTop", "tntSides"],
      //onupdate: function(x,y,z){
      //  explode(x,y,z,5)
      //}, flint and steel explodes it
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
		{
      name: "light",
      solid:false,
      icon: "glass",
      shadow: false,
      transparent:true,
      lightLevel: 11,
      textures: "none",
      glassSound: true
    },
    {
      name: "portal",
      solid:false,
      shadow: false,
      portal: true,
      transparent:true,
      lightLevel: 11,
      ontouch: function(){
        portalEffect += 2
        if(portalEffect >= 100){
          portalEffect = 0
          //releasePointer()
          if(world.type === "nether"){
            world = dimensions.overworld
            //world.loadSave(world.getSaveString())
            changeScene("loading")
          }else{
            world = dimensions.nether
            //world.loadSave(world.getSaveString())
            changeScene("netherLoading")
          }
        }
      },
      glassSound: true
    },
    { name: "obsidian", stoneSound:true},
    {
      name:"redstoneDust",
      onupdate: function(x,y,z){
        var neigbors = [
          world.getBlock(x+1,y,z),
          world.getBlock(x-1,y,z),
          world.getBlock(x,y,z+1),
          world.getBlock(x,y,z-1),
          world.getBlock(x,y+1,z),
          world.getBlock(x,y-1,z)
        ];
        
        if(neigbors.includes(blockIds.redstoneBlock) || neigbors.includes(blockIds.redstoneDustOn)){
          world.setBlock(x,y,z, blockIds.redstoneDustOn, false, true)
        }
        
      }
    },
    {
      name:"redstoneDustOn",
      hidden: true,
      onupdate: function(x,y,z){
        var checked = []
        
        function touchingSource(x,y,z, t){
          t = t || 0;
          t ++;
          
          var neighbors = [
            [x+1,y,z],
            [x-1,y,z],
            [x,y,z+1],
            [x,y,z-1],
            [x,y+1,z],
            [x,y-1,z]
          ];
          
          for(var i=0; i<neighbors.length; i++){
            var value = neighbors[i];
            var block = world.getBlock(value[0], value[1], value[2])
            
            if(block === blockIds.redstoneBlock){
              return true;
            }
            
            if(t<10){
              if( !(checked.includes[value]) && (block === blockIds.redstoneDust || block === blockIds.buffer) && touchingSource(value[0], value[1], value[2], t)){
                checked.push(value);
                return true
              };
            }
            
          }
          return false;
        }
        
        if(!touchingSource(x,y,z)){
          world.setBlock(x,y,z, blockIds.redstoneDust);
        }
        
        //world.setBlock(x,y,z, blockIds.redstoneDust);
      }
    },
    {
      name: "buffer",
      textures: ["bufferTop", "bufferMiddle"],
      onupdate: function(x,y,z){
        setTimeout(() => {
          var isOn = world.getBlock(x,y+1,z);
          isOn = isOn === blockIds.redstoneDustOn || isOn === blockIds.redstoneBlock;
          if(isOn && world.getBlock(x,y-1,z) === blockIds.redstoneDust ){
            setTimeout(function(){world.setBlock(x,y-1,z, blockIds.redstoneDustOn)}, 500);
          }
        }, 10)
      }
    },
    { name: "soup"},
    { name: "soup2"},
    {
      name: "soup3",
      transparent:true,
    },
    { name: "soup4"},
    { name: "randomSoup"},
    {
      name: "redStain",
      transparent: true,
    },
    {
      name:"poision potion",
      transparent:true,
      crossShape:true,
    },
    
    {
      name: "light",
      textures: "none",
      transparent:true,
      lightLevel: 15,
      solid: false,
      icon: "glass",
      shadow: false
    },
    
    {
			name: "autumnLeaves",
			transparent: true,
		},
		{
			name: "darkLeaves",
			transparent: true,
		},
		{
			name: "redBerryLeaves",
			transparent: true,
		},
		{
			name: "blueBerryLeaves",
			transparent: true,
		},
    {
      name: "pinkLeaves",
      transparent: true,
    },
    
    { name: "flowerOftheValley",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
		{ name: "poppy",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
		{ name: "dandelion",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "blueOrchid",
		    solid: false,
		    transparent: true,
		    shadow: false,
        crossShape: true,
		},
    { name: "pinkTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "orangeTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "redTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "whiteTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "azureBluet",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "cornFlower",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "purpleFlower",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "allium",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "oxeyeDaisy",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "lilac",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "lilacBottom",
      potCross: true,
        tallcrossShape: true,
		},
    { name: "roseBush",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "roseBushBottom",
        tallcrossShape: true,
		},
    { name: "peony",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "peonyBottom",
        tallcrossShape: true,
		},
    { name: "witherRose",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
      ontouch: () => {witherEffect = 120; witherDamage = 1; witherTime = 2000}
		},
    { name: "TallGrass",
		    solid: false,
		    transparent: true,
		    shadow: false,
        crossShape: true,
		},
    
		{ 
      name: "oakDoor",
		  transparent: true,
		  shadow: false,
      textures: "oakDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "spruceDoor",
		  transparent: true,
		  shadow: false,
      textures:"spruceDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "ironDoor",
		  transparent: true,
		  shadow: false,
      textures:"ironDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "darkOakDoor",
		  transparent: true,
		  shadow: false,
      textures:"darkOakDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "birchDoor",
		  transparent: true,
		  shadow: false,
      textures:"birchDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "jungleDoor",
		  transparent: true,
		  shadow: false,
      textures:"jungleDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "acaciaDoor",
		  transparent: true,
		  shadow: false,
      textures:"acaciaDoorBottom",
      door:true,
      woodSound:true
    },
		{
      name: "warpedDoor",
		  transparent: true,
		  shadow: false,
      textures:"warpedDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "crimsonDoor",
		  transparent: true,
		  shadow: false,
      textures:"crimsonDoorBottom",
      door:true,
      woodSound:true
		},
    
    {
      name: "torch",
		  transparent: true,
		  shadow: false,
      torch: true,
      lightLevel: 13,
      woodSound:true
		},
		{
      name: "soulTorch",
		  transparent: true,
		  shadow: false,
      torch: true,
      lightLevel: 10,
      woodSound:true
		},
    
    {
      name: "lantern",
		  transparent: true,
		  shadow: false,
      lightLevel: 13,
      lantern: true,
      digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
      stepSound: ["block.lantern.step1", "block.lantern.step2","block.lantern.step3","block.lantern.step4","block.lantern.step5","block.lantern.step6"]
		},
    {
      name: "soulLantern",
		  transparent: true,
		  shadow: false,
      lightLevel: 10,
      lantern: true,
      digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
      stepSound: ["block.lantern.step1", "block.lantern.step2","block.lantern.step3","block.lantern.step4","block.lantern.step5","block.lantern.step6"]
		},
    
    {
      name: "beacon", 
		  transparent: true,
		  shadow: false,
      beacon: true,
      lightLevel: 15,
      glassSound: true
		},
    
    {
      name: "cactus",
		  textures: ["cactusBottom", "cactusTop", "cactusSide"],
		  transparent: true,
      cactus: true,
      damage: 1,
		},
    
    {
			name: "glassPane",
			transparent: true,
			shadow: false,
      breakTime: 60,
      pane:true,
      textures: ["glassPaneTop","glassPaneTop","glass","glass","glassPaneSide","glassPaneSide"],
      glassSound: true
		},
    
    { name: "ladder",
		  transparent: true,
		  shadow: false,
		  wallFlat: true
		},
		{ name: "vine",
		  transparent: true,
		  shadow: false,
		  wallFlat: true
		},
    
    {
      name: "Water",
      transparent: true,
      liquid: true,
      shadow: false //to hide faces
    },
    {
      name: "Lava",
      transparent: true,
      liquid: true,
      lightLevel:15,
      damage:4,
      shadow: false
    },
    
    {
      name: "craftingTable",
      textures: ["oakPlanks","craftingTableTop","craftingTableFront","craftingTableFront","craftingTableSide","craftingTableSide"],
      onclick: () => {changeScene("crafting"); releasePointer()},
      woodSound: true
    },
    
    {
      name: "crimsonNylium",
      textures: ["netherrack", "crimsonNyliumTop", "crimsonNyliumSide"],
      nyliumSound: true
    },
    {
      name: "warpedNylium",
      textures: ["netherrack", "warpedNyliumTop", "warpedNyliumSide"],
      nyliumSound: true
    },
    {
      name: "crimsonStem",
      textures: ["crimsonStemTop", "crimsonStemSide"],
      stemSound: true
    },
    {
      name: "warpedStem",
      textures: ["warpedStemTop", "warpedStemSide"],
      stemSound: true
    },
    { name: "netherWartBlock",
      digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
      stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
    { name: "warpedWartBlock",
      digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
      stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
    { name: "shroomlight", lightLevel:15,
      digSound: ["block.shroomlight.dig1", "block.shroomlight.dig2", "block.shroomlight.dig3", "block.shroomlight.dig4", "block.shroomlight.dig5"],
      stepSound: ["block.shroomlight.step1", "block.shroomlight.step2","block.shroomlight.step3","block.shroomlight.step4","block.shroomlight.step5","block.shroomlight.step6"]},
    { 
		  name: "warpedFungus",
		  solid: false,
		  shadow: false,
      transparent: true,
      crossShape: true,
      potCross: true,
      digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
		},
    {
			name: "blackstone",
			textures: ["blackstoneTop", "blackstone" ],
      stoneSound: true
		},
		{ name: "gildedBlackstone", stoneSound: true},
		{ name: "polishedBlackstoneBricks", stoneSound: true},
		{ name: "chiseledPolishedBlackstone", stoneSound: true},
		{ name: "netheriteBlock", 
      digSound: ["block.netherite.dig1", "block.netherite.dig2", "block.netherite.dig3", "block.netherite.dig4"],
      stepSound: ["block.netherite.step1", "block.netherite.step2","block.netherite.step3","block.netherite.step4","block.netherite.step5","block.netherite.step6"]},
    {
			name: "basalt",
			textures: [ "basaltTop", "basaltSide" ],
      basaltSound: true
		},
    {
			name: "polishedBasalt",
			textures: [ "polishedBasaltTop", "polishedBasaltSide" ],
      basaltSound: true
		},
		{ name: "chain", transparent:true, shadow:false, chain:true,
      digSound: ["block.chain.dig1", "block.chain.dig2", "block.chain.dig3", "block.chain.dig4"],
      stepSound: ["block.chain.step1", "block.chain.step2","block.chain.step3","block.chain.step4","block.chain.step5","block.chain.step6"]},
		{ name: "warpedPlanks", woodSound:true},
		{ 
		  name: "warpedTrapdoor",
		  transparent: true,
      shadow: false,
      trapdoor: true,
      woodSound:true
		},
		{ name: "magma", lightLevel:15},
		{
		  name: "crimsonFungus",
		  solid: false,
		  shadow: false,
      transparent: true,
      crossShape: true,
      potCross: true,
      digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
		},
		{ 
		    name: "warpedRoots",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true,
        rootSound: true
		},
		{ 
		    name: "crimsonRoots",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true,
      rootSound: true
		},
		{ 
		    name: "twistingVines",
      transparent: true,
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true
		},
		{ 
		    name: "twistingVinesPlant",
      transparent: true,
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true
		},
		{ 
		    name: "weepingVines",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true
		},
		{ 
		    name: "weepingVinesPlant",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true
		},
		{ 
		    name: "netherSprouts",
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true,
      digSound: ["block.nether_sprouts.dig1", "block.nether_sprouts.dig2", "block.nether_sprouts.dig3", "block.nether_sprouts.dig4"],
      stepSound: ["block.nether_sprouts.step1", "block.nether_sprouts.step2","block.nether_sprouts.step3","block.nether_sprouts.step4","block.nether_sprouts.step5"]
		},
    
    { name: "stoneButton", textures:"stone", button:true, transparent: true },
    
    { 
		  name: "RespawnAnchorOff",
		  textures: ["respawnAnchorBottom", "respawnAnchorTopOff", "respawnAnchorSide0"],
      onupdate: (x,y,z) => {if(world.type !== "nether"){explode(x,y,z,2)}}
		},
		{ 
		  name: "RespawnAnchor1",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop1", "respawnAnchorSide1"],
      hidden: true
		},
		{ 
		  name: "RespawnAnchor2",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop2", "respawnAnchorSide2"],
      hidden: true
		},
		{ 
		  name: "RespawnAnchor3",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop3", "respawnAnchorSide3"],
      hidden: true
		},
		{ 
		  name: "RespawnAnchor",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop", "respawnAnchorSide4"],
      hidden: true
		},
    
    {
      name:"redBed",
      onclick: (x,y,z) => {
        world.spawnPoint.x=x
        world.spawnPoint.y=y
        world.spawnPoint.z=z
        Messages.add("You can't sleep in beds yet")
        Messages.add("Respawn point set")
      },
      transparent: true,
      bed: true
    },
    
    {
      name: "flintAndSteel",
      textures: ["Lava", "none"],
      onuse: (x,y,z, block) => {
        if(block === blockIds.tnt){
          var e = new BlockEntity(blockIds.tnt, x,y,z)
          e.velx = (Math.random() * 0.1) - 0.05
          e.vely = Math.random() * 0.1
          e.velz = (Math.random() * 0.1) - 0.05
          world.addEntity(e)
          world.setBlock(x,y,z,0)
          playSound("entity.tnt.fuse", 0, posSound(x,y,z))
          var i = 0
          var int = setInterval(() => {
            e.changeBlock((i % 2) ? blockIds.tnt : blockIds.whiteConcrete)
            if(i >= 8){
              clearInterval(int)
              e.canDespawn = true
              explode(round(e.x),round(e.y),round(e.z),4)
            }
            i++
          },500)
        }
      }
    },
    
    {
      name: "barrier",
      textures: "none",
      icon: "redConcrete",
      transparent:true
    },
    {
      name: "oakSapling",
      crossShape: true,
      potCross: true,
      transparent: true,
      solid: false,
    },
    
    { 
		  name: "crimsonTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "oakTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "spruceTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "darkOakTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "birchTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "jungleTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "acaciaTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "ironTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    
    { 
      name: "cryingObsidian",
      shadow: false,
      lightLevel: 10
    },
    { name: "netherGoldOre",
      digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
      stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"]},
    {
			name: "flowerPot",
			transparent: true,
			shadow: false,
      pot: true
		},
		{
			name: "acaciaSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "birchSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "darkOakSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "jungleSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "spruceSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "blueOrchidPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
		{
			name: "warpedRootsPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
		{
			name: "crimsonRootsPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
    { name: "whiteCarpet", textures: "whiteWool", carpet: true, clothSound:true},
		{ name: "orangeCarpet", textures: "orangeWool", carpet: true, clothSound:true},
		{ name: "magentaCarpet", textures: "magentaWool", carpet: true, clothSound:true},
		{ name: "lightBlueCarpet", textures: "lightBlueWool", carpet: true, clothSound:true},
		{ name: "yellowCarpet", textures: "yellowWool", carpet: true, clothSound:true},
		{ name: "limeCarpet", textures: "limeWool", carpet: true, clothSound:true},
		{ name: "pinkCarpet", textures: "pinkWool", carpet: true, clothSound:true},
		{ name: "grayCarpet", textures: "grayWool", carpet: true, clothSound:true},
		{ name: "lightGrayCarpet", textures: "lightGrayWool", carpet: true, clothSound:true},
		{ name: "cyanCarpet", textures: "cyanWool", carpet: true, clothSound:true},
		{ name: "purpleCarpet", textures: "purpleWool", carpet: true, clothSound:true},
		{ name: "blueCarpet", textures: "blueWool", carpet: true, clothSound:true},
		{ name: "brownCarpet", textures: "brownWool", carpet: true, clothSound:true},
		{ name: "greenCarpet", textures: "greenWool", carpet: true, clothSound:true},
		{ name: "redCarpet", textures: "redWool", carpet: true, clothSound:true},
		{ name: "blackCarpet", textures: "blackWool", carpet: true, clothSound:true},
    
    //*
    { name: "pigFace" },
		{ 
		  name: "steveFace",
		  textures: ["steveHeadTop", "steveFace"]
		},
    { name: "sarahFace",
      textures: ["sarahTop", "sarahFace"]
    },
    {
      name: "lexiFace",
      textures: ["lexiTop","lexiFace"]
    },
    {
      name: "sallyFace",
      textures: ["sallyTop","sallyFace"]
    },
    {
      name: "face",
      textures: ["faceTop","face"]
    },//*/
	];

	const BLOCK_COUNT = blockData.length;
  window.console.log(BLOCK_COUNT)

  const emptyFunc = function(){}
  var stoneDigSound = ["block.stone.dig1", "block.stone.dig2", "block.stone.dig3", "block.stone.dig4"],
      stoneStepSound = ["block.stone.step1", "block.stone.step2","block.stone.step3","block.stone.step4","block.stone.step5","block.stone.step6"],
      woodDigSound = ["block.wood.dig1", "block.wood.dig2", "block.wood.dig3", "block.wood.dig4"],
      woodStepSound = ["block.wood.step1", "block.wood.step2","block.wood.step3","block.wood.step4","block.wood.step5","block.wood.step6"],
      clothDigSound = ["block.cloth.dig1", "block.cloth.dig2", "block.cloth.dig3", "block.cloth.dig4"],
      clothStepSound = ["block.cloth.step1", "block.cloth.step2","block.cloth.step3","block.cloth.step4"],
      glassDigSound = ["block.glass.dig1", "block.glass.dig2", "block.glass.dig3"],
      nyliumDigSound = ["block.nylium.dig1", "block.nylium.dig2", "block.nylium.dig3", "block.nylium.dig4", "block.nylium.dig5", "block.nylium.dig6"],
      nyliumStepSound = ["block.nylium.step1", "block.nylium.step2","block.nylium.step3","block.nylium.step4","block.nylium.step5","block.nylium.step6"],
      stemDigSound = ["block.stem.dig1", "block.stem.dig2", "block.stem.dig3", "block.stem.dig4", "block.stem.dig5", "block.stem.dig6"],
      stemStepSound = ["block.stem.step1", "block.stem.step2","block.stem.step3","block.stem.step4","block.stem.step5","block.stem.step6"],
      basaltDigSound = ["block.basalt.dig1", "block.basalt.dig2", "block.basalt.dig3", "block.basalt.dig4", "block.basalt.dig5"],
      basaltStepSound = ["block.basalt.step1", "block.basalt.step2","block.basalt.step3","block.basalt.step4","block.basalt.step5","block.basalt.step6"],
      rootDigSound = ["block.roots.dig1", "block.roots.dig2", "block.roots.dig3", "block.roots.dig4", "block.roots.dig5", "block.roots.dig6"],
      rootStepSound = ["block.roots.step1", "block.roots.step2","block.roots.step3","block.roots.step4","block.roots.step5","block.roots.step6"]
	// Set defaults on blockData
	for (let i = 1; i < BLOCK_COUNT; ++i) {
		const data = blockData[i];
		data.id = i;

		if ( !("textures" in data) ) {
			data.textures = new Array(6).fill(data.name);
		} else if (typeof data.textures === "string") {
			data.textures = new Array(6).fill(data.textures);
		} else {
			const { textures } = data;

			if (textures.length === 3) {
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
			} else if (textures.length === 2) {
				// Top and bottom are the first texture, sides are the second.
				textures[2] = textures[1];
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
				textures[1] = textures[0];
			}
		}

		data.transparent = data.transparent || false

		data.shadow = data.shadow !== undefined ? data.shadow	: true

		data.lightLevel = data.lightLevel || 0
    
    data.onupdate = data.onupdate || emptyFunc
      
    if(data.solid === undefined)data.solid = true
    
    data.breakTime = data.breakTime || 4 // frames for total mine
    
    if(data.stoneSound){
      data.digSound = stoneDigSound
      data.stepSound = stoneStepSound
    }
    if(data.woodSound){
      data.digSound = woodDigSound
      data.stepSound = woodStepSound
    }
    if(data.clothSound){
      data.digSound = clothDigSound
      data.stepSound = clothStepSound
    }
    if(data.glassSound){
      data.digSound = glassDigSound
      data.placeSound = stoneDigSound
    }
    if(data.nyliumSound){
      data.digSound = nyliumDigSound
      data.stepSound = nyliumStepSound
    }
    if(data.stemSound){
      data.digSound = stemDigSound
      data.stepSound = stemStepSound
    }
    if(data.basaltSound){
      data.digSound = basaltDigSound
      data.stepSound = basaltStepSound
    }
    if(data.rootSound){
      data.digSound = rootDigSound
      data.stepSound = rootStepSound
    }
	}
  
  let textureIds = {}
  let idx = -1
  for(var i in textures){
    idx ++
    textureIds[i] = idx
  }
  window.textureIds = textureIds
  
  // survival inventory
  let invItems = [1];
  let invLength = 13*9;
  for(let i=0; i<invLength; i++){
    if(!invItems[i]){
      invItems.push({id:0,amount:64})
    }
  }
  //add something to inventory
  function newInvItem(id){
    //look for empty slot
    for(let i=0; i<inventory.hotbar.length; i++){
      if(!inventory.hotbar[i].id){
        inventory.hotbar[i] = {id:id, amount:1}
        return true
      }
      if(inventory.hotbar[i].id === id && inventory.hotbar[i].amount < 64){
        inventory.hotbar[i].amount ++;
        return true
      }
    }
    for(let i=0; i<invLength; i++){
      if(!(invItems[i] && invItems[i].id)){
        invItems[i] = {id:id, amount:1}
        return true
      }
      if(invItems[i].id === id && invItems[i].amount < 64){
        invItems[i].amount ++;
        return true
      }
    }
    return false
  }
  
  const crafts = {
    "oakLog": {name:"oakPlanks", amount:4},
    "acaciaLog": {name:"acaciaPlanks", amount:4},
    "birchLog": {name:"birchPlanks", amount:4},
    "darkOakLog": {name:"darkOakPlanks", amount:4},
    "jungleLog": {name:"junglePlanks", amount:4},
    "spruceLog": {name:"sprucePlanks", amount:4},
    "oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"oakDoor", amount:3},
    "acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"acaciaDoor", amount:3},
    "birchPlanks,birchPlanks,air,birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"birchDoor", amount:3},
    //i dont want to make the rest of the doors
    "oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"oakTrapdoor", amount:2},
    "redWool,redWool,redWool,oakPlanks,oakPlanks,oakPlanks":{name:"redBed", amount:3},
    "oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"craftingTable", amount:1},
  }
  
	// implementation of xxHash
	const {
		seedHash,
		hash
	} = (() => {
		// closure around mutable `seed`; updated via calls to `seedHash`

		let seed = Math.random() * 2100000000 | 0;

		const PRIME32_2 = 1883677709;
		const PRIME32_3 = 2034071983;
		const PRIME32_4 = 668265263;
		const PRIME32_5 = 374761393;

		const seedHash = s => {
			seed = s | 0;
		}

		const { imul } = Math;

		const hash = (x, y) => {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += imul(x, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(y, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};

		return {
			seedHash,
			hash
		};
	})();

	const win = window.parent;
	const doc = document;
	const { console } = win;
	let world;
	let worldSeed;
  let dimensions;

	class Marsaglia {
		// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c

		nextInt() {
			const { z, w } = this;

			this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
			this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;

			return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
		}

		nextDouble() {
			const i = this.nextInt() / 4294967296;

			const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0

			return is_less_than_zero + i;
		}

		constructor(i1, i2) { // better param names
			this.z = (i1 | 0) || 362436069;
			this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
		}
	}

	// The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls

	const {
		randomSeed,
		random
	} = (() => {
		// closure around mut `currentRandom`

		let currentRandom = null;

		const randomSeed = seed => {
			currentRandom = new Marsaglia(seed);
		};

		const random = (min, max) => {
			if (!max) {
				if (min) {
					max = min;
					min = 0;
				} else {
					min = 0;
					max = 1;
				}
			}

			return currentRandom.nextDouble() * (max - min) + min;
		};

		return {
			randomSeed,
			random
		};
	})();

	class PerlinNoise {
		// http://www.noisemachine.com/talk1/17b.html
		// http://mrl.nyu.edu/~perlin/noise/

		static grad3d(i, x, y, z) {
			const h = i & 15; // convert into 12 gradient directions

			const u = h < 8
				? x
				: y;

			const v = h < 4
				? y
				: h === 12 || h === 14
					? x
					: z;

			return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
		}

		static grad2d(i, x, y) {
			const v = (i & 1) === 0
				? x
				: y;

			return (i & 2) === 0
				? -v
				: v;
		}

		static grad1d(i, x) {
			return (i & 1) === 0
				? -x
				: x;
		}

		static lerp(t, a, b) {
			return a + t * (b - a);
		}

		// end of statics

		// permutation
		perm = new Uint8Array(0x200);

		// prototype functions:
		noise3d(x, y, z) {
			const { floor } = Math;

			const X = floor(x) & 0xff;
			const Y = floor(y) & 0xff;
			const Z = floor(z) & 0xff;

			x -= floor(x);
			y -= floor(y);
			z -= floor(z);

			const fx = (3 - 2 * x) * x * x;
			const fy = (3 - 2 * y) * y * y;
			const fz = (3 - 2 * z) * z * z;

			const { perm } = this;

			const p0 = perm[X] + Y;
			const p00 = perm[p0] + Z;
			const p01 = perm[p0 + 1] + Z;
			const p1 = perm[X + 1] + Y;
			const p10 = perm[p1] + Z;
			const p11 = perm[p1 + 1] + Z;

			const { lerp, grad3d } = PerlinNoise;

			return lerp(
				fz,
				lerp(
					fy,
					lerp(
						fx,
						grad3d(perm[p00], x, y, z),
						grad3d(perm[p10], x - 1, y, z)
					),
					lerp(
						fx,
						grad3d(perm[p01], x, y - 1, z),
						grad3d(perm[p11],x - 1, y - 1, z)
					)
				),
				lerp(
					fy,
					lerp(
						fx,
						grad3d(perm[p00 + 1], x, y, z - 1),
						grad3d(perm[p10 + 1], x - 1, y, z - 1)
					),
					lerp(
						fx,
						grad3d(perm[p01 + 1], x, y - 1, z - 1),
						grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
					)
				)
			);
		}

		noise2d(x, y) {
			const { floor } = Math;

			const X = floor(x) & 0xff;
			const Y = floor(y) & 0xff;

			x -= floor(x);
			y -= floor(y);

			const { perm } = this;
			const fx = (3 - 2 * x) * x * x;
			const fy = (3 - 2 * y) * y * y;
			const p0 = perm[X] + Y;
			const p1 = perm[X + 1] + Y;

			const { lerp, grad2d } = PerlinNoise;

			return lerp(
				fy,
				lerp(
					fx,
					grad2d(
						perm[p0],
						x,
						y
					),
					grad2d(
						perm[p1],
						x - 1,
						y
					)
				),
				lerp(
					fx,
					grad2d(
						perm[p0 + 1],
						x,
						y - 1
					),
					grad2d(
						perm[p1 + 1],
						x - 1,
						y - 1
					)
				)
			);
		}

		noise1d(x) {
			const { floor } = Math;

			const X = floor(x) & 0xff;

			x -= floor(x);

			const fx = (3 - 2 * x) * x * x;

			const { lerp, grad1d } = PerlinNoise;

			return lerp(
				fx,
				grad1d(perm[X], x),
				grad1d(perm[X + 1], x - 1)
			);
		}

		constructor(seed) {
			if (seed === undefined) {
				throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
			}

			const rnd = new Marsaglia(seed);

			// generate permutation
			const { perm } = this;

			// fill 0x0..0x100
			for (let i = 0; i < 0x100; ++i) {
				perm[i] = i;
			}

			for (let i = 0; i < 0x100; ++i) {
				const j = rnd.nextInt() & 0xFF;
				const t = perm[j];
				perm[j] = perm[i];
				perm[i] = t;
			}

			// copy to avoid taking mod in perm[0]
			// copies from first half of array, into the second half
			perm.copyWithin(0x100, 0x0, 0x100);
		}
	}

	const noiseProfile = {
		generator: undefined,
		octaves: 4,
		fallout: 0.5,
		seed: undefined,
		noiseSeed(seed) {
			this.seed = seed;
			this.generator = new PerlinNoise(noiseProfile.seed);
		},
		noise(x, y, z) {
			const { generator, octaves, fallout } = (this || noiseProfile);

			let effect = 1,
				k = 1,
				sum = 0;

			for (let i = 0; i < octaves; ++i) {
				effect *= fallout;

				const k = 1 << i;

				let temp;
				switch (arguments.length) {
					case 1: {
						temp = generator.noise1d(k * x);
						break;
					} case 2: {
						temp = generator.noise2d(k * x, k * y);
						break;
					} case 3: {
						temp = generator.noise3d(k * x, k * y, k * z);
						break;
					}
				}

				sum += effect * (1 + temp) / 2;
			}

			return sum;
		}
	};
  const noise = noiseProfile.noise

	let caveNoise;
	// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
	function openSimplexNoise(clientSeed) {
		const SQ4 = 2
		const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) }
		const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) }
		const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) }
		const NORM_3D = 1.0 / 206.0
		const SQUISH_3D = 1 / 3
		const STRETCH_3D = -1 / 6
		var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
		const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
		var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) }
		var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
		const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a }
		const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} }

		function shuffleSeed(seed,count){
			seed = seed * 1664525 + 1013904223 | 0
			count -= 1
			return count > 0 ? shuffleSeed(seed, count) : seed
		}
		const types = {
			_3D : {
				base : base3D,
				squish : SQUISH_3D,
				dimensions : 3,
				pD : p3D,
				lookup : lookupPairs3D,
			}
		}

		function createContribution(type, baseSet, index) {
			var i = 0
			const multiplier = baseSet[index ++]
			const c = { next : undefined }
			while(i < type.dimensions) {
				const axis = ("xyzw")[i]
				c[axis + "sb"] = baseSet[index + i]
				c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
			}
			return c
		}

		function createLookupPairs(lookupArray, contributions){
			var i
			const a = lookupArray()
			const res = new Map()
			for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
			return res
		}

		function createContributionArray(type) {
			const conts = []
			const d = type.dimensions
			const baseStep = d * d
			var k, i = 0
			while (i < type.pD.length) {
				const baseSet = type.base[type.pD[i]]
				let previous, current
				k = 0
				do {
					current = createContribution(type, baseSet, k)
					if (!previous) { conts[i / baseStep] = current; }
					else { previous.next = current; }
					previous = current
					k += d + 1
				} while(k < baseSet.length)

				current.next = createContribution(type, type.pD, i + 1)
				if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
				if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
				i += baseStep
			}
			const result = [conts, createLookupPairs(type.lookup, conts)]
			type.base = undefined
			type.lookup = undefined
			return result
		}

		let temp = createContributionArray(types._3D)
		const contributions3D = temp[0], lookup3D = temp[1]
		const perm = new Uint8Array(256)
		const perm3D = new Uint8Array(256)
		const source = new Uint8Array(setOf(256))
		var seed = shuffleSeed(clientSeed, 3)
		doFor(256, function(i) {
			i = 255 - i
			seed = shuffleSeed(seed, 1)
			var r = (seed + 31) % (i + 1)
			r += r < 0 ? i + 1 : 0
			perm[i] = source[r]
			perm3D[i] = (perm[i] % 24) * 3
			source[r] = source[i]
		})
		base3D = undefined
		lookupPairs3D = undefined
		p3D = undefined

		return function(x, y, z) {
			const pD = perm3D
			const p = perm
			const g = gradients3D
			const stretchOffset = (x + y + z) * STRETCH_3D
			const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
			const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
			const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
			const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
			const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
			const inSum = xins + yins + zins
			var c = lookup3D.get(
				(yins - zins + 1) |
				((xins - yins + 1) << 1) |
				((xins - zins + 1) << 2) |
				(inSum << 3) |
				((inSum + zins) << 5) |
				((inSum + yins) << 7) |
				((inSum + xins) << 9)
			)
			var i, value = 0
			while (c !== undefined) {
				const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
				let attn = 2 - dx * dx - dy * dy - dz * dz
				if (attn > 0) {
					i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF]
					attn *= attn
					value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
				}
				c = c.next
			}
			return value * NORM_3D + 0.5
		}
	}
  
  //copied from https://gist.github.com/bzdgn/d722c961f45d97ea8efc6cef3aa39e76
  function nodeRotationX(node, theta) {
				var cosTheta = Math.cos(theta);
				var sinTheta = Math.sin(theta);
				
				var y = node.y;
				var z = node.z;
				
				node.y = y * cosTheta - z * sinTheta;
				node.z = y * sinTheta + z * cosTheta;
	}
  function nodeRotationY(node, theta) {
				var cosTheta = Math.cos(theta);
				var sinTheta = Math.sin(theta);
				
				var x = node.x;
				var z = node.z;
				
				node.x = x * cosTheta - z * sinTheta;
				node.z = x * sinTheta + z * cosTheta;
	}
  var node = {x:0, y:0, z:0}
  function getRotation(rotX, rotY){
    node.x = 1
    node.y = 1
    node.z = 1
    
    nodeRotationX(node, rotX)
    nodeRotationY(node, rotY)
    
    return node
  }
  win.getRotation = getRotation

	class PVector {
		constructor(x, y, z) {
			this.x = x
			this.y = y
			this.z = z
		}
		set(x, y, z) {
			if (y === undefined) {
				this.x = x.x
				this.y = x.y
				this.z = x.z
			} else {
				this.x = x
				this.y = y
				this.z = z
			}
		}
		normalize() {
			let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
			this.x /= mag
			this.y /= mag
			this.z /= mag
		}
		add(v) {
			this.x += v.x
			this.y += v.y
			this.z += v.z
		}
		mult(m) {
			this.x *= m
			this.y *= m
			this.z *= m
		}
	}
	let fill = function(r, g, b, a) {
		if (g === undefined) {
			g = r
			b = r
		}
    a = a || a === 0 ? a : 100
		ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ", "+a+"%)"
	}
	let stroke = function(r, g, b) {
		if (g === undefined) {
			g = r
			b = r
		}
		ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let line = function(x1, y1, x2, y2) {
		ctx.moveTo(x1, y1)
		ctx.lineTo(x2, y2)
	}
  let ellipse = function(x,y,w,h){
	    if(ctx.ellipse){
	        ctx.ellipse(x,y,w,h,0, 0,Math.PI*2)
	    }
	}
	function text(txt, x, y, h) {
		h = h || 0

		let lines = txt.split("\n")
		for (let i = 0; i < lines.length; i++) {
			ctx.fillText(lines[i], x, y + h * i)
		}
	}
	function textSize(size) {
		ctx.font = size + 'px VT323' // VT323
	}
	let strokeWeight = function(num) {
		ctx.lineWidth = num
	}
  function map(v, min, max, min2, max2){
    return min2 + (max2 - min2) * ((v - min) / (max - min));
  }
  function dist2(x,y,x2,y2){
    let xDist = x - x2
    let yDist = y - y2
    return sqrt((xDist*xDist)+(yDist*yDist))
  }
  function dist3(x,y,z,x2,y2,z2){
    let xDist = x - x2
    let yDist = y - y2
    let zDist = z - z2
    return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
  }
	const ARROW = "arrow"
	const HAND = "pointer"
	let cursor = function(type) {
		canvas.style.cursor = type
	}
	randomSeed(Math.random() * 10000000 | 0)

	async function createDatabase() {
		return await new Promise(async (resolve, reject) => {
			let request = window.indexedDB.open("Geekycraft", 1)

			request.onupgradeneeded = function(event) {
				let DB = event.target.result
				// Worlds will contain and ID containing the timestamp at which the world was created, a "saved" timestamp,
				// and a "data" string that's identical to the copy/paste save string
				let store = DB.createObjectStore("worlds", { keyPath: "id" })
				store.createIndex("id", "id", { unique: true })
				store.createIndex("data", "data", { unique: false })
			}

			request.onsuccess = function(e) {
				resolve(request.result)
			}

			request.onerror = function(e) {
				console.error(e)
				reject(e)
			}
		})
	}
	async function loadFromDB(id) {
		return await new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = id ? store.get(id) : store.getAll()
			req.onsuccess = function(e) {
				resolve(req.result)
				db.close()
			}
			req.onerror = function(e) { 
				resolve(null)
				db.close()
			}
		})
	}
	async function saveToDB(id, data) {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = store.put({ id: id, data: data })
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(e)
			}
		})
	}
	async function deleteFromDB(id) {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = store.delete(id)
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(e)
			}
		})
	}

	function save() {
		saveToDB(world.id, {
			id: world.id,
			edited: Date.now(),
			name: world.name,
			version: version,
			code: world.getSaveString(),
      nether: world.getNetherSaveString(),
      inv: world.getInv(),
      surviv: world.getSurvivStr(),
      mod: world.mod
		}).then(() => world.edited = Date.now()).catch(e => console.error(e))
	}
  win.save = save

	// Expose these functions to the global scope for debugging
	win.saveToDB = saveToDB
	win.loadFromDB = loadFromDB
	win.createDatabase = createDatabase
	win.deleteFromDB = deleteFromDB

	//globals
	//{
	let version = "Alpha 1.0.0"
  let normReach = 5
  let bigReach = 40
  let reach = normReach // Max distance player can place or break blocks
	let sky = [/*0.33, 0.54, 0.72, <originl sky>*/  0.6, 0.8, 0.9] // 0 to 1 RGB color scale
  function changeSky(type){
    if(type === "nether"){
      sky = [0,0,0]
    }else{
      sky = [0.6, 0.8, 0.9]
    }
  }
  let soundOn = true
	let superflat = false
	let trees = true
	let caves = true
  win.survival = false;

	let blockIds = {}
	blockData.forEach(block => blockIds[block.name] = block.id)
	win.blockData = blockData
	win.blockIds = blockIds
  
  //fill the crafts that have less than 9 items. Ex: "thing" => "thing,air,air..."
  let arr = []
  for(let i in crafts){
    arr = i.split(",")
    for(let j = 0; j<9; j++){
      if(arr[j]){
        arr[j] = blockIds[arr[j]]
      }else{
        arr.push(0)
      }
    }
    crafts[i].id = blockIds[crafts[i].name]
    crafts[arr.join(",")] = crafts[i]
    
    delete crafts[i]
  }
  window.crafts = crafts

	let currentFov

	// Configurable and savable settings
	let settings = {
		renderDistance: 4,
		fov: 70, // Field of view in degrees
		mouseSense: 100 // Mouse sensitivity as a percentage of the default
	}
	let locked = true
	let generatedChunks
	let mouseX, mouseY, mouseDown
	let width = window.innerWidth
	let height = window.innerHeight

	if (height === 400) alert("Canvas is too small. Click the \"Settings\" button to the left of the \"Vote Up\" button under the editor and change the height to 600.")

	let generator = {
		height: 80, // Height of the hills
		smooth: 0.01, // Smoothness of the terrain
		extra: 30, // Extra height added to the world.
		caveSize: 0.00, // Redefined right above where it's used
    biomeSmooth: 0.007, // Smoothness of biomes
	}
	let maxHeight = 255
	let blockOutlines = false
	let blockFill = true
	let updateHUD = true
  
  let images = {
    deadHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAT0lEQVQoU62OwQ3AMAwCz1N4//E8RSqjuiVRn/ULocMQvLduGYBr2uhbmSlRVbgGQqkx7esjO/QvtG3yyq6aTeNv2wYQdYwV6MAXpOozfAGB1SIH1uYKrgAAAABJRU5ErkJggg==",
    heart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAXElEQVQoU3XQQRKAIAiF4Z97ua8j19572UCSTytWjHwCgzGi9dQAzfEHj/YrwOJXgFqhFGl8pw4GepUXdADbBzqBvXeKnVaYwE0uPkEFuZcOio4+QqY8J5igAi9cnpgXB7uKmTQAAAAASUVORK5CYII=",
    halfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAY0lEQVQoU4WOwQ3AMAgDzS50i/zbkTtAxmCXVLiBoKhS+YDMYSxYNeYoAOoMF7xGVVWVopl5E14R6B1ojctjQgEuqPz9hG4A5w/ETBUMp5opPBJ0KAAmL1/S8XrF3O0Qwf34AVFaJQc+FQukAAAAAElFTkSuQmCC",
    whiteHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAARUlEQVQoU61QQQ4AIAiK/z+aBsuNbN7ykKQEJtYJkhQEgMSu6VBRzQn7VRFKNbP7/0h9jscqZ+m2efePcg21ghS4SJP1BvDiR/68vCmnAAAAAElFTkSuQmCC",
    witherHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAJ1BMVEUAAAAAAAA7ExPLy8srKysvDw8nJycdHR0qDg4gICA5HBxHHBz///8BX2maAAAAAXRSTlMAQObYZgAAAAFiS0dEDIGzUWMAAAAHdElNRQfkCBcNAScIdsCqAAAAAW9yTlQBz6J3mgAAADpJREFUCNdjYBBkFGBgYFQSUmRgEDJRcRJgEHVxcxdgkJjmMkuAgbHTcyEDA4PEbKAaBsaNDCAAZAIArksGwN+RpQkAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTM6MDE6MzkrMDA6MDAs2fv0AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDEzOjAxOjM5KzAwOjAwXYRDSAAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MTg3Njk53UrJaAAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTA3NzIwNzAyOTQ0NjEzMTIwMzcf2rzMAAAAAElFTkSuQmCC",
    witherHalfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAlElEQVQoU2NkQID/UCYjAwMDMpsBJAAC/y24ucGME1+/MoiLi4PZL1++BFGMYF0gBVMOHmSIjo5mEHzyhOE+Dw/cfJBCsCJtNjaGP4qKcIkPHz5gKlJlY2P4KiLCwMHBwcDKysqATRHYTTCFvLy8cEXIboIZDVf49+9fuKPBLkcKArCJrqKiDLtfv0aRQ1cEVoiuGQBusjgHiQpSWAAAAABJRU5ErkJggg==",
  }
  for(var i in images){
    var url = images[i]
    images[i] = new Image()
    images[i].src = url
  }
  win.images = images
  let audioCtx
  
	let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
      CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,WALL,
      WALLU,//wall withe exteion under another wall
      FENCQ,//fence (one extension)
      BUTTON,CHAIN,POT,POTCROSS,CARPET,
	    FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
  var prevConstVersion = null
  function constVersion(v){
    if(v === prevConstVersion) return
    prevConstVersion = v
    if(v.replace(/Alpha /g, '').split(".")[0] !== "0"){
CUBE = 0
SLAB = 0x100 // 9th bit
STAIR = 0x200 // 10th bit
CROSS = 0x300
FLIP = 0x400 // 11th bit
TALLCROSS = 0x700
LANTERN = 0x900
LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
TORCH = 0x1800
CHAIN = 0x1900
DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
WALL = 0x6400
WALLU = 0x6600 //wall withe exteion under another wall
FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
    }else{
      CUBE      = 0
      SLAB      = 0x100 // 9th bit
      STAIR     = 0x200 // 10th bit
      CROSS     = 0x2000
      TALLCROSS = 0x2200
      DOOR      = 0x2400
      TORCH     = 0x2600
      LANTERN   = 0x2800
      LANTERNHANG=0x3000
      BEACON    = 0x4200
      CACTUS    = 0x4400
      PANE      = 0x4600
      PORTAL    = 0x5000
      WALLFLAT  = 0x4800
      TRAPDOOR  = 0x5200
      TRAPDOOROPEN=0x5400
      FENCE     = 0x6000
      WALLPOST  = 0x6200
      WALL      = 0x6400
      WALLU     = 0x6600 //wall withe exteion under another wall
      FENCQ     = 0x6800 //fence (one extension)
      BUTTON    = 0x7000
      CHAIN     = 0x7200
      POT       = 0x8000
      POTCROSS  = 0x8200
      CARPET    = 0x8400
      FLIP      = 0x400 // 11th bit
      NORTH     = 0 // 12th and 13th bits for the 4 directions
      SOUTH     = 0x800
      EAST      = 0x1000
      WEST      = 0x1800
      ROTATION  = 0x1800 // Mask for the direction bits
    }
    initBlockData()
    genIcons()
  }
	let blockMode   = CUBE
	let tex
	let textureAtlas
	let textureMap
	let dirtBuffer, netherBuffer
	let dirtTexture, netherTexture
	let textureCoords
	let texCoordsBuffers
	let mainbg, dirtbg, netherbg // Background images
	let bigArray = win.bigArray || new Float32Array(600000)
	win.bigArray = bigArray

	// Callback functions for all the screens; will define them further down the page
	let drawScreens = {
		"main menu": () => {},
		"options": () => {},
		"play": () => {},
		"pause": () => {},
		"creation menu": () => {},
		"inventory": () => {},
		"multiplayer menu": () => {},
		"comingsoon menu": () => {},
		"loadsave menu": () => {},
    "marketplace": () => {},
	}
	let html = {
		pause: {
			enter: [window.message],
			exit: [window.savebox, window.saveDirections, window.message]
		},
		"loadsave menu": {
			enter: [window.worlds, window.boxCenterTop, window.quota],
			exit: [window.worlds, window.boxCenterTop, window.quota],
			onenter: () => {
				if(!touchScreen){
				window.boxCenterTop.placeholder = "Enter Save String (Optional)"
				}if(touchScreen){
				window.boxCenterTop.style.display = "none"
				}
				if (navigator && navigator.storage && navigator.storage.estimate) {
					navigator.storage.estimate().then(data => {
						window.quota.innerText = `${data.usage.toLocaleString()} / ${data.quota.toLocaleString()} bytes (${(100 * data.usage / data.quota).toLocaleString(undefined, { maximumSignificantDigits: 2 })}%) of your quota used`
					}).catch(console.error)
				}
				if(!touchScreen){
					window.boxCenterTop.onmousedown = e => {
					let elem = document.getElementsByClassName("selected")
					if (elem && elem[0]) {
						elem[0].classList.remove("selected")
					}
					selectedWorld = 0
					Button.draw()
				}
				}
				
			},
			onexit: () => {
				window.boxCenterTop.onmousedown = null
			}
		},
    "multiplayer menu": {
			enter: [window.servers],
			exit: [window.servers],
		},
		"creation menu": {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
				window.boxCenterTop.style.display = "block"
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = ""
			}
		},
		loading: {
			onenter: () => {
        startLoad()
        constVersion(world.version || version)
      }
		},
    netherLoading: {
			onenter: startLoad
		},
		editworld: {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = ""
			}
		},
    marketplace: {
      enter: [window.marketplace],
      exit: [window.marketplace]
    },
    play: {
      enter: [window.messageHolder, window.onscreenControl_Element],
      exit: [window.messageHolder, window.onscreenControl_Element],
      onexit: () => Messages.clear()
    }
	}

	let screen = "main menu"
	let previousScreen = screen
	function changeScene(newScene) {
		if (screen === "options") {
			saveToDB("settings", settings).catch(e => console.error(e))
		}

		if (html[screen] && html[screen].exit) {
			for (let element of html[screen].exit) {
				element.classList.add("hidden")
			}
		}

		if (html[newScene] && html[newScene].enter) {
			for (let element of html[newScene].enter) {
				element.classList.remove("hidden")
			}
		}

		if (html[newScene] && html[newScene].onenter) {
			html[newScene].onenter()
		}
		if (html[screen] && html[screen].onexit) {
			html[screen].onexit()
		}

		previousScreen = screen
		screen = newScene
		mouseDown = false
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
	}
	let hitBox = {}
	let holding = 0
  let crack = {
    0: "crack1",
    1: "crack2",
    2: "crack3",
    3: "crack4",
    4: "crack4",
    idx: 0, // block will break if idx is 4
    tex: ["crack1","crack1","crack1","crack1","crack1","crack1"],
    shape: null,
    pos: [0,0,0],
    prevPos: [-1,-1,-1],
    soundTimer: 0
  }
  win.crack = crack
  let crackAmount = 0
  {
    //command system
    var copiedBlocks = [];
    var prevPos;
    function fill(x,y,z,x2,y2,z2, blockID){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}
      for(var X=x; x2>=X; X++){
        for(var Y=y; y2>=Y; Y++){
          for(var Z=z; z2>=Z; Z++){
            world.setBlock(X,Y,Z,blockID)
          }
        }
      }
    }
    function copy(x,y,z,x2,y2,z2){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}

      copiedBlocks = [];
      for(var X=x; x2>=X; X++){
        var xRow = [];
        for(var Y=y; y2>=Y; Y++){
          var yRow = []
          for(var Z=z; z2>=Z; Z++){
            yRow.push(world.getBlock(X,Y,Z));
          }
          xRow.push(yRow);
        }
        copiedBlocks.push(xRow);
      }
    }
    function paste(x,y,z){
      for(var X = 0; X<copiedBlocks.length; X++){
        var xRow = copiedBlocks[X];
        for(var Y=0; Y<xRow.length; Y++){
          var yRow = xRow[Y];
          for(var Z=0; Z<yRow.length; Z++){
            var block = yRow[Z];
            world.setBlock(X+x,Y+y,Z+z,block)
          }
        }
      }
    }
    function replaceBlocks(x,y,z,x2,y2,z2, replace, into){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}
      for(var X=x; x2>=X; X++){
        for(var Y=y; y2>=Y; Y++){
          for(var Z=z; z2>=Z; Z++){
            if(world.getBlock(X,Y,Z) === replace){
              world.setBlock(X,Y,Z,into)
            }
          }
        }
      }
    }

    function fromPlayer(){
      prevPos = [p2.x, p2.y, p2.z]
    }
    function fillToPlayer(id){
      //fills at player feet
      fill(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, id)
    }

    function copyToPlayer(){
      copy(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z);
    }
    function pasteAtPlayer(){
      paste(p2.x,p2.y-1,p2.z)
    }

    function hcyl(bottom, height, radius, id) {
        let radsq = radius * radius
        let innerRadsq = (radius - 1.2) * (radius - 1.2)
        height += bottom
        for (let x = -radius; x <= radius; x++) {
            for (let y = bottom; y < height; y++) {
                for (let z = -radius; z <= radius; z++) {
                    let d = x * x + z * z
                    if (d < radsq && d >= innerRadsq) {
                        world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                    }
                }
            }
        }
    }

    function cyl(bottom, height, radius, id) {
        let radsq = radius * radius
        height += bottom
        for (let x = -radius; x <= radius; x++) {
            for (let y = bottom; y < height; y++) {
                for (let z = -radius; z <= radius; z++) {
                    let d = x * x + z * z
                    if (d < radsq) {
                        world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                    }
                }
            }
        }
    }

    function sphereoid(w, h, d, id, X,Y,Z) {
        let w2 = w * w
        let h2 = h * h
        let d2 = d * d
        let w3 = (w - 1.5) * (w - 1.5)
        let h3 = (h - 1.5) * (h - 1.5)
        let d3 = (d - 1.5) * (d - 1.5)

        for (let y = -h; y < h; y++) {
            for (let x = -w; x <= w; x++) {
                for (let z = -d; z <= d; z++) {
                    let n = x * x / w2 + y * y / h2 + z * z / d2
                    let n2 = x * x / w3 + y * y / h3 + z * z / d3
                    if (n < 1 && n2 >= 1) {
                        world.setBlock(X + x, Y + y, Z + z, id)
                    }
                }
            }
        }
    }
    var cmds = [
      {
        name: "fromPlayer",
        info: "Sets position 1 to player"
      },
      {
        name: "fillToPlayer",
        args: ["block_name"],
        info: "Fills from position 1 to player position"
      },
      {
        name: "copyToPlayer",
        info: "Copys blocks from position 1 to player position"
      },
      {
        name: "pasteAtPlayer",
        info: "Pastes copied blocks at the player's position"
      },
      {
        name: "sphereoid",
        args: ["width", "height", "depth", "block_name", "x", "y", "z"]
      },
      {
        name: "replaceToPlayer",
        args: ["replace_what", "with_what"]
      },
      {
        name: "give",
        args: ["block_name", "amount"],
        info: "Gives you the the specified amount of specified blocks"
      },
      {
        name: "ban",
        args: ["username"],
        info: "Bans a player. They cannot rejoin the world. Only bans them until multiplayer turns off"
      }
    ]
    function getCmd(name){
      for(var i=0; i<cmds.length; i++){
        if(cmds[i].name === name){
          return cmds[i]
        }
      }
    }
    
    function runCmd(str){
      str = str.replace("/", '')
      let split = str.split(" ")
      let name = split[0]
      if(name === "?"){
        if(split[1]){
          var cmd = getCmd(split[1])
          if(cmd){
            var str = "<b>/"+split[1]+"</b><br>"
            str += "Syntax: /"+cmd.name+" "
            if(cmd.args) str += cmd.args.join(" ")
            str += "<br>"
            if(cmd.info) str += "Description: "+cmd.info
            Messages.add(str)
          }else Messages.add("There is no information for /"+split[1])
        }else{
          var str = "List of commands:<br>"
          str += "Use <span style='color:lime;'>/? command_name</span> to get information about a command<br>"
          cmds.forEach(r => {
            str += "<span style='color:lightblue;'>/"+r.name+"</span> "
            if(r.args) str += r.args.join(" ")
            str += "<br>"
          })
          Messages.add(str)
        }
      }else if(name === "fromPlayer"){
        fromPlayer()
      }else if(name === "fillToPlayer"){ //args: <block name>
        let id = blockIds[split[1]]
        if(!split[1]) id = 0
        fillToPlayer(id)
      }else if(name === "copyToPlayer"){
        copyToPlayer()
      }else if(name === "pasteAtPlayer"){
        pasteAtPlayer()
      }else if(name === "sphereoid"){ //args: width, height, depth, <block name>, x,y,z
        let id = blockIds[split[4]]
        if(!split[4]) id = 0
        let x = split[5] ? parseInt(split[5]) : p2.x,
            y = split[6] ? parseInt(split[6]) : p2.y,
            z = split[7] ? parseInt(split[7]) : p2.z
        sphereoid(split[1], split[2], split[3], id, x,y,z)
      }else if(name === "replaceToPlayer"){
        let replace = blockIds[split[1]]
        if(!split[1]) replace = 0
        let into = blockIds[split[2]]
        if(!split[2]) into = 0
        replaceBlocks(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, replace, into)
      }else if(name === "give"){
        let id = blockIds[split[1]]
        if(id){
          if(split[2] && split[2] > 1){
            for(var i=0; i<split[2]; i++){
              newInvItem(id)
            }
          }else newInvItem(id)
        }
      }else if(name === "ban"){
        if(win.ban){
          ban(split[1])
        }else{
          Messages.add("Error: can't ban.")
        }
      }else{
        Messages.add("Error: no such command called "+name)
      }
    }
    win.runCmd = runCmd
  }
  let Messages = {
    array: [],
    update:function(){
      if(this.array.length === 0){
        messages.innerHTML = ""
      }else messages.innerHTML = this.array.join("<br>")
    },
    clear: function(){this.array = [];this.update()},
    add: function(msg){
      this.array.push(msg)
      if(this.array.length > 5){
        this.array.shift()
      }
      this.update()
    },
    write: function(msg, from){
      this.add((from || username)+": "+msg)
      if(!from && multiplayer){
        send({type:"message", data:msg, username:username})
      }
    },
    showInput(){
      messageInput.classList.remove("hidden")
      messageInput.focus()
      messageInput.onkeypress = (e) => {
        if(e.key !== "Enter") return
        if(messageInput.value[0] === "/"){
          if(survival){
            Messages.add("<span style='color:red;'>Commands unavailable</span>")
          }else runCmd(messageInput.value)
        }else{
          Messages.write(messageInput.value)
        }
        messageInput.classList.add("hidden")
        messageInput.value = ""
        canvas.focus()
      }
    }
  }
  window.Messages = Messages
	let Key = {}
	let modelView = win.modelView || new Float32Array(16)
	win.modelView = modelView
	let glCache
	let worlds, selectedWorld = 0
	let freezeFrame = 0
	let p
	let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector()
	let move = {
		x: 0,
		y: 0,
		z: 0,
		ang: Math.sqrt(0.5),
	}
	let p2 = {
		x: 0,
		y: 0,
		z: 0,
	}
  let p3 = { //precise positions for multiplayer
    x: 0,
    y: 0,
    z: 0,
    survival: false,
    username: ""
  }
	let place
  let liquid = false
  let harmEffect = 0
  let healTime = 5000 // miliseconds between each heal
  let healEffect = 0 // health bar outline flash white
  let lastHeal = 0
  let lastBlockHarm = 0
  let witherEffect = 0
  let witherDamage = 0
  let witherTime = 0
  let portalEffect = 0
  win.lastStepSound = 0
	let inventory = {
		hotbar: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
		main: [],
		hotbarSlot: 0,
		size: 40 * min(width, height) / 600,
		holding: 0,
    crafting: [0,0,0,0,0,0,0,0,0],
    craftingStr: "",
    craftingRes: 0, //block id
	}
  inventory.craftingStr = inventory.crafting.join(",")
  win.inventory = inventory
	//}
  for(var i=0; i<9; i++){
    inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
  }
  for(var i=0; i<9; i++){
    inventory.crafting[i] = {id:inventory.crafting[i],amount:64}
  }
  function setHotbar(arr){
    inventory.hotbar = arr
    for(var i=0; i<9; i++){
      inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
    }
  }

	function play() {
		canvas.onblur()
		p.lastBreak = Date.now()
		updateHUD = true
		use3d()
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		getPointer()
		fill(255, 255, 255)
		textSize(10)
		changeScene("play")
	}

	let gl
	let glExtensions
	function getPointer() {
		if (canvas.requestPointerLock) {
			canvas.requestPointerLock()
		}
	}
	function releasePointer() {
		if (doc.exitPointerLock) {
			doc.exitPointerLock()
		}
	}

	let Block = {
		top: 0x4,
		bottom: 0x8,
		north: 0x20,
		south: 0x10,
		east: 0x2,
		west: 0x1,
	}
	let Sides = {
		top: 0,
		bottom: 1,
		north: 2,
		south: 3,
		east: 4,
		west: 5,
	}

	// GLSL Shader code (written in script tags at the top of the file)
	let vertexShaderSrc3D = document.getElementById("blockVertexShader").text
	let fragmentShaderSrc3D = document.getElementById("blockFragmentShader").text
	let vertexShaderSrc2D = document.getElementById("2dVertexShader").text
	let fragmentShaderSrc2D = document.getElementById("2dFragmentShader").text
	let vertexShaderSrcEntity = document.getElementById("entityVertexShader").text
	let fragmentShaderSrcEntity = document.getElementById("entityFragmentShader").text

	function createProgramObject(curContext, vetexShaderSource, fragmentShaderSource) {
		let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER)
		curContext.shaderSource(vertexShaderObject, vetexShaderSource)
		curContext.compileShader(vertexShaderObject)
		if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(vertexShaderObject)
		}

		let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER)
		curContext.shaderSource(fragmentShaderObject, fragmentShaderSource)
		curContext.compileShader(fragmentShaderObject)
		if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(fragmentShaderObject)
		}

		let programObject = curContext.createProgram()
		curContext.attachShader(programObject, vertexShaderObject)
		curContext.attachShader(programObject, fragmentShaderObject)
		curContext.linkProgram(programObject)
		if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
			throw "Error linking shaders."
		}

		return programObject
	}

	let program3D, program2D, programEntity

	function objectify(x, y, z, width, height, textureX, textureY) {
		return {
			x: x,
			y: y,
			z: z,
			w: width,
			h: height,
			tx: textureX,
			ty: textureY
		}
	}
	let shapes = {
		/*
			[
				[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
				[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
				[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
				[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
				[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
				[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
			]
			*/
		cube: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
				[objectify(16, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
		slab: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
				[objectify(16, 8, 16, 16, 8, 0, 0)], //north
				[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
				[objectify(16, 8,  0, 16, 8, 0, 0)], //east
				[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 1,
				south: 1,
				east: 1,
				west: 1
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
			flip: true,
			rotate: false
		},
		stair: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
				[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
				[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 3,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 10,
			varients: [],
			flip: true,
			rotate: true
		},
    cross: {
			verts: [
				[objectify(8, 0, 8, 1, 1, 0, 0)], //bottom
				[objectify(8, 16, 8, 1, 1, 0, 0)], //top
				[objectify(16, 16, 8, 16, 16, 0, 0)], //north
				[objectify(0, 16, 8, 16, 16, 0, 0)], //south
				[objectify(8, 16, 0, 16, 16, 0, 0)], //east
				[objectify(8, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    tallCross: {
      verts: [
				[objectify( 0,  0,  0, 0, 0, 0, 0)], //bottom
				[objectify( 0, 16, 16, 0, 0, 0, 0), objectify( 0, 32, 16, 0, 0, -16, 0)], //top
				[objectify(16, 16, 8, 16, 16, 0, 0), objectify(16, 32, 8, 16, 16, -16, 0)], //north
				[objectify( 0, 16,  8, 16, 16, 0, 0), objectify( 0, 32,  8, 16, 16, -16, 0)], //south
				[objectify(8, 16,  0, 16, 16, 0, 0), objectify(8, 32,  0, 16, 16, -16, 0)], //east
				[objectify( 8, 16, 16, 16, 16, 0, 0), objectify( 8, 32, 16, 16, 16, -16, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
    door: {
			verts: [
				[objectify( 0,  0,  0, 16, 3, 0, 0)], //bottom
				[objectify( 0, 16, 3, 16, 3, 0, 0),objectify( 0, 32, 3, 16, 3, -16, 0)], //top
				[objectify(16, 16, 3, 16, 16, 0, 0),objectify(16, 32, 3, 16, 16, -16, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0),objectify( 0, 32,  0, 16, 16, -16, 0)], //south
				[objectify(16, 16,  0, 3, 16, 0, 0),objectify(16, 32,  0, 3, 16, -16, 0)], //east
				[objectify( 0, 16, 3, 3, 16, 0, 0),objectify( 0, 32, 3, 3, 16, -16, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    torch: {
			verts: [
				[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
				[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
				[objectify(9, 10, 9, 2, 10, 7, 6)], //north
				[objectify( 7, 10,  7, 2, 10, 7, 6)], //south
				[objectify(9, 10,  7, 2, 10, 7, 6)], //east
				[objectify( 7, 10, 9, 2, 10, 7, 6)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    lantern: {
			verts: [
				[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
				[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
				[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10)], //north
				[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10)], //south
				[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2)], //east
				[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    lanternHang: {
			verts: [
				[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
				[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
				[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10),objectify(9.5, 16, 8, 3, 3, 11, 2)], //north
				[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10),objectify(6.5, 16, 8, 3, 3, 11, 2)], //south
				[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2),objectify(8, 14, 6.5, 3, 4, 11, 1)], //east
				[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2),objectify(8, 14, 9.5, 3, 4, 11, 1)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    beacon: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 16, -96),objectify( 2, 0.001, 2, 12, 12, -32, 0)], //bottom
				[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify( 2, 3, 14, 12, 12, -16, 3)], //top
				[objectify(13, 13, 13, 10, 10, 3, 3),objectify( 16, 16,  16, 16, 16, -32, 0),objectify(14, 3, 14, 12, 3,  -16, 3)], //north
				[objectify( 3, 13,  3, 10, 10, 3, 3),objectify( 0,  16,  0,  16, 16, -32, 0),objectify(2,  3, 2,  12, 3,  -16, 3)], //south
				[objectify(13, 13,  3, 10, 10, 3, 3),objectify( 16, 16,  0,  16, 16, -32, 0),objectify(14, 3, 2,  12, 3,  -16, 3)], //east
				[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify(2,  3, 14, 12, 3,  -16, 3)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    cactus: {
			verts: [
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 15, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  1, 16, 16, 0, 0)], //south
				[objectify(15, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 1, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    pane: {
			verts: [
				[objectify( 0,  0,  7, 16, 2, 0, 7)], //bottom
				[objectify( 0, 16, 9, 16, 2, 0, 7)], //top
				[objectify(16, 16, 9, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
				[objectify(16, 16, 7, 2, 16, 7, 0)], //east
				[objectify(0, 16, 9, 2, 16, 7, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    portal: {
			verts: [
				[objectify(0, 0, 7, 16, 2, 0, 0)],
				[objectify(0, 16, 9, 16, 2, 0, 0)],
				[objectify(16, 16, 9, 16, 16, 0, 0)],
				[objectify(0, 16, 7, 16, 16, 0, 0)],
				[objectify(16, 16, 7, 2, 16, 0, 0)],
				[objectify(0, 16, 9, 2, 16, 0, 0)]
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    trapdoor: {
			verts: [
				[objectify(0, 0, 0, 16, 16, 0, 0)], //bottom
				[objectify(0, 3, 16, 16, 16, 0, 0)], //top
				[objectify(16, 3, 16, 16, 3, 0, 0)], //north
				[objectify(0, 3, 0, 16, 3, 0, 0)], //south
				[objectify(16, 3, 0, 16, 3, 0, 0)], //east
				[objectify(0, 3, 16, 16, 3, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true,
			flip: true
		},
		trapdoorOpen: {
			verts: [
				[objectify(0, 0, 13, 16, 3, 0, 0)], //bottom
				[objectify(0, 16, 16, 16, 3, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify(0, 16, 13, 16, 16, 0, 0)], //south
				[objectify(16, 16, 13, 3, 16, 0, 0)], //east
				[objectify(0, 16, 16, 3, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    wallFlat: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
				[objectify(0, 16, 16, 0, 0, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify(0, 16,  15, 16, 16, 0, 0)], //south
				[objectify(0, 0,  0, 0, 0, 0, 0)], //east
				[objectify(0, 0, 16, 0, 0, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    fence: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(6, 0, 6, 4, 4, 0, 1)], //bottom
				[objectify(6, 16, 10, 4, 4, 0, 1)], //top
				[objectify(10, 16, 10, 4, 16, 6, 0)], //north
				[objectify(6, 16, 6, 4, 16, 6, 0)], //south
				[objectify(10, 16, 6, 4, 16, 6, 0)], //east
				[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
		wallpost: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
		wall: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 16, 16, 6, 4, 5, 10)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 16, 16, 6, 16, 5, 0)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 16, 12, 4, 16, 12, 0)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 16, 16, 4, 16, 12, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
		wallu: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 13, 16, 6, 4, 5, 10)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 13, 16, 6, 13, 5, 3)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 13, 12, 4, 13, 12, 3)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 13, 16, 4, 13, 12, 3)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    fencq: {
			verts: [
				[objectify(6, 0, 6, 4, 4, 0, 1),objectify(10, 12, 7, 6, 2, 0, 2),objectify(10, 6, 7, 6, 2, 0, 2)], //bottom
				[objectify(6, 16, 10, 4, 4, 0, 1),objectify(10, 15, 9, 6, 2, 0, 2),objectify(10, 9, 9, 6, 2, 0, 2)], //top
				[objectify(10, 16, 10, 4, 16, 6, 0),objectify(16, 15, 9, 6, 3, 6, 0),objectify(16, 9, 9, 6, 3, 6, 0)], //north
				[objectify(6, 16, 6, 4, 16, 6, 0),objectify(10, 15, 7, 6, 3, 6, 0),objectify(10, 9, 7, 6, 3, 6, 0)], //south
				[objectify(10, 16, 6, 4, 16, 6, 0)], //east
				[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
		button: {
			verts: [
				[objectify(5, 6, 14, 6, 2, 5, 6)], //bottom
				[objectify(5, 10, 16, 6, 2, 5, 6)], //top
				[objectify(11, 10, 16, 6, 4, 5, 6)], //north
				[objectify(5, 10, 14, 6, 4, 5, 6)], //south
				[objectify(11, 10, 14, 2, 4, 5, 6)], //east
				[objectify(5, 10, 16, 2, 4, 5, 6)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
			flip: true,
			rotate: true
		},
    chain: {
			verts: [
				[objectify(8, 0, 8, 0.5, 0.5, 0, 0)], //bottom
				[objectify(8, 16, 8, 0.5, 0.5, 0, 0)], //top
				[objectify(9.5, 16, 8, 3, 16, 3, 0)], //north
				[objectify(6.5, 16, 8, 3, 16, 3, 0)], //south
				[objectify(8, 16, 6.5, 3, 16, 0, 0)], //east
				[objectify(8, 16, 9.5, 3, 16, 0, 0)] //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    pot: {
			verts: [
				[objectify(5, 0, 5, 6, 6, 5, 10)], //bottom
				[objectify(5, 6, 11, 6, 6, 5, 5), objectify(6, 4, 10, 4, 4, -16, 0)], //top
				[objectify(11, 6, 11, 6, 6, 5, 10), objectify(11, 6, 6, 6, 6, 5, 10)], //north
				[objectify(5, 6, 5, 6, 6, 5, 10), objectify(5, 6, 10, 6, 6, 5, 10)], //south
				[objectify(11, 6, 5, 6, 6, 5, 10), objectify(6, 6, 5, 6, 6, 5, 10)], //east
				[objectify(5, 6, 11, 6, 6, 5, 10), objectify(10, 6, 11, 6, 6, 5, 10)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    potCross: {
			verts: [
				[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
				[objectify(0, 16, 16, 0, 0, 0, 0)], //top
				[objectify(16, 4, 8, 16, 16, 0, 0)], //north
				[objectify(0, 4, 8, 16, 16, 0, 0)], //south
				[objectify(8, 4, 0, 16, 16, 0, 0)], //east
				[objectify(8, 4, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    carpet: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 1, 16, 16, 16, 0, 0)], //top
				[objectify(16, 1, 16, 16, 1, 0, 0)], //north
				[objectify( 0, 1,  0, 16, 1, 0, 0)], //south
				[objectify(16, 1,  0, 16, 1, 0, 0)], //east
				[objectify( 0, 1, 16, 16, 1, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 1,
				south: 1,
				east: 1,
				west: 1
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: []
		},
    bed: {
			verts: [
				[objectify( 0, 3,  0, 16, 32, 0, 0),
				objectify(0, 0, 0, 3,3,0,0),
				objectify(13, 0, 29, 3,3,0,0),
				objectify(0, 0, 29, 3,3,0,0),
				objectify(13, 0, 0, 3,3,0,0)], //bottom
				[objectify( 0, 9, 32, 16, 32, 0, 0)], //top
				[objectify(16, 9, 32, 16, 6, 0, 0),
				objectify(3, 3, 3, 3,3,0,0),
				objectify(16, 3, 32, 3,3,0,0),
				objectify(3, 3, 32, 3,3,0,0),
				objectify(16, 3, 3, 3,3,0,0)], //north
				[objectify( 0, 9,  0, 16, 6, 0, 0),
				objectify(0, 3, 0, 3,3,0,0),
				objectify(13, 3, 29, 3,3,0,0),
				objectify(0, 3, 29, 3,3,0,0),
				objectify(13, 3, 0, 3,3,0,0)], //south
				[objectify( 0, 9,  0, 32, 6, 0, 0),
				objectify(0, 3, 0, 3,3,0,0),
				objectify(13, 3, 29, 3,3,0,0),
				objectify(0, 3, 29, 3,3,0,0),
				objectify(13, 3, 0, 3,3,0,0)], //east
				[objectify( 0, 9, 32, 32, 6, 0, 0),
				objectify(0, 3, 3, 3,3,0,0),
				objectify(13, 3, 32, 3,3,0,0),
				objectify(0, 3, 32, 3,3,0,0),
				objectify(13, 3, 3, 3,3,0,0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: []
		},
    
    cow: {
      verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16,  8,  4,  8,  8,  0,  0)], //bottom
				[objectify( 0, 12, 16, 16, 16, 0, 0), objectify(16, 16, 12,  8,  8,  0,  0)], //top
				[objectify(16, 12, 16, 16, 12, 0, 4), objectify(24, 16, 12,  8,  8, 16,  0)], //north
				[objectify( 0, 12,  0, 16, 12, 0, 4), objectify(16, 16,  4,  8,  8, 16,  0)], //south
				[objectify(16, 12,  0, 16, 12, 0, 4), objectify(24, 16,  4,  8,  8, 16,  0)], //east
				[objectify( 0, 12, 16, 16, 12, 0, 4), objectify(16, 16, 12,  8,  8, 16,  0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 12,
    },
	}
	win.shapes = shapes

	function compareArr(arr, out) {
		let minX = 1000
		let maxX = -1000
		let minY = 1000
		let maxY = -1000
		let minZ = 1000
		let maxZ = -1000
		let num = 0
		for (let i = 0; i < arr.length; i += 3) {
			num = arr[i]
			minX = minX > num ? num : minX
			maxX = maxX < num ? num : maxX
			num = arr[i + 1]
			minY = minY > num ? num : minY
			maxY = maxY < num ? num : maxY
			num = arr[i + 2]
			minZ = minZ > num ? num : minZ
			maxZ = maxZ < num ? num : maxZ
		}
		out[0] = minX
		out[1] = minY
		out[2] = minZ
		out[3] = maxX
		out[4] = maxY
		out[5] = maxZ
		return out
	}
  function arrayValues(a1,a2){
    if(a1.length !== a2.length) return false
    let minLen = a1.length
    for(var i=0; i<minLen; i++){
      if(a1[i] !== a2[i]){
        return false
      }
    }
    return true
  }

	function initShapes() {
		function mapCoords(rect, face) {
			let x = rect.x
			let y = rect.y
			let z = rect.z
			let w = rect.w
			let h = rect.h
			let tx = rect.tx
			let ty = rect.ty
			let tex = [tx+w,ty, tx,ty, tx,ty+h, tx+w,ty+h]
			let pos = null
			switch(face) {
				case 0: // Bottom
					pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
					break
				case 1: // Top
					pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
					break
				case 2: // North
					pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
					break
				case 3: // South
					pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
					break
				case 4: // East
					pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
					break
				case 5: // West
					pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
					break
			}
			pos = pos.map(c => c / 16 - 0.5)
			let minmax = compareArr(pos, [])
			pos.max = minmax.splice(3, 3)
			pos.min = minmax
			tex = tex.map(c => c / 16 / 16)
			
			return {
				pos: pos,
				tex: tex
			}
		}
		
		// 90 degree clockwise rotation; returns a new shape object
		function rotate(shape) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = face[k + 1]
						c[k + 2] = -face[k]
					}
					
					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
					if (i === 0) {
						// Bottom
						c.push(...c.splice(0, 3))
						tex[i][j].push(...tex[i][j].splice(0, 2))
					}
					if (i === 1) {
						// Top
						c.unshift(...c.splice(-3, 3))
						tex[i][j].unshift(...tex[i][j].splice(-2, 2))
					}

					let minmax = compareArr(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax
				}
			}
			let temp = tex[2] // North
			tex[2] = tex[5] // North = West
			tex[5] = tex[3] // West = South
			tex[3] = tex[4] // South = East
			tex[4] = temp // East = North

			temp = pos[2] // North
			pos[2] = pos[5] // North = West
			pos[5] = pos[3] // West = South
			pos[3] = pos[4] // South = East
			pos[4] = temp // East = North

			let cull2 = {
				top: cull.top,
				bottom: cull.bottom,
				north: cull.west,
				west: cull.south,
				south: cull.east,
				east: cull.north
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: true,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients
			}
		}

		// Reflect over the y plane; returns a new shape object
		function flip(shape) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j].slice().reverse()
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = -face[k + 1]
						c[k + 2] = face[k]
					}
					let minmax = compareArr(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax

					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
				}
			}
			let temp = pos[0] // Bottom
			pos[0] = pos[1] // Bottom = Top
			pos[1] = temp // Top = Bottom

			temp = tex[0] // Bottom
			tex[0] = tex[1] // Bottom = Top
			tex[1] = temp // Top = Bottom

			let cull2 = {
				top: cull.bottom,
				bottom: cull.top,
				north: (cull.north & 1) << 1 | (cull.north & 2) >> 1,
				west: (cull.west & 1) << 1 | (cull.west & 2) >> 1,
				south: (cull.south & 1) << 1 | (cull.south & 2) >> 1,
				east: (cull.east & 1) << 1 | (cull.east & 2) >> 1
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: shape.rotate,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients
			}
		}

		for (let shape in shapes) {
			let obj = shapes[shape]
			let verts = obj.verts
			
			// Populate the vertex coordinates
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				let texArr = []
				obj.texVerts.push(texArr)
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let mapped = mapCoords(face, i)
					side[j] = mapped.pos
					texArr.push(mapped.tex)
				}
			}

			if (obj.rotate) {
				let v = obj.varients
				let east = rotate(obj)
				let south = rotate(east)
				let west = rotate(south)
				v[0] = obj
				v[2] = south
				v[4] = east
				v[6] = west
			}
			if (obj.flip) {
				let v = obj.varients
				v[1] = flip(obj)
				if (obj.rotate) {
					v[3] = flip(v[2])
					v[5] = flip(v[4])
					v[7] = flip(v[6])
				}
			}

			obj.buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts.flat(2)), gl.STATIC_DRAW)
		}

    win.initBlockData = function(){
		for (let i = 0; i < BLOCK_COUNT; i++) {
			let baseBlock = blockData[i]
			let slabBlock = Object.create(baseBlock)
			let stairBlock = Object.create(baseBlock)
      let crossBlock = Object.create(baseBlock)
      let tallcrossBlock = Object.create(baseBlock)
      let doorBlock = Object.create(baseBlock)
      let torchBlock = Object.create(baseBlock)
      let lanternBlock = Object.create(baseBlock)
      let lanternHangBlock = Object.create(baseBlock)
      let beaconBlock = Object.create(baseBlock)
      let cactusBlock = Object.create(baseBlock)
      let paneBlock = Object.create(baseBlock)
      let portalBlock = Object.create(baseBlock)
      let trapdoorBlock = Object.create(baseBlock)
      let openTrapdoor = Object.create(baseBlock)
      let wallFlatBlock = Object.create(baseBlock)
      let fenceBlock = Object.create(baseBlock)
			let wallPostBlock = Object.create(baseBlock)
			let wallBlock = Object.create(baseBlock)
			let walluBlock = Object.create(baseBlock)
      let fencqBlock = Object.create(baseBlock)
			let buttonBlock = Object.create(baseBlock)
      let chainBlock = Object.create(baseBlock)
      let potBlock = Object.create(baseBlock)
      let potCrossBlock = Object.create(baseBlock)
      let carpetBlock = Object.create(baseBlock)
      baseBlock.shape = shapes.cube
			slabBlock.shape = shapes.slab
      slabBlock.transparent = true
			stairBlock.shape = shapes.stair
      stairBlock.transparent = true
      crossBlock.shape = shapes.cross
      tallcrossBlock.shape = shapes.tallCross
      doorBlock.shape = shapes.door
      doorBlock.solid = false
      torchBlock.shape = shapes.torch
      lanternBlock.shape = shapes.lantern
      lanternHangBlock.shape = shapes.lanternHang
      beaconBlock.shape = shapes.beacon
      cactusBlock.shape = shapes.cactus
      paneBlock.shape = shapes.pane
      portalBlock.shape = shapes.portal
      wallFlatBlock.shape = shapes.wallFlat
      trapdoorBlock.shape = shapes.trapdoor
      openTrapdoor.shape = shapes.trapdoorOpen
      fenceBlock.shape = shapes.fence
      wallPostBlock.shape = shapes.wallpost
			wallBlock.shape = shapes.wall
			walluBlock.shape = shapes.wallu
      fencqBlock.shape = shapes.fencq
			buttonBlock.shape = shapes.button
      chainBlock.shape = shapes.chain
      potBlock.shape = shapes.pot
      potCrossBlock.shape = shapes.potCross
      carpetBlock.shape = shapes.carpet
      carpetBlock.shadow = false
      carpetBlock.transparent = true
      if(blockData[i].bed) baseBlock.shape = shapes.bed
			blockData[i | SLAB] = slabBlock
			blockData[i | STAIR] = stairBlock
      blockData[i | CROSS] = crossBlock
      blockData[i | TALLCROSS] = tallcrossBlock
      blockData[i | DOOR] = doorBlock
      blockData[i | TORCH] = torchBlock
      blockData[i | LANTERN] = lanternBlock
      blockData[i | LANTERNHANG] = lanternHangBlock
      if(blockData[i].beacon) blockData[i | BEACON] = beaconBlock
      if(blockData[i].cactus) blockData[i | CACTUS] = cactusBlock
      blockData[i | PANE] = paneBlock
      blockData[i | PORTAL] = portalBlock
      blockData[i | WALLFLAT] = wallFlatBlock
      blockData[i | TRAPDOOR] = trapdoorBlock
      blockData[i | TRAPDOOROPEN] = openTrapdoor
      blockData[i | FENCE] = fenceBlock
			blockData[i | WALLPOST] = wallPostBlock
			blockData[i | WALL] = wallBlock
			blockData[i | WALLU] = walluBlock
      blockData[i | FENCQ] = fencqBlock
			if(blockData[i].button) blockData[i | BUTTON] = buttonBlock
      if(blockData[i].chain) blockData[i | CHAIN] = chainBlock
      if(blockData[i].pot) blockData[i | POT] = potBlock
      blockData[i | POTCROSS] = potCrossBlock
      if(blockData[i].carpet) blockData[i | CARPET] = carpetBlock
			let v = slabBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | SLAB | j << 10] = block
				}
			}
			v = stairBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | STAIR | j << 10] = block
				}
			}
      v = doorBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | DOOR | j << 10] = block
				}
			}
      v = paneBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | PANE | j << 10] = block
				}
			}
      v = portalBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | PORTAL | j << 10] = block
				}
			}
      v = wallFlatBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | WALLFLAT | j << 10] = block
				}
			}
      v = trapdoorBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | TRAPDOOR | j << 10] = block
				}
			}
      v = openTrapdoor.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | TRAPDOOROPEN | j << 10] = block
				}
			}
      v = fenceBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | FENCE | j << 10] = block
				}
			}
			v = wallPostBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | WALLPOST | j << 10] = block
				}
			}
			v = wallBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | WALL | j << 10] = block
				}
			}
			v = walluBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | WALLU | j << 10] = block
				}
			}
      v = fencqBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | FENCQ | j << 10] = block
				}
			}
			v = buttonBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j] && blockData[i].button) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | BUTTON | j << 10] = block
				}
			}
		}
    }
    constVersion(version)
	}
    
	let indexOrder;
	(function() {
		let arr = []
		for (let i = 0; i < 100000; i++) {
			arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4)
		}
		indexOrder = new Uint32Array(arr)
	})()

	let hexagonVerts
	let slabIconVerts
	let stairIconVerts
  let fenceIconVerts
	let wallPostIconVerts
	let walluIconVerts
	let wallIconVerts
  let fencqIconVerts
	let buttonIconVerts
	let blockIcons
	{
		let side = Math.sqrt(3) / 2
		let s = side
		let q = s / 2
		hexagonVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])

		slabIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])

		stairIconVerts = [
			-s,0.5,0,0,1,         0,1,1,0,1,         q,0.75,1,0.5,1,    -q,0.25,0,0.5,1,    // top of the top step
			-q,-0.25,0,0,1,       q,0.25,1,0,1,      s,0,1,0.5,1,        0,-0.5,0,0.5,1,    // top of the bottom step
			-q,0.25,0,0,0.6,      q,0.75,1,0,0.6,    q,0.25,1,0.5,0.6,  -q,-0.25,0,0.5,0.6, // front of the top step
			0,-0.5,0,0,0.6,       s,0,1,0,0.6,       s,-0.5,1,0.5,0.6,   0,-1,0,0.5,0.6,    // front of the bottom step
			-s,0.5,0,0,0.8,      -q,0.25,0.5,0,0.8, -q,-0.75,0.5,1,0.8, -s,-0.5,0,1,0.8,    // side of the top step
			-q,-0.25,0.5,0.5,0.8, 0,-0.5,1,0.5,0.8,  0,-1,1,1,0.8,      -q,-0.75,0.5,1,0.8, // side of the bottom step
		]
    fenceIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		
		wallPostIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		
		wallIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		walluIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
    fencqIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		buttonIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])
	}
	function genIcons() {
		blockIcons = [null]
		blockIcons.lengths = []
		let texOrder = [ 1, 2, 3 ]
		let shadows = [ 1, 0.4, 0.7 ]
		let scale = 0.16 / height * inventory.size
		for (let i = 1; i < BLOCK_COUNT; i++) {
			let data = []
			let block = blockData[i]
      if(block.icon){
        block = blockData[blockIds[block.icon]]
      }
			for (let j = 11; j >= 0; j--) {
				data.push(-hexagonVerts[j * 3 + 0] * scale)
				data.push(hexagonVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 0) % 8])
				data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 1) % 8])
				data.push(shadows[floor(j / 4)])
			}
			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i] = buffer
			blockIcons.lengths[i] = 6 * 3

			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]

				data.push(-slabIconVerts[j * 3 + 0] * scale)
				data.push(slabIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[floor(j / 4)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | SLAB] = buffer
			blockIcons.lengths[i | SLAB] = 6 * 3

			data = []
			let v = stairIconVerts
			for (let j = 23; j >= 0; j--) {
				let num = floor(j / 8)
				let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
				let tx = tex[0]
				let ty = tex[1]
				data.push(-v[j * 5 + 0] * scale)
				data.push(v[j * 5 + 1] * scale)
				data.push(0.1666666)
				data.push(tx + v[j * 5 + 2] / 16)
				data.push(ty + v[j * 5 + 3] / 16)
				data.push(shadows[num])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | STAIR] = buffer
			blockIcons.lengths[i | STAIR] = 6 * 6
      
      data = []
			for (let j = 11; j >= 0; j--) {
				data.push(-hexagonVerts[j * 3 + 0] * scale)
				data.push(hexagonVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 0) % 8])
				data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 1) % 8])
				data.push(shadows[floor(j / 4)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | CROSS] = buffer
			blockIcons.lengths[i | CROSS] = 6 * 3
      
      data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-fenceIconVerts[j * 3 + 0] * scale)
				data.push(fenceIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | FENCE] = buffer
			blockIcons.lengths[i | FENCE] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-wallPostIconVerts[j * 3 + 0] * scale)
				data.push(wallPostIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALLPOST] = buffer
			blockIcons.lengths[i | WALLPOST] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-wallIconVerts[j * 3 + 0] * scale)
				data.push(wallIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALL] = buffer
			blockIcons.lengths[i | WALL] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-walluIconVerts[j * 3 + 0] * scale)
				data.push(walluIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALLU] = buffer
			blockIcons.lengths[i | WALLU] = 6 * 1
      
      data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-fencqIconVerts[j * 3 + 0] * scale)
				data.push(fencqIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | FENCQ] = buffer
			blockIcons.lengths[i | FENCQ] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-buttonIconVerts[j * 3 + 0] * scale)
				data.push(buttonIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | BUTTON] = buffer
			blockIcons.lengths[i | BUTTON] = 6 * 1
		}
	}

	function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getUniformLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		gl.uniformMatrix4fv(vrLocation, transpose, matrix)
	}
	function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getAttribLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		if (vrLocation !== -1) {
			gl.enableVertexAttribArray(vrLocation)
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO)
			gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0)

		}
	}

	//Generate buffers for every block face and store them
	let sideEdgeBuffers
	let indexBuffer

	function cross(v1, v2, result) {
		let x = v1.x,
			y = v1.y,
			z = v1.z,
			x2 = v2.x,
			y2 = v2.y,
			z2 = v2.z
		result.x = y * z2 - y2 * z
		result.y = z * x2 - z2 * x
		result.z = x * y2 - x2 * y
	}

	let matrix = new Float32Array(16); // A temperary matrix that may store random data.
	let projection = new Float32Array(16)
	let defaultModelView = new Float32Array([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
	class Matrix {
		constructor(arr) {
			this.elements = new Float32Array(arr || 16)
		}
		translate(x, y, z) {
			let a = this.elements
			a[3] += a[0] * x + a[1] * y + a[2] * z
			a[7] += a[4] * x + a[5] * y + a[6] * z
			a[11] += a[8] * x + a[9] * y + a[10] * z
			a[15] += a[12] * x + a[13] * y + a[14] * z
		}
		rotX(angle) {
			let elems = this.elements
			let c = cos(angle)
			let s = sin(angle)
			let t = elems[1]
			elems[1] = t * c + elems[2] * s
			elems[2] = t * -s + elems[2] * c
			t = elems[5]
			elems[5] = t * c + elems[6] * s
			elems[6] = t * -s + elems[6] * c
			t = elems[9]
			elems[9] = t * c + elems[10] * s
			elems[10] = t * -s + elems[10] * c
			t = elems[13]
			elems[13] = t * c + elems[14] * s
			elems[14] = t * -s + elems[14] * c
		}
		rotY(angle) {
			let c = cos(angle)
			let s = sin(angle)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[2] * -s
			elems[2] = t * s + elems[2] * c
			t = elems[4]
			elems[4] = t * c + elems[6] * -s
			elems[6] = t * s + elems[6] * c
			t = elems[8]
			elems[8] = t * c + elems[10] * -s
			elems[10] = t * s + elems[10] * c
			t = elems[12]
			elems[12] = t * c + elems[14] * -s
			elems[14] = t * s + elems[14] * c
		}
		scale(x, y, z) {
			let a = this.elements
			a[0] *= x;
			a[1] *= y;
			a[2] *= z;
			a[4] *= x;
			a[5] *= y;
			a[6] *= z;
			a[8] *= x;
			a[9] *= y;
			a[10] *= z;
			a[12] *= x;
			a[13] *= y;
			a[14] *= z;
		}
		identity() {
			let a = this.elements
			a[0] = 1
			a[1] = 0
			a[2] = 0
			a[3] = 0
			a[4] = 0
			a[5] = 1
			a[6] = 0
			a[7] = 0
			a[8] = 0
			a[9] = 0
			a[10] = 1
			a[11] = 0
			a[12] = 0
			a[13] = 0
			a[14] = 0
			a[15] = 1
		}
		// somebody optimize this
		// you just have to expand it
		mult(b) {
			const a = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		// same here
		postMult(a) {
			const b = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		transpose() {
			let matrix = this.elements
			let temp = matrix[4]
			matrix[4] = matrix[1]
			matrix[1] = temp

			temp = matrix[8]
			matrix[8] = matrix[2]
			matrix[2] = temp

			temp = matrix[6]
			matrix[6] = matrix[9]
			matrix[9] = temp

			temp = matrix[3]
			matrix[3] = matrix[12]
			matrix[12] = temp

			temp = matrix[7]
			matrix[7] = matrix[13]
			matrix[13] = temp

			temp = matrix[11]
			matrix[11] = matrix[14]
			matrix[14] = temp
		}
		copyArray(from) {
			let to = this.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}
		copyMatrix(from) {
			let to = this.elements
			from = from.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}
	}

	class Plane {
		constructor(nx, ny, nz) {
			this.set(nx, ny, nz)
		}
		set(nx, ny, nz) {
			// Pre-computed chunk offsets to reduce branching during culling
			this.dx = nx > 0 ? 16 : 0
			this.dy = ny > 0
			this.dz = nz > 0 ? 16 : 0

			// Normal vector for the plane
			this.nx = nx
			this.ny = ny
			this.nz = nz
		}
	}

	let defaultTransformation = new Matrix([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
	class Camera {
		constructor() {
			this.x = 0
			this.y = 0
			this.z = 0
			this.rx = 0; // Pitch
			this.ry = 0; // Yaw
			this.currentFov = 0
			this.defaultFov = settings.fov
			this.targetFov = settings.fov
			this.step = 0
			this.lastStep = 0
			this.projection = new Float32Array(5)
			this.transformation = new Matrix()
			this.direction = { x: 1, y: 0, z: 0 }; // Normalized direction vector
			this.frustum = [] // The 5 planes of the viewing frustum (there's no far plane)
			for (let i = 0; i < 5; i++) {
				this.frustum.push(new Plane(1, 0, 0))
			}
		}
		FOV(fov, time) {
			if (fov === this.currentFov) return

			if (!fov) {
				let now = Date.now()
				fov = this.currentFov + this.step * (now - this.lastStep)
				this.lastStep = now
				if (Math.sign(this.targetFov - this.currentFov) !== Math.sign(this.targetFov - fov)) {
					fov = this.targetFov
				}
			}
			else if (time) {
				this.targetFov = fov
				this.step = (fov - this.currentFov) / time
				this.lastStep = Date.now()
				return
			} else {
				this.targetFov = fov
			}

			const tang = Math.tan(fov * Math.PI / 360)
			const scale = 1 / tang
			const near = 1
			const far = 1000000
			this.currentFov = fov; // Store the state of the projection matrix
			this.nearH = near * tang; // This is needed for frustum culling

			this.projection[0] = scale / width * height
			this.projection[1] = scale
			this.projection[2] = -far / (far - near)
			this.projection[3] = -1
			this.projection[4] = -far * near / (far - near)
		}
		transform() {
			this.transformation.copyMatrix(defaultTransformation)
			this.transformation.rotX(this.rx)
			this.transformation.rotY(this.ry)
			this.transformation.translate(-this.x, -this.y, -this.z)
		}
    resetMatrix() {
      this.transformation.copyMatrix(defaultTransformation)
    }
		getMatrix() {
			let proj = this.projection
			let view = this.transformation.elements
			matrix[0]  = proj[0] * view[0]
			matrix[1]  = proj[1] * view[4]
			matrix[2]  = proj[2] * view[8] + proj[3] * view[12]
			matrix[3]  = proj[4] * view[8]
			matrix[4]  = proj[0] * view[1]
			matrix[5]  = proj[1] * view[5]
			matrix[6]  = proj[2] * view[9] + proj[3] * view[13]
			matrix[7]  = proj[4] * view[9]
			matrix[8]  = proj[0] * view[2]
			matrix[9]  = proj[1] * view[6]
			matrix[10] = proj[2] * view[10] + proj[3] * view[14]
			matrix[11] = proj[4] * view[10]
			matrix[12] = proj[0] * view[3]
			matrix[13] = proj[1] * view[7]
			matrix[14] = proj[2] * view[11] + proj[3] * view[15]
			matrix[15] = proj[4] * view[11]
			return matrix
		}
		setDirection() {
			if (this.targetFov !== this.currentFov) {
				this.FOV()
			}
			this.direction.x = -sin(this.ry) * cos(this.rx)
			this.direction.y = sin(this.rx)
			this.direction.z = cos(this.ry) * cos(this.rx)
			this.computeFrustum()
		}
		computeFrustum() {
			let X = vec1
			let dir = this.direction
			X.x = dir.z
			X.y = 0
			X.z = -dir.x
			X.normalize()

			let Y = vec2
			Y.set(dir)
			Y.mult(-1)
			cross(Y, X, Y)

			//Near plane
			this.frustum[0].set(dir.x, dir.y, dir.z)

			let aux = vec3
			aux.set(Y)
			aux.mult(this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(aux, X, aux)
			this.frustum[1].set(aux.x, aux.y, aux.z)

			aux.set(Y)
			aux.mult(-this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(X, aux, aux)
			this.frustum[2].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(-this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(aux, Y, aux)
			this.frustum[3].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(Y, aux, aux)
			this.frustum[4].set(aux.x, aux.y, aux.z)
		}
		canSee(x, y, z, maxY) {
			x -= 0.5
			y -= 0.5
			z -= 0.5
			maxY += 0.5
			let px = 0, py = 0, pz = 0, plane = null
			let cx = p.x, cy = p.y, cz = p.z
			for (let i = 0; i < 5; i++) {
				plane = this.frustum[i]
				px = x + plane.dx
				py = plane.dy ? maxY : y
				pz = z + plane.dz
				if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
					return false
				}
			}
			return true
		}
	}

	function trans(matrix, x, y, z) {
		let a = matrix
		a[3] += a[0] * x + a[1] * y + a[2] * z
		a[7] += a[4] * x + a[5] * y + a[6] * z
		a[11] += a[8] * x + a[9] * y + a[10] * z
		a[15] += a[12] * x + a[13] * y + a[14] * z
	}
	function rotX(matrix, angle) {
		// This function is basically multiplying 2 4x4 matrices together,
		// but 1 of them has a bunch of 0's and 1's in it,
		// so I removed all terms that multiplied by 0, and just left off the 1's.
		// mat2 = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
		let elems = matrix
		let c = cos(angle)
		let s = sin(angle)
		let t = elems[1]
		elems[1] = t * c + elems[2] * s
		elems[2] = t * -s + elems[2] * c
		t = elems[5]
		elems[5] = t * c + elems[6] * s
		elems[6] = t * -s + elems[6] * c
		t = elems[9]
		elems[9] = t * c + elems[10] * s
		elems[10] = t * -s + elems[10] * c
		t = elems[13]
		elems[13] = t * c + elems[14] * s
		elems[14] = t * -s + elems[14] * c
	}
	function rotY(matrix, angle) {
	//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
		let c = cos(angle)
		let s = sin(angle)
		let elems = matrix
		let t = elems[0]
		elems[0] = t * c + elems[2] * -s
		elems[2] = t * s + elems[2] * c
		t = elems[4]
		elems[4] = t * c + elems[6] * -s
		elems[6] = t * s + elems[6] * c
		t = elems[8]
		elems[8] = t * c + elems[10] * -s
		elems[10] = t * s + elems[10] * c
		t = elems[12]
		elems[12] = t * c + elems[14] * -s
		elems[14] = t * s + elems[14] * c
	}
	function transpose(matrix) {
		let temp = matrix[4]
		matrix[4] = matrix[1]
		matrix[1] = temp

		temp = matrix[8]
		matrix[8] = matrix[2]
		matrix[2] = temp

		temp = matrix[6]
		matrix[6] = matrix[9]
		matrix[9] = temp

		temp = matrix[3]
		matrix[3] = matrix[12]
		matrix[12] = temp

		temp = matrix[7]
		matrix[7] = matrix[13]
		matrix[13] = temp

		temp = matrix[11]
		matrix[11] = matrix[14]
		matrix[14] = temp
	}
	function matMult() {
	//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
		let proj = projection
		let view = modelView
		matrix[0] = proj[0] * view[0]
		matrix[1] = proj[0] * view[1]
		matrix[2] = proj[0] * view[2]
		matrix[3] = proj[0] * view[3]
		matrix[4] = proj[5] * view[4]
		matrix[5] = proj[5] * view[5]
		matrix[6] = proj[5] * view[6]
		matrix[7] = proj[5] * view[7]
		matrix[8] = proj[10] * view[8] + proj[11] * view[12]
		matrix[9] = proj[10] * view[9] + proj[11] * view[13]
		matrix[10] = proj[10] * view[10] + proj[11] * view[14]
		matrix[11] = proj[10] * view[11] + proj[11] * view[15]
		matrix[12] = proj[14] * view[8]
		matrix[13] = proj[14] * view[9]
		matrix[14] = proj[14] * view[10]
		matrix[15] = proj[14] * view[11]
	}
	function copyArr(a, b) {
		for (let i = 0; i < a.length; i++) {
			b[i] = a[i]
		}
	}
	function FOV(fov) {
		let tang = Math.tan(fov * 0.5 * Math.PI / 180)
		let scale = 1 / tang
		let near = 1
		let far = 1000000
		currentFov = fov

		projection[0] = scale / width * height
		projection[5] = scale
		projection[10] = -far / (far - near)
		projection[11] = -1
		projection[14] = -far * near / (far - near)
	}
	function initModelView(camera, x, y, z, rx, ry) {
		if (camera) {
			camera.transform()
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			copyArr(defaultModelView, modelView)
			rotX(modelView, rx)
			rotY(modelView, ry)
			trans(modelView, -x, -y, -z)
			matMult()
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
	}

	function timeString(millis) {
		if (millis > 300000000000 || !millis) {
			return "never"
		}
		const SECOND = 1000
		const MINUTE = SECOND * 60
		const HOUR = MINUTE * 60
		const DAY = HOUR * 24
		const YEAR = DAY * 365

		if (millis < MINUTE) {
			return "just now"
		}

		let years = floor(millis / YEAR)
		millis -= years * YEAR

		let days = floor(millis / DAY)
		millis -= days * DAY

		let hours = floor(millis / HOUR)
		millis -= hours * HOUR

		let minutes = floor(millis / MINUTE)

		if (years) {
			return `${years} year${years > 1 ? "s" : ""} and ${days} day${day !== 1 ? "s" : ""} ago`
		}
		if (days) {
			return `${days} day${days > 1 ? "s" : ""} and ${hours} hour${hours !== 1 ? "s" : ""} ago`
		}
		if (hours) {
			return `${hours} hour${hours > 1 ? "s" : ""} and ${minutes} minute${minutes !== 1 ? "s" : ""} ago`
		}
		return `${minutes} minute${minutes > 1 ? "s" : ""} ago`
	}
	function roundBits(number) {
		return ((number * 1000000 + 0.5) | 0) / 1000000
	}
	function rayTrace(x, y, z, shape) {
		let cf, cd = 1e9; //Closest face and distance
		let m; //Absolute distance to intersection point
		let ix, iy, iz; //Intersection coords
		let minX, minY, minZ, maxX, maxY, maxZ, min, max; //Bounds of face coordinates
		let east = p.direction.x < 0
		let top = p.direction.y < 0
		let north = p.direction.z < 0
		let verts = shape.verts
		let faces = verts[0]

		//Top and bottom faces

		if (top) {
			faces = verts[1]
		}
		if (p.direction.y) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				m = (y + face[1] - p.y) / p.direction.y
				ix = m * p.direction.x + p.x
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iz >= z + minZ && iz <= z + maxZ) {
					cd = m; //Ray crosses bottom face
					cf = top ? "top" : "bottom"
				}
			}
		}

		//West and East faces
		if (east) {
			faces = verts[4]
		} else {
			faces = verts[5]
		}
		if (p.direction.x) {
			for (let face of faces) {
				min = face.min
				minY = min[1]
				minZ = min[2]
				max = face.max
				maxY = max[1]
				maxZ = max[2]
				m = (x + face[0] - p.x) / p.direction.x
				iy = m * p.direction.y + p.y
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && iy >= y + minY && iy <= y + maxY && iz >= z + minZ && iz <= z + maxZ) {
					cd = m
					cf = east ? "east" : "west"
				}
			}
		}

		//South and North faces
		if (north) {
			faces = verts[2]
		} else {
			faces = verts[3]
		}
		if (p.direction.z) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				m = (z + face[2] - p.z) / p.direction.z
				ix = m * p.direction.x + p.x
				iy = m * p.direction.y + p.y
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iy >= y + minY && iy <= y + maxY) {
					cd = m
					cf = north ? "north" : "south"
				}
			}
		}
		return [ cd, cf ]
	}
	function runRayTrace(x, y, z) {
		let block = world.getBlock(x, y, z)
		if (block) {
			let shape = blockData[block].shape
			let rt = rayTrace(x, y, z, blockData[block].shape)

			if (rt[1] && rt[0] < hitBox.closest) {
				hitBox.closest = rt[0]
				hitBox.face = rt[1]
				hitBox.pos = [ x, y, z ]
				hitBox.shape = blockData[block].shape
        
        crack.pos = [x, y, z]
        crack.shape = blockData[block].shape
			}
		}
	}
	function lookingAt() {
		// Checks blocks in front of the player to see which one they're looking at
		hitBox.pos = null
		hitBox.closest = 1e9

		if (p.spectator) {
			return
		}
		let blockState = world.getBlock(p2.x, p2.y, p2.z)
		if (blockState) {
			hitBox.pos = [ p2.x, p2.y, p2.z ]
			hitBox.closest = 0
			hitBox.shape = blockData[blockState].shape
      
      crack.pos = [p2.x, p2.y, p2.z]
      crack.shape = blockData[blockState].shape
			return
		}

		let pd = p.direction

		// Target block
		let tx = round(pd.x * reach + p.x)
		let ty = round(pd.y * reach + p.y)
		let tz = round(pd.z * reach + p.z)

		let minX = p2.x
		let maxX = 0
		let minY = p2.y
		let maxY = 0
		let minZ = p2.z
		let maxZ = 0

		for (let i = 0; i < reach + 1; i++) {
			if (i > reach) {
				i = reach
			}
			maxX = round(p.x + pd.x * i)
			maxY = round(p.y + pd.y * i)
			maxZ = round(p.z + pd.z * i)
			if (maxX === minX && maxY === minY && maxZ === minZ) {
				continue
			}
			if (minX !== maxX) {
				if (minY !== maxY) {
					if (minZ !== maxZ) {
						runRayTrace(maxX, maxY, maxZ)
					}
					runRayTrace(maxX, maxY, minZ)
				}
				if (minZ !== maxZ) {
					runRayTrace(maxX, minY, maxZ)
				}
				runRayTrace(maxX, minY, minZ)
			}
			if (minY !== maxY) {
				if (minZ !== maxZ) {
					runRayTrace(minX, maxY, maxZ)
				}
				runRayTrace(minX, maxY, minZ)
			}
			if (minZ !== maxZ) {
				runRayTrace(minX, minY, maxZ)
			}
			if (hitBox.pos) {
				return; //The ray has collided; it can't possibly find a closer collision now
			}
			minZ = maxZ
			minY = maxY
			minX = maxX
		}
	}
	let inBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.topH
		let ih = h + p.bottomH + p.topH
		let ix = x - w/2 - p.w
		let iw = w + p.w*2
		let iz = z - d/2 - p.w
		let id = d + p.w*2
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
	}
	let onBox = function(x, y, z, w, h, d) {
		let iy = roundBits(y - h/2 - p.topH)
		let ih = roundBits(h + p.bottomH + p.topH)
		let ix = roundBits(x - w/2 - p.w)
		let iw = roundBits(w + p.w*2)
		let iz = roundBits(z - d/2 - p.w)
		let id = roundBits(d + p.w*2)
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
	}
	function collided(x, y, z, vx, vy, vz, block) {
		if(p.spectator) {
			return false
		}
		let verts = blockData[block].shape.verts
		let px = roundBits(p.x - p.w - x)
		let py = roundBits(p.y - p.bottomH - y)
		let pz = roundBits(p.z - p.w - z)
		let pxx = roundBits(p.x + p.w - x)
		let pyy = roundBits(p.y + p.topH - y)
		let pzz = roundBits(p.z + p.w - z)
		let minX, minY, minZ, maxX, maxY, maxZ, min, max

		//Top and bottom faces
		let faces = verts[0]
		if (vy <= 0) {
			faces = verts[1]
		}
		if (!vx && !vz) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
					if (vy <= 0) {
						p.onGround = true
						p.y = round((face[1] + y + p.bottomH) * 10000) / 10000
						return false
					} else {
						return true
					}
				}
			}
			return false
		}

		//West and East faces
		if (vx < 0) {
			faces = verts[4]
		} else if (vx > 0) {
			faces = verts[5]
		}
		if (vx) {
			let col = false
			for (let face of faces) {
				min = face.min
				minZ = min[2]
				minY = min[1]
				max = face.max
				maxZ = max[2]
				maxY = max[1]
				if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
					if (maxY - py > 0.5) {
						p.canStepX = false
					}
					col = true
				}
			}
			return col
		}

		//South and North faces
		if (vz < 0) {
			faces = verts[2]
		} else if (vz > 0) {
			faces = verts[3]
		}
		if (vz) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
					if (maxY - py > 0.5) {
						p.canStepZ = false
					}
					col = true
				}
			}
			return col
		}
	}
	let contacts = {
		array: [],
		size: 0,
		add: function(x, y, z, block) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
			}
			this.size++
		},
		clear: function() {
			this.size = 0
		},
	}
	let resolveContactsAndUpdatePosition = function() {
		let pminX = p2.x - 1
		let pmaxX = p2.x + 1
		let pminY = p2.y - 2
		let pmaxY = p2.y + 1
		let pminZ = p2.z - 1
		let pmaxZ = p2.z + 1
		let block = null
		let vel = p.velocity

    let blocks = []
		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = world.getBlock(x, y, z)
					if (block && blockData[block].solid && !blockData[block].liquid) {
						contacts.add(x, y, z, block)
					}
          if (block) {
            blocks.push([x, y, z, block])
          }
				}
			}
		}

		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt

		p.previousX = p.x
		p.previousY = p.y
		p.previousZ = p.z

    var ontouch
    var x
    var y
    var z
    var damage = 0
    liquid = false
    //collisions for ontouch
    for (let i = 0; i < blocks.length; i++) {
			block = blocks[i]
      if(block[0] === p2.x && block[2] === p2.z && blockData[block[3]].ontouch){
        ontouch = blockData[block[3]].ontouch
        x = block[0]
        y = block[1]
        z = block[2]
      }
      if(blockData[block[3]].liquid) {
        liquid = true
      }
      let d = blockData[block[3]].damage
      if(d && d>damage) {
        damage = d
      }
		}
    
		//Check collisions in the Y direction
		p.onGround = false
		p.canStepX = false
		p.canStepZ = false
		p.y += vel.y * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], 0, vel.y, 0, block[3])) {
				p.y = p.previousY
				vel.y = 0
				break
			}
		}
		if (p.y === p.previousY && !p.flying) {
			p.canStepX = true
			p.canStepZ = true
		}

		var sneakLock = false, sneakSafe = false
		if (p.sneaking) {
			for (let i = 0; i < contacts.size; i++) {
				block = contacts.array[i]
				if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
					sneakLock = true
					break
				}
			}
		}

		//Check collisions in the X direction
		p.x += vel.x * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], vel.x, 0, 0, block[3])) {
				if (p.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				p.x = p.previousX
				vel.x = 0
				break
			}
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true
			}
		}

		if (sneakLock && !sneakSafe) {
			p.x = p.previousX
			vel.x = 0
		}
		sneakSafe = false

		//Check collisions in the Z direction
		p.z += vel.z * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], 0, 0, vel.z, block[3])) {
				if (p.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				p.z = p.previousZ
				vel.z = 0
				break
			}
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true
			}
		}

		if (sneakLock && !sneakSafe) {
			p.z = p.previousZ
			vel.z = 0
		}

		if (!p.flying) {
      if (liquid){
        p.jumpSpeed = 0.135;
        p.gravityStength = -0.001;
        if (Key[" "] || Key.w || Key.a || Key.s || Key.d){
          p.velocity.y += 0.006
        }
      }else{
        p.gravityStength = -0.032
      }
			let drag = p.onGround ? 0.5 : 0.85
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt
		} else {
			let drag = 0.9
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt
			p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y) * dt
			if (p.onGround && !p.spectator) {
				p.flying = false
			}
		}

		p.lastUpdate = performance.now()
		contacts.clear()
		lookingAt()
    
    return {ontouch:ontouch, x:x, y:y, z:z, damage:damage}
	}
	let runGravity = function() {
		if (p.flying) {
			return
		}
		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt
		if(p.onGround) {
      let fall = p.lastY - p.y
      p.lastY = p.y
      if(fall > 3 && survival && !liquid) {
        p.health -= Math.floor(fall-3)//Math.floor( (p.velocity.y * p.velocity.y * 8));
        harmEffect = 40
        updateHUD = true;
        if(fall > 6){
          playSound("damage.bigfall")
        }else playSound("damage.smallfall")
			}
      if(p.velocity.y < -0.1) blockSound(world.getBlock(p2.x, p2.y-2, p2.z), "step")
			if(Key[" "]) {
				p.velocity.y = p.jumpSpeed
				p.onGround = false
			} else {
				p.velocity.y = 0
			}
		} else {
			p.velocity.y += p.gravityStength * dt
			if(p.velocity.y < -p.maxYVelocity) {
				p.velocity.y = -p.maxYVelocity
			}
		}
	}

	function box2(sides, tex, shape) {
		if (blockFill && !shape) {
			let i = 0
			for (let side in Block) {
				if (sides & Block[side]) {
					vertexAttribPointer("aVertex", program3D, "aVertex", 3, sideEdgeBuffers[Sides[side]])
					vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0)
				}
				i++
			}
		}else if(shape){
			for (let i = 0; i < shape.size; i++) {
        vertexAttribPointer("aVertex", program3D, "aVertex", 3, shape.buffer)
	 		  vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
				gl.drawArrays(gl.TRIANGLES, i * 4, 4) //doesn't work
			}
    }
		if (blockOutlines) {
			vertexAttribPointer("aVertex", program3D, "aVertex", 3, hitBox.shape.buffer)
			vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox])
			for (let i = 0; i < hitBox.shape.size; i++) {
				gl.drawArrays(gl.LINE_LOOP, i * 4, 4)
			}
    }
	}
	function block2(x, y, z, t, camera, cracks) {
		if (camera) {
			camera.transformation.translate(x, y, z)
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			//copyArr(modelView, matrix)
			trans(modelView, x, y, z)
			matMult()
			trans(modelView, -x, -y, -z)
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
    if(cracks){
      box2(0xff, crack.tex)
    }else box2(0xff, blockData[t].textures)
	}

	function changeWorldBlock(t, drop) {
		let pos = hitBox.pos
		if(pos && pos[1] > 0 && pos[1] < maxHeight) {
			let shape = t && blockData[t].shape
			if (t && shape.rotate) {
				let pi = Math.PI / 4
				if (p.ry <= pi) {} // North; default
				else if (p.ry < 3 * pi) {
					t |= WEST
				} else if (p.ry < 5 * pi) {
					t |= SOUTH
				} else if (p.ry < 7 * pi) {
					t |= EAST
				}
			}

			if (t && shape.flip && hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y) % 1 < 0.5)) {
				t |= FLIP
			}

      var prevBlock = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
			world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t)
      if(drop){
        let block = prevBlock
        let theDrop = blockData[prevBlock].drop
        if(theDrop) block = blockIds[theDrop]
        world.addEntity(new Item(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, 0, 0, block))
      }
			if (t) {
				p.lastPlace = Date.now()
			} else {
				p.lastBreak = Date.now()
        blockSound(prevBlock, "dig", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
			}
		}
	}
	function newWorldBlock() {
    if(hitBox.pos){
      let pos = hitBox.pos, x= pos[0], y = pos[1], z = pos[2]
      let block = world.getBlock(x, y, z)
      if(block){
        let onclick = blockData[block].onclick
        if(onclick){
          if(!onclick(x, y, z)){p.lastPlace = Date.now(); return} //if it doesn't return true
        }
        let onuse = blockData[holding] ? blockData[holding].onuse : null
        if(onuse){ //items like flint and steel can't be placed but lights stuff
          if(!onuse(x,y,z, block)){p.lastPlace = Date.now(); return}
        }
      }
    }
		if(!hitBox.pos || !holding) {
			return
		}
    let pos = hitBox.pos, x= pos[0], y = pos[1], z = pos[2]
    let side = false
		switch(hitBox.face) {
			case "top":
				y += 1
				break
			case "bottom":
				y -= 1
				break
			case "south":
				z -= 1
        side = true
				break
			case "north":
				z += 1
        side = true
				break
			case "west":
				x -= 1
        side = true
				break
			case "east":
				x += 1
        side = true
				break
		}
		if (!inBox(x, y, z, 1, 1, 1) && !world.getBlock(x, y, z)) {
      var block = holding
      
			pos[0] = x
			pos[1] = y
			pos[2] = z
			var prevBlockMode = blockMode;
      var onPot = !side && blockData[world.getBlock(x,y-1,z)] && blockData[world.getBlock(x,y-1,z)].pot
      if(blockData[holding].potCross && onPot){
        blockMode = POTCROSS
      }else if(blockData[holding].crossShape){
        if(onPot && blockIds[blockData[holding].name+"Pot"]){
          block = blockIds[blockData[holding].name+"Pot"]
          blockMode = POTCROSS
        }else{
          blockMode = CROSS
        }
      }
      if(blockData[holding].tallcrossShape){
        blockMode = TALLCROSS
      }
      if(blockData[holding].door){
        blockMode = DOOR
      }
      if(blockData[holding].torch){
        blockMode = TORCH
      }
      if(blockData[holding].lantern){
        if(world.getBlock(hitBox.pos[0],hitBox.pos[1]+1,hitBox.pos[2])){
          blockMode = LANTERNHANG
        }else{
          blockMode = LANTERN
        }
      }
      if(blockData[holding].beacon){
        blockMode = BEACON
      }
      if(blockData[holding].cactus){
        blockMode = CACTUS
      }
      if(blockData[holding].pane){
        blockMode = PANE
      }
      if(blockData[holding].portal){
        blockMode = PORTAL
      }
      if(blockData[holding].wallFlat){
        blockMode = WALLFLAT
      }
      if(blockData[holding].trapdoor){
        if(side){
          blockMode = TRAPDOOROPEN
        }else{
          blockMode = TRAPDOOR
        }
      }
      if(blockData[holding].chain){
        blockMode = CHAIN
      }
      if(blockData[holding].button){
        blockMode = BUTTON
      }
      if(blockData[holding].pot){
        blockMode = POT
      }
      if(blockData[holding].carpet){
        blockMode = CARPET
      }
			changeWorldBlock(block < 0xff ? (block | blockMode) : block)
      blockMode = prevBlockMode;
      
      if(survival && inventory.hotbar[inventory.hotbarSlot]){
        inventory.hotbar[inventory.hotbarSlot].amount --;
        updateHUD = true
      }
      
      //play sound
      blockSound(block, "place", x,y,z)
		}
	}

  function cracks(){
    var block = hitBox.pos ? world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) : 0
    var breaking = Key.leftMouse && block
    if(!arrayValues(crack.prevPos, crack.pos)){
      crack.prevPos = crack.pos
      crackAmount = 0
      crack.soundTimer = 0
    }
    if(breaking){
      crackAmount ++
      crack.idx = map(crackAmount, 0,blockData[block].breakTime, 0,3)
      crack.idx = floor(crack.idx)
      var tex = crack[crack.idx]
      for(var i=0; i<crack.tex.length; i++) crack.tex[i] = tex
      crack.soundTimer ++
      if(crack.soundTimer > 15){
        crack.soundTimer -= 15
        blockSound(block, "breaking", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
      }
      if(crack.idx >= 3) changeWorldBlock(0, true)
    }else{
      crack.idx = -1
      crackAmount = 0
    }
  }

	// Save the coords for a small sphere used to carve out caves
	let sphere;
	{
		let blocks = []
		let radius = 3.5
		let radsq = radius * radius
		for (let i = -radius; i <= radius; i++) {
			for (let j = -radius; j <= radius; j++) {
				for (let k = -radius; k <= radius; k++) {
					if (i*i + j*j + k*k < radsq) {
						blocks.push(i|0, j|0, k|0)
					}
				}
			}
		}
		sphere = new Int8Array(blocks)
	}

	function isCave(x, y, z) {
		// Generate a 3D rigid multifractal noise shell.
		// Then generate another one with different coordinates.
		// Overlay them on top of each other, and the overlapping parts should form a cave-like structure.
		// This is extremely slow, and requires generating 2 noise values for every single block in the world.
		// TODO: replace with a crawler system of some sort, that will never rely on a head position in un-generated chunks.
		let smooth = 0.02
		let caveSize = 0.0055
		let cave1 = abs(0.5 - caveNoise(x * smooth, y * smooth, z * smooth)) < caveSize
		let cave2 = abs(0.5 - caveNoise(y * smooth, z * smooth, x * smooth)) < caveSize
		return (cave1 && cave2)
	}
	function carveSphere(x, y, z) {
		if (y > 3) {
			for (let i = 0; i < sphere.length; i += 3) {
				world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true)
			}
		}
	}

	let renderedChunks = 0
	function getBlock(x, y, z, blocks) {
		return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)]
	}
	/**
	 * Returns a 1 if the face is exposed and should be drawn, or a 0 if the face is hidden
	 * 
	 * @param {number} x - The X coordinate of the block that may be covering a face
	 * @param {number} y - The Y coordinate of the block that may be covering a face
	 * @param {number} z - The Z coordinate of the block that may be covering a face
	 * @param {Collection} blocks - Some collection of blocks that can return the block at (x, y, z)
	 * @param {number} type - The blockstate of the block that's being considered for face culling
	 * @param {function} func - The function that can be called to return a block from the blocks collection
	*/
	function hideFace(x, y, z, blocks, type, func, sourceDir, dir) {
		let block = func.call(world, x, y, z, blocks)
		if (!block) {
			return 1
		}

		let data = blockData[block]
		let sourceData = blockData[type]

		let sourceRange = 3
		let hiderRange = 3
		if (func !== getBlock || screen === "loading") {
			// getBlock is only used during the optimize phase of worldGen
			sourceRange = sourceData.shape.cull[sourceDir]
			hiderRange = data.shape.cull[dir]
		}

		if ((sourceRange & hiderRange) !== sourceRange || sourceRange === 0 || block !== type && data.transparent || data.transparent && data.shadow) {
			return 1
		}
		return 0
	}
	let getShadows = {
		shade: [ 1, 0.85, 0.7, 0.6, 0.3 ],
		ret: [],
		blocks: [],
		top: function(x, y, z, block) { // Actually the bottom... How did these get flipped?
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x, y-1, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x, y-1, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y-1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y-1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y-1, z+1, block)].shadow

			ret[0] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.75
			ret[1] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.75
			ret[2] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.75
			ret[3] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.75
			return ret
		},
		bottom: function(x, y, z, block) { // Actually the top
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x, y+1, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y+1, z, block)].shadow
			blocks[4] = blockData[getBlock(x, y+1, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
			ret[2] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
			return ret
		},
		north: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[1] = blockData[getBlock(x, y-1, z+1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y, z+1, block)].shadow
			blocks[4] = blockData[getBlock(x, y, z+1, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y, z+1, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
			ret[1] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
			ret[2] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
			ret[3] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
			return ret
		},
		south: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x, y-1, z-1, block)].shadow
			blocks[4] = blockData[getBlock(x, y, z-1, block)].shadow
			blocks[5] = blockData[getBlock(x, y+1, z-1, block)].shadow
			blocks[6] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[7] = blockData[getBlock(x+1, y, z-1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z-1, block)].shadow

			ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
			return ret
		},
		east: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x+1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x+1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x+1, y, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x+1, y, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8
			return ret
		},
		west: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x-1, y, z, block)].shadow
			blocks[5] = blockData[getBlock(x-1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x-1, y, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x-1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8
			ret[3] = this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8
			return ret
		},
	}
	
	function average(l, a, b, c, d) {
		a = l[a]
		b = l[b]
		c = l[c]
		d = l[d]
		let count = 1
		let zero = 0
		let total = a
		if (b && abs(a-b) <= 2) {
			total += b
			count++
		} else zero++
		if (c && abs(a-c) <= 2) {
			total += c
			count++
		} else zero++
		if (d && abs(a-d) <= 2) {
			total += d
			count++
		} else zero++

		let mx = max(a, b, c, d)
		if (mx > 2) {
			return total / (count * 15)
		}
		if (mx > 1) {
			return zero ? total / (count * 15 + 15) : total / (count * 15)
		}
		return (total) / 60
	}
	let getLight = {
		blocks: [],
		top: function(x, y, z, block, ret, blockLight = 0) { // Actually the bottom... How did these get flipped?
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 0, 1, 3)
			ret[1] = average(blocks, 4, 1, 2, 5)
			ret[2] = average(blocks, 4, 5, 7, 8)
			ret[3] = average(blocks, 4, 3, 6, 7)
			// debugger
			return ret
		},
		bottom: function(x, y, z, block, ret, blockLight = 0) { // Actually the top
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 3, 6, 7)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 1, 2, 5)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		north: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 3, 6, 7)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 1, 2, 5)
			return ret
		},
		south: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		east: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x+1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		west: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x-1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 1, 2, 5)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 3, 6, 7)
			return ret
		},
	}

	/*
	function interpolateShadows(shadows, x, y) {
		let sx = (shadows[1] - shadows[0]) * x + shadows[0]
		let sx2 = (shadows[3] - shadows[2]) * x + shadows[2]
		return (sx2 - sx) * y + sx
	}
	*/
  
class Generator {
    constructor() {
        this.seedSet = false;
        this.seed = 0;
        this.size = 600;
        this.diagonalNeighbors = true; //true if the corners are also adjacent
        
        this.grid = [];
        this.vertex = [];
        this.river = [];
        this.precip = [];
        this.biome = [];
        this.biomeBlend = [];
        
        this.highestPoint = [0,0];
        
        this.updates = [];
        this.stage = 0;
        this.changes = 0;
        this.rivers = 0;
        this.h = 0;
        this.X = 0;
    }
    GetVertex(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 0;}
        return this.vertex[x+y*this.size];
    }
    GetHeight(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 5;}
        return Math.round(
        (this.GetVertex(Math.floor(x), Math.floor(y))+
        this.GetVertex(Math.floor(x+0.5), Math.floor(y))+
        this.GetVertex(Math.floor(x), Math.floor(y+0.5))+
        this.GetVertex(Math.floor(x+0.5), Math.floor(y+0.5)))*0.5+5);
    };
    GetWater(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        if (this.GetBiome(x,y) === -15099421 || this.GetBiome(x,y) === -16479791) {return 1}
        return Math.sqrt(this.river[x+y*this.size]);
    }
    GetWaterDepth(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        var w = 0;
        for (let x2 = 0; x2 < 1; x2+=0.5) {
            for (let y2 = 0; y2 < 1; y2+=0.5) {
                w += this.GetWater(Math.floor(x+x2),Math.floor(y+y2));
            }
        }
        w = w/4.0;
        if (w > 0.25) {
            return 1;
        }   else {
            return 0;
        }
    }
    GetBiome(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return -16479791;}
        return this.biome[x+y*this.size];
    }
    GetBiomeType(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        return this.GetBiome(Math.floor(x),Math.floor(y));
    }
    GetNeighbors(x, y) {
        var n = [];
        if (x > 0) {
            n.push({x:x-1, y:y});
            if (this.diagonalNeighbors) {
            if (y > 0) {
                n.push({x:x-1, y:y-1});
            }
            if (y < this.size-1) {
                n.push({x:x-1, y:y+1});
            }}
        }
        if (x < this.size-1) {
            n.push({x:x+1, y:y});
            if (this.diagonalNeighbors) {
            if (y > 0) {
                n.push({x:x+1, y:y-1});
            }
            if (y < this.size-1) {
                n.push({x:x+1, y:y+1});
            }
            }
        }
        if (y > 0) {
            n.push({x:x, y:y-1});
        }
        if (y < this.size-1) {
            n.push({x:x, y:y+1});
        }
        return n;
    }
    GetDown(x, y) {
        var n = this.GetNeighbors(x, y);
        var l = this.size;
        var ld = [];
        for (var i in n) {
            if (this.vertex[n[i].x + n[i].y*this.size] <= l) {
                if (this.vertex[n[i].x + n[i].y*this.size] === l) {
                    ld.push(n[i]);
                }
                l = this.vertex[n[i].x + n[i].y*this.size];
                ld = [n[i]];
            }
        }
        if (l <= this.vertex[x + y*this.size]) {
            return ld[Math.floor(random(ld.length))];
        }
        return undefined;
    }
    SetSeed(seed) {
        this.seed = seed;
        this.seedSet = true;
        randomSeed(hash(seed, 2123155232) * 210000000)
    }
    Generate(start) {
        var end = start+16;
        var nS = 0.021;
        function sq(n) {return n*n}
        function color(r, g, b, a) {
            a = (a === undefined ? 255 : a);
            g = (g === undefined ? r : g);
            b = (b === undefined ? g : b);
            if (a > 127) {a = -256+a;}
            return b+g*256+r*65536+a*16777216;
        }
        if (this.stage === 0) { //landmass
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.grid[x +y*this.size] = 0;
                    this.vertex[x + y*this.size] = -1;
                    this.precip[x + y*this.size] = -1;
                    this.river[x + y*this.size] = 0;
                    var d = this.size/2-Math.sqrt(sq(x-this.size/2)+sq(y-this.size/2));
                    var islandMask = Math.sqrt(sq(this.size/2)-sq(d-this.size/2))*2/this.size;
                    var v = noise(x*nS, y*nS, this.seed);
                    if (v*islandMask > 0.3) {
                        this.grid[x+y*this.size] = 1;
                    }
                }
                this.X++;
            }
            if (this.X === this.size) {
                this.updates.push({type:"ocean", x:0, y:0});
            }
        }   else if (this.stage === 1) {    //Oceans
            while (this.updates.length > 0 && win.performance.now() < end) {
                var u = this.updates.shift();
                if (this.grid[u.x+u.y*this.size] === 0) {
                    this.grid[u.x+u.y*this.size] = 2;
                    var n = this.GetNeighbors(u.x, u.y);
                    for (var i = 0; i < n.length; i++) {
                        if (this.grid[n[i].x+n[i].y*this.size] === 0) {
                            this.updates.push({type:"ocean",x:n[i].x,y:n[i].y});
                        }
                    }
                }
            }
            if (this.updates.length === 0) {
                this.X = this.size;
            }
        }   else if (this.stage === 2) {    //altitude
            if (this.h === -1) {this.h = 0;}
            var doingLake = false;
            var I = 0;
            while (win.performance.now() < end && this.updates.length > 0 && I < this.updates.length) {
                if (this.updates[I].type === "lake") {
                    var u = this.updates.splice(I, 1)[0];
                    if (this.grid[u.x + u.y*this.size] === 0 && this.vertex[u.x+u.y*this.size] === -1) {
                        this.vertex[u.x + u.y*this.size] = u.a;
                        var n = this.GetNeighbors(u.x, u.y);
                        for (var i in n) {
                            if (this.grid[n[i].x+n[i].y*this.size] === 0 && this.vertex[n[i].x + n[i].y*this.size] === -1) {
                                this.updates.push({type:"lake",x:n[i].x,y:n[i].y,a:u.a});
                            }
                        }
                    }
                    I--;
                }
                I++;
            }
            while (this.X < this.size && win.performance.now() < end && !doingLake) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.vertex[x+y*this.size] === -1) {
                        if (this.grid[x+y*this.size] === 2) {
                            this.vertex[x+y*this.size] = this.h;
                            this.changes++;
                        }   else if (this.h > 0) {
                            var n = this.GetNeighbors(x, y);
                            var l = this.size;
                            var ld;
                            for (var i in n) {
                                var v = this.vertex[n[i].x + n[i].y*this.size];
                                if (v < l && v !== -1) {
                                    l = v;
                                    ld = n[i];
                                }
                            }
                            if (l !== this.size && l <= this.h) {
                                if (this.grid[x+y*this.size] === 0) {
                                    this.updates.push({type:"river",x:ld.x,y:ld.y});
                                    this.updates.push({type:"lake",x:x,y:y,a:l});
                                }   else {
                                    this.vertex[x+y*this.size] = l+1+(random() > 0.5 ? 1 : 0);
                                }
                                this.changes++;
                            }
                        }
                    }
                }
                this.X++;
            }
            if (this.X === this.size && this.h < this.size/3) {
                if (this.changes === 0) {
                    this.h++;
                }
                this.X = 0;
                this.changes = 0;
            }
        }   else if (this.stage === 3) {    //altitude readjustment
            
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.vertex[x+y*this.size] = (Math.pow(20, this.vertex[x+y*this.size]/this.size*3)-1)/(20-1)*this.size/3;
                    if (this.vertex[x+y*this.size] > this.vertex[this.highestPoint[0]+this.highestPoint[1]*this.size]) {
                        this.highestPoint[0] = x;
                        this.highestPoint[1] = y;
                    }
                }
                this.X++;
            }
            
        }   else if (this.stage === 4) {    //rivers
            if (this.rivers === 0) {
                var x, y;
                for (var i = 0; i < 200 && this.rivers < 100; i++) {
                    x = Math.floor(random(this.size));
                    y = Math.floor(random(this.size));
                    if (this.grid[x+y*this.size] === 1) {
                        this.updates.push({type:"river",x:x,y:y});
                        this.rivers++;
                    }
                }
            }   else {
                if (this.updates.length === 0) {
                    this.X = this.size;
                }
            }
            while(this.updates.length > 0 && win.performance.now() < end) {
                var u = this.updates[0];
                if (this.grid[u.x+u.y*this.size] === 1) {
                    this.river[u.x+u.y*this.size]++;
                    var d = this.GetDown(u.x, u.y);
                    if (d === undefined) {
                        this.updates.shift();
                    }   else {
                        this.updates[0].x = d.x; this.updates[0].y = d.y;
                    }
                }   else {
                    this.updates.shift();
                }
            }
        }   else if (this.stage === 5) {    //precipitation
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.precip[x + y*this.size] === -1) {
                        if (this.h === -1) {
                            if (this.grid[x + y*this.size] === 2) {
                                this.precip[x + y*this.size] = 5;
                                this.changes++;
                            }
                        }   else {
                            if (this.h <= 8) {
                                if (this.grid[x + y*this.size] === 0 || this.river[x+y*this.size] > 0) {
                                    this.precip[x + y*this.size] = 8;
                                    this.changes++;
                                }
                            }
                            var n = this.GetNeighbors(x, y);
                            var h = -1;
                            for (var i in n) {
                                if (this.precip[n[i].x + n[i].y*this.size] > h) {
                                    h = this.precip[n[i].x + n[i].y*this.size];
                                }
                            }
                            if (h > -1 && h >= this.h) {
                                this.precip[x+y*this.size] = Math.max(h - (random() < 0.5 ? 0.66 : 0.33), 0);
                                this.changes++;
                            }
                        }
                    }
                }
                this.X++;
            }
            if (this.X === this.size) {
                this.X = 0;
                if (this.h === -1) {
                    this.h = 10;
                }   else {
                    if (this.changes === 0) {
                        this.h--;
                    }
                    this.changes = 0;
                    if (this.h < 0) {
                        this.X = this.size;
                    }
                }
            }
        }   else if (this.stage === 6) {    //readjust precipitation
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.precip[x+y*this.size] = Math.floor(this.precip[x+y*this.size]/10*6);
                }
                this.X++;
            }
        }   else if (this.stage === 7) {    //temperature
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                }
                this.X++;
            }
        }   else if (this.stage === 8) {    //biomes
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    var c;
                    var h = Math.floor(this.vertex[x+y*this.size]/this.size*6*5);
                    switch (this.grid[x+y*this.size]) {
                        case 0: if (h > 2) {
                                c = color(157, 194, 201);
                            }   else {
                                c = color(25, 153, 227);
                            }   break;
                        case 1: if (this.river[x+y*this.size] > 0) {
                                    if (h > 2) {
                                    c = color(157, 194, 201);
                                }   else {
                                    c = color(25, 153, 227);
                                }
                            }   else {
                                switch (h) {
                                    case 0: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: c = color(10, 133, 72); break;
                                        case 3: case 2: c = color(10, 133, 23); break;
                                        case 1: c = color(179, 232, 35); break;
                                        case 0: c = color(209, 166, 58); break;
                                    } break;
                                    case 1: switch (this.precip[x+y*this.size]) {
                                        case 5: c = color(14, 156, 85); break;
                                        case 4: case 3: c = color(72, 133, 10); break;
                                        case 2: case 1: c = color(179, 232, 35); break;
                                        case 0: c = color(207, 195, 58); break;
                                    } break;
                                    case 2: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: c = color(121, 191, 95); break;
                                        case 3: case 2: c = color(155, 161, 135); break;
                                        case 1: case 0: c = color(207, 195, 58); break;
                                    } break;
                                    case 3: case 4: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: case 3: c = color(255); break;
                                        case 2: c = color(149, 189, 94); break;
                                        case 1: c = color(180); break;
                                        case 0: c = color(128);
                                    } break;
                                }
                            }
                            break;
                        case 2: c = color(4, 137, 209); break;
                    }
                    this.biome[x+y*this.size] = c;
                }
                this.X++;
            }
        }   else if (this.stage === 9) {    //add lava
            let ph = this.vertex[this.highestPoint[0] + this.highestPoint[1]*this.size]-5;
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.vertex[x + y*this.size] > ph) {
                        this.vertex[x + y*this.size] = ph-2;
                        this.biome[x + y*this.size] = -65536;
                    }
                }
                this.X++;
            }
        }
        if (this.X === this.size) {
            console.log(this.stage)
            this.X = 0;
            this.h = -1;
            this.stage++;
        }
    }
}

	class Section {
		constructor(x, y, z, size, chunk) {
			this.x = x
			this.y = y
			this.z = z
			this.size = size
			this.arraySize = size * size * size
			this.blocks = new Int32Array(this.arraySize)
			this.light = new Uint8Array(this.arraySize)
			this.renderData = []
			this.renderLength = 0
			this.faces = 0
			this.hasVisibleBlocks = false
			this.chunk = chunk
			this.edited = false
			this.caves = !caves
			this.pallete = [0]
			this.palleteMap = {"0": 0}
			this.palleteSize = 0
		}
		getBlock(x, y, z) {
			let s = this.size
			return this.blocks[x * s * s + y * s + z]
		}
		setBlock(x, y, z, blockId) {
			let s = this.size
			this.blocks[x * s * s + y * s + z] = blockId
		}
		deleteBlock(x, y, z) {
			let s = this.size
			this.blocks[x * s * s + y * s + z] = 0
		}
		optimize() {
			let visible = false
			let pos = 0
			let xx = this.x
			let yy = this.y
			let zz = this.z
			let blockState = 0
			let palleteIndex = 0
			let index = 0
			let s = this.size
			let blocks = this.blocks
			this.hasVisibleBlocks = false
			this.renderLength = 0
			let localBlocks = world.getAdjacentSubchunks(xx, yy, zz)

			//Check all the blocks in the subchunk to see if they're visible.
			for (let i = 0; i < s; i++) {
				for (let j = 0; j < s; j++) {
					for (let k = 0; k < s; k++, index++) {
						blockState = blocks[index]

						if (this.palleteMap[blockState] === undefined) {
							this.palleteMap[blockState] = this.pallete.length
							palleteIndex = this.pallete.length
							this.pallete.push(blockState)
						} else {
							palleteIndex = this.palleteMap[blockState]
						}

						visible = blockState && (hideFace(i-1, j, k, localBlocks, blockState, getBlock, "west", "east")
						| hideFace(i+1, j, k, localBlocks, blockState, getBlock, "east", "west") << 1
						| hideFace(i, j-1, k, localBlocks, blockState, getBlock, "bottom", "top") << 2
						| hideFace(i, j+1, k, localBlocks, blockState, getBlock, "top", "bottom") << 3
						| hideFace(i, j, k-1, localBlocks, blockState, getBlock, "south", "north") << 4
						| hideFace(i, j, k+1, localBlocks, blockState, getBlock, "north", "south") << 5)
						if (visible) {
							pos = (i | j << 4 | k << 8) << 19
							this.renderData[this.renderLength++] = 1 << 31 | pos | visible << 13 | palleteIndex
							this.hasVisibleBlocks = true
						}
					}
				}
			}
		}
		updateBlock(x, y, z, world, leaveMe) {
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk)
			}
			let i = x
			let j = y
			let k = z
			let s = this.size
			x += this.x
			y += this.y
			z += this.z
			let blockState = this.blocks[i * s * s + j * s + k]
			let visible = blockState && (hideFace(x-1, y, z, 0, blockState, world.getBlock, "west", "east")
			| hideFace(x+1, y, z, 0, blockState, world.getBlock, "east", "west") << 1
			| hideFace(x, y-1, z, 0, blockState, world.getBlock, "bottom", "top") << 2
			| hideFace(x, y+1, z, 0, blockState, world.getBlock, "top", "bottom") << 3
			| hideFace(x, y, z-1, 0, blockState, world.getBlock, "south", "north") << 4
			| hideFace(x, y, z+1, 0, blockState, world.getBlock, "north", "south") << 5)
			let pos = (i | j << 4 | k << 8) << 19
			let index = -1

			// Find index of current block in this.renderData
			for (let i = 0; i < this.renderLength; i++) {
				if ((this.renderData[i] & 0x7ff80000) === pos) {
					index = i
					break
				}
			}

			// Update pallete
			if (this.palleteMap[blockState] === undefined) {
				this.palleteMap[blockState] = this.pallete.length
				this.pallete.push(blockState)
			}

			if (index < 0 && !visible) {
				// Wasn't visible before, isn't visible after.
				return
			}
			if (!visible) {
				// Was visible before, isn't visible after.
				this.renderData.splice(index, 1)
				this.renderLength--
				this.hasVisibleBlocks = !!this.renderLength
				return
			}
			if (visible && index < 0) {
				// Wasn't visible before, is visible after.
				index = this.renderLength++
				this.hasVisibleBlocks = true
			}
			this.renderData[index] = 1 << 31 | pos | visible << 13 | this.palleteMap[blockState]
      
      if(!leaveMe && blockData[world.getBlock(x,y,z)]) blockData[world.getBlock(x,y,z)].onupdate(x,y,z);
		}
		genMesh(barray, index) {
			if (!this.renderLength) {
				return index
			}
			let length = this.renderLength
			let rData = this.renderData
			let x = 0, y = 0, z = 0, loc = 0, data = 0,
				sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0,
				verts = null, texVerts = null, texShapeVerts = null,
				tx = 0, ty = 0
			let wx = this.x, wy = this.y, wz = this.z
			let blocks = world.getAdjacentSubchunks(wx, wy, wz)
			let lightChunks = world.getAdjacentSubchunks(wx, wy, wz, true)
			let block = null

			let shadows = null, slights = [0, 0, 0, 0], blights = [0, 0, 0, 0]
			let blockSides = Object.keys(Block)
			let side = ""
			let shapeVerts = null
			let shapeTexVerts = null
			let pallete = this.pallete
			// let intShad = interpolateShadows
			
			for (let i = 0; i < length; i++) {
				data = rData[i]
				block = blockData[pallete[data & 0x1fff]]
				tex = block.textures
				sides = data >> 13 & 0x3f
				loc = data >> 19 & 0xfff
				x = loc & 15
				y = loc >> 4 & 15
				z = loc >> 8 & 15

				x2 = x + this.x
				y2 = y + this.y
				z2 = z + this.z

				shapeVerts = block.shape.verts
				shapeTexVerts = block.shape.texVerts

				let texNum = 0
				for (let n = 0; n < 6; n++) {
					side = blockSides[n]
					if (sides & Block[side]) {
						shadows = getShadows[side](x, y, z, blocks)
						slights = getLight[side](x, y, z, lightChunks, slights, 0)
						blights = getLight[side](x, y, z, lightChunks, blights, 1)
						let directionalFaces = shapeVerts[Sides[side]]
						for (let facei = 0; facei < directionalFaces.length; facei++) {
							verts = directionalFaces[facei]
							texVerts = textureCoords[textureMap[tex[texNum]]]
							tx = texVerts[0]
							ty = texVerts[1]
							texShapeVerts = shapeTexVerts[n][facei]

							barray[index] = verts[0] + x2
							barray[index+1] = verts[1] + y2
							barray[index+2] = verts[2] + z2
							barray[index+3] = tx + texShapeVerts[0]
							barray[index+4] = ty + texShapeVerts[1]
							barray[index+5] = shadows[0]
							barray[index+6] = slights[0]
							barray[index+7] = blights[0]

							barray[index+8] = verts[3] + x2
							barray[index+9] = verts[4] + y2
							barray[index+10] = verts[5] + z2
							barray[index+11] = tx + texShapeVerts[2]
							barray[index+12] = ty + texShapeVerts[3]
							barray[index+13] = shadows[1]
							barray[index+14] = slights[1]
							barray[index+15] = blights[1]

							barray[index+16] = verts[6] + x2
							barray[index+17] = verts[7] + y2
							barray[index+18] = verts[8] + z2
							barray[index+19] = tx + texShapeVerts[4]
							barray[index+20] = ty + texShapeVerts[5]
							barray[index+21] = shadows[2]
							barray[index+22] = slights[2]
							barray[index+23] = blights[2]

							barray[index+24] = verts[9] + x2
							barray[index+25] = verts[10] + y2
							barray[index+26] = verts[11] + z2
							barray[index+27] = tx + texShapeVerts[6]
							barray[index+28] = ty + texShapeVerts[7]
							barray[index+29] = shadows[3]
							barray[index+30] = slights[3]
							barray[index+31] = blights[3]
							index += 32
						}
					}
					texNum++
				}
			}
			return index
		}
		carveCaves() {
			let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16
			for (let x = this.x, xx = 0; x < wx; x++, xx++) {
				for (let z = this.z, zz = 0; z < wz; z++, zz++) {
					wy = this.chunk.tops[zz * 16 + xx]
					for (let y = this.y; y < wy; y++) {
						if (isCave(x, y, z)) {
							carveSphere(x, y, z)
						}
					}
				}
			}
			this.caves = true
		}
		tick() {
			for (let i = 0; i < 3; i++) {
				let rnd = Math.random() * this.blocks.length | 0
				if ((this.blocks[rnd]) === blockIds.grass) {
					// Spread grass

					let x = (rnd >> 8) + this.x
					let y = (rnd >> 4 & 15) + this.y
					let z = (rnd & 15) + this.z
					if (!blockData[world.getBlock(x, y + 1, z)].transparent) {
						world.setBlock(x, y, z, blockIds.dirt, false)
						return
					}

					let rnd2 = Math.random() * 27 | 0
					let x2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - x2 - 1) / 3
					let y2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - y2 - 1) / 3
					z += rnd2 - 1
					x += x2
					y += y2

					if (world.getBlock(x, y, z) === blockIds.dirt && world.getBlock(x, y + 1, z) === blockIds.air) {
						world.setBlock(x, y, z, blockIds.grass, false)
					}
				} else if (this.blocks[rnd] === (blockIds.oakSapling | CROSS)){
          let i = (rnd >> 8) + this.x;      let wx = i
					let j = (rnd >> 4 & 15) + this.y; let wy = j
					let k = (rnd & 15) + this.z;      let wz = k
          var ground = j//this.chunk.tops[i * 16 + k]
          var top = ground + floor(4.5 + (Math.random()*2.5) )
          var rand = floor(Math.random()*4096)
          let tree = blockIds.oakLog
          let leaf = blockIds.leaves
          let groundBlock = blockIds.dirt

          //Center
          for (let j = ground + 1; j <= top; j++) {
            world.setBlock(i, j, k, tree)
          }
          world.setBlock(i, top + 1, k, leaf)
          world.setBlock(i, ground, k, groundBlock)

          //Bottom leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 2, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 2, wz + z, leaf)
                }
              }
            }
          }

          //2nd layer leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 1, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 1, wz + z, leaf)
                }
              }
            }
          }

          //3rd layer leaves
          for (let x = -1; x <= 1; x++) {
            for (let z = -1; z <= 1; z++) {
              if (x || z) {
                if (x & z) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top, wz + z, leaf)
                }
              }
            }
          }

          //Top leaves
          world.setBlock(wx + 1, top + 1, wz, leaf)
          world.setBlock(wx, top + 1, wz - 1, leaf)
          world.setBlock(wx, top + 1, wz + 1, leaf)
          world.setBlock(wx - 1, top + 1, wz, leaf)
        }else if (this.blocks[rnd] === (blockIds.birchSapling | CROSS)){
          let i = (rnd >> 8) + this.x;      let wx = i
					let j = (rnd >> 4 & 15) + this.y; let wy = j
					let k = (rnd & 15) + this.z;      let wz = k
          var ground = j//this.chunk.tops[i * 16 + k]
          var top = ground + floor(4.5 + (Math.random()*2.5) )
          var rand = floor(Math.random()*4096)
          let tree = blockIds.birchLog
          let leaf = blockIds.leaves
          let groundBlock = blockIds.dirt

          //Center
          for (let j = ground + 1; j <= top; j++) {
            world.setBlock(i, j, k, tree)
          }
          world.setBlock(i, top + 1, k, leaf)
          world.setBlock(i, ground, k, groundBlock)

          //Bottom leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 2, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 2, wz + z, leaf)
                }
              }
            }
          }

          //2nd layer leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 1, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 1, wz + z, leaf)
                }
              }
            }
          }

          //3rd layer leaves
          for (let x = -1; x <= 1; x++) {
            for (let z = -1; z <= 1; z++) {
              if (x || z) {
                if (x & z) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top, wz + z, leaf)
                }
              }
            }
          }

          //Top leaves
          world.setBlock(wx + 1, top + 1, wz, leaf)
          world.setBlock(wx, top + 1, wz - 1, leaf)
          world.setBlock(wx, top + 1, wz + 1, leaf)
          world.setBlock(wx - 1, top + 1, wz, leaf)
        }
			}
		}
		getLight(x, y, z, block = 0) {
			let s = this.size
			let i = x * s * s + y * s + z
			return (this.light[i] & 15 << (block * 4)) >> (block * 4)
		}
		setLight(x, y, z, level, block = 0) {
			let s = this.size
			let i = x * s * s + y * s + z
			this.light[i] = level << (block * 4) | (this.light[i] & 15 << (!block * 4))
		}
	}
	let emptySection = new Section(0, 0, 0, 16)
	let fullSection = new Section(0, 0, 0, 16)
	fullSection.blocks.fill(blockIds.bedrock)
	emptySection.light.fill(15)

	class Chunk {
		constructor(x, z, type) {
			this.x = x
			this.z = z
			this.maxY = 0
			this.minY = 255
			this.sections = []
			this.cleanSections = []
			this.tops = new Uint8Array(16 * 16) // Store the heighest block at every (x,z) coordinate
			this.optimized = false
			this.generated = false; // Terrain
			this.populated = superflat === true // Trees and ores
			this.lit = false
			this.lazy = false
			this.edited = false
			this.loaded = false
      this.type = type || world.type
			// vao for this chunk
			this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			this.caves = !caves
		}
		getBlock(x, y, z) {
			let s = y >> 4
			return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0
		}
		setBlock(x, y, z, blockID, user) {
			if (!this.sections[y >> 4]) {
				do {
					this.sections.push(new Section(this.x, this.sections.length * 16, this.z, 16, this))
				} while (!this.sections[y >> 4])
			}
			if (user && !this.sections[y >> 4].edited) {
				this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
				this.sections[y >> 4].edited = true
				this.edited = true
			}
			this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
		}
		fillLight() {
			let max = this.sections.length * 16 - 1
			let blockSpread = []

			// Set virtical columns of light to level 15
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					let stop = false
					for (let y = max; y >= 0; y--) {
						let data = blockData[this.getBlock(x, y, z)]
						if (data.lightLevel) {
							if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
							blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
							this.setLight(x, y, z, data.lightLevel, 1)
						}
						if (!stop && !data.transparent) {
							this.tops[z * 16 + x] = y
							stop = true
						} else if (!stop) {
							this.setLight(x, y, z, 15, 0)
						}
					}
				}
			}

			// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
			let spread = []
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
						if (x === 15 || this.tops[z * 16 + x + 1] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (x === 0 || this.tops[z * 16 + x - 1] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (z === 15 || this.tops[(z + 1) * 16 + x] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (z === 0 || this.tops[(z - 1) * 16 + x] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						break
					}
				}
			}
			this.spreadLight(spread, 14)

			for (let i = blockSpread.length - 1; i > 0; i--) {
				let blocks = blockSpread[i]
				if (blocks && blocks.length) {
					this.spreadLight(blocks, i - 1, false, 1)
				}
			}

			this.lit = true
		}
		setLight(x, y, z, level, blockLight) {
			this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
		}
		getLight(x, y, z, blockLight = 0) {
			if (y >= this.sections.length * 16) return 15
      if(!this.sections[y >> 4]) return 0
			return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
		}
		trySpread(x, y, z, level, spread, blockLight, update = false) {
			if (world.getLight(x, y, z, blockLight) < level) {
				if (blockData[world.getBlock(x, y, z)].transparent) {
					world.setLight(x, y, z, level, blockLight)
					spread.push(x, y, z)
				}
			}
			if (update && (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15)) {
				let chunk = world.getChunk(x, z)
				if (chunk.buffer && !world.meshQueue.includes(chunk)) {
					world.meshQueue.push(chunk)
				}
			}
		}
		spreadLight(blocks, level, update = false, blockLight = 0) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
				this.trySpread(x - 1, y, z, level, spread, blockLight, update)
				this.trySpread(x + 1, y, z, level, spread, blockLight, update)
				this.trySpread(x, y - 1, z, level, spread, blockLight, update)
				this.trySpread(x, y + 1, z, level, spread, blockLight, update)
				this.trySpread(x, y, z - 1, level, spread, blockLight, update)
				this.trySpread(x, y, z + 1, level, spread, blockLight, update)
			}
			if (level > 1 && spread.length) {
				this.spreadLight(spread, level - 1, update, blockLight)
			}
		}
		tryUnSpread(x, y, z, level, spread, respread, blockLight) {
			let light = world.getLight(x, y, z, blockLight)
			let trans = blockData[world.getBlock(x, y, z)].transparent
			if (light === level) {
				if (trans) {
					world.setLight(x, y, z, 0, blockLight)
					spread.push(x, y, z)
				}
			} else if (light > level) {
				respread[light].push(x, y, z)
			}
			if (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15) {
				let chunk = world.getChunk(x, z)
				if (chunk.buffer && !world.meshQueue.includes(chunk)) {
					world.meshQueue.push(chunk)
				}
			}
		}
		unSpreadLight(blocks, level, respread, blockLight) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
				this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
			}
			if (level > 1 && spread.length) {
				this.unSpreadLight(spread, level - 1, respread, blockLight)
			}
		}
		reSpreadLight(respread, blockLight) {
			for (let i = respread.length - 1; i > 1; i--) {
				let blocks = respread[i]
				let level = i - 1
				let spread = respread[level]
				for (let j = 0; j < blocks.length; j += 3) {
					let x = blocks[j]
					let y = blocks[j+1]
					let z = blocks[j+2]
					this.trySpread(x - 1, y, z, level, spread, blockLight)
					this.trySpread(x + 1, y, z, level, spread, blockLight)
					this.trySpread(x, y - 1, z, level, spread, blockLight)
					this.trySpread(x, y + 1, z, level, spread, blockLight)
					this.trySpread(x, y, z - 1, level, spread, blockLight)
					this.trySpread(x, y, z + 1, level, spread, blockLight)
				}
			}
		}
		optimize() {
			for (let i = 0; i < this.sections.length; i++) {
				this.sections[i].optimize()
			}
			if (!world.meshQueue.includes(this)) {
				world.meshQueue.push(this)
			}
			this.optimized = true
		}
		render() {
			if (!this.buffer) {
				return
			}
			if (p.canSee(this.x, this.minY, this.z, this.maxY)) {
				renderedChunks++
				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
				gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
				glExtensions.vertex_array_object.bindVertexArrayOES(null)
			}
		}
		updateBlock(x, y, z, world, lazy, leaveMe) {
			if (this.buffer) {
				this.lazy = lazy
				if (this.sections.length > y >> 4) {
					this.sections[y >> 4].updateBlock(x, y & 15, z, world, leaveMe)
				}
			}
		}
		deleteBlock(x, y, z, user) {
			if (!this.sections[y >> 4]) {
				return
			}
			if (user && !this.sections[y >> 4].edited) {
				this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
				this.sections[y >> 4].edited = true
				this.edited = true
			}
			this.sections[y >> 4].deleteBlock(x, y & 15, z)
			this.minY = y < this.minY ? y : this.minY
			this.maxY = y > this.maxY ? y : this.maxY
		}
		carveCaves() {
			for (let i = 0; i < this.sections.length; i++) {
				if (!this.sections[i].caves) {
					this.sections[i].carveCaves()
					if (i + 1 >= this.sections.length) {
						this.caves = true
					}
					return
				}
			}
		}
		populate() {
      var flowers = [blockIds.flowerOftheValley, blockIds.poppy, blockIds.dandelion, 
                     blockIds.blueOrchid, blockIds.pinkTulip, blockIds.orangeTulip, blockIds.redTulip, blockIds.whiteTulip,
                     blockIds.azureBluet, blockIds.cornFlower, blockIds.purpleFlower, blockIds.witherRose,
                     blockIds.allium, blockIds.oxeyeDaisy,
                     blockIds.lilac, blockIds.roseBush, blockIds.peony,
                     blockIds.TallGrass]
      
			randomSeed(hash(this.x, this.z) * 210000000)
			let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false, topsi = 0, tall = 0
      let trueX = this.x, trueY = this.y, trueZ = this.z
      let biomeSmooth = generator.biomeSmooth;
			let biome = 0
      let type = world.type

			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					wx = this.x + i
					wz = this.z + k

					ground = this.tops[k * 16 + i]
          biome = superflat ? 0 : noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)

          let b = getNetherBiome(biome)
					if (trees && random() < 0.005 && type === "" && world.getBlock(i, ground, k) === blockIds.grass) {
            top = ground + floor(4.5 + random(2.5))
						rand = floor(random(4096))
						let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
            let leaf = blockIds.leaves
            let groundBlock = this.type === "nether" ? blockIds.netherrack : blockIds.dirt

						//Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, groundBlock)

						//Bottom leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 2, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 2, wz + z, leaf)
									}
								}
							}
						}

						//2nd layer leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 1, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 1, wz + z, leaf)
									}
								}
							}
						}

						//3rd layer leaves
						for (let x = -1; x <= 1; x++) {
							for (let z = -1; z <= 1; z++) {
								if (x || z) {
									if (x & z) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top, wz + z, leaf)
									}
								}
							}
						}

						//Top leaves
						world.spawnBlock(wx + 1, top + 1, wz, leaf)
						world.spawnBlock(wx, top + 1, wz - 1, leaf)
						world.spawnBlock(wx, top + 1, wz + 1, leaf)
						world.spawnBlock(wx - 1, top + 1, wz, leaf)
					}
          
          // Cactus
          if (random() < 0.01 && this.getBlock(i, ground, k) && biome > 0.5 && ground > 60 && this.type !== "nether") {
            top = ground + Math.floor(2.5 + random(1.5));
            rand = Math.floor(random(4096));
            let tree = blockIds.cactus | CACTUS;

            //Center
            for (let j = ground + 1; j <= top; j++) {
              this.setBlock(i, j, k, tree);
            }
            this.setBlock(i, ground, k, blockIds.sand);
          }
          
          var g = world.getBlock(i, ground, k)
          if (random() < 0.005 && type === "nether" && g !== blockIds.Lava && b !== 0){
            tall = floor(4.5 + random(2.5))
            if(floor(random(12)) === 1) tall *= 2
						top = ground + tall
						rand = floor(random(4096))
            let tree
            let leaf
            let groundBlock = blockIds.netherrack
            if(this.type === "nether"){
              if(b === 1){
                tree = blockIds.warpedStem
                leaf = blockIds.warpedWartBlock
              }else if(b === 2){
                tree = blockIds.crimsonStem
                leaf = blockIds.netherWartBlock
              }
            }
            
            //Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, groundBlock)
            
            //Shroomlight
            world.spawnBlock(wx + random(-1, 1), top - 1, wz + random(-1,1), blockIds.shroomlight)
            
            //Top leaves
            for(var x=-1; x<2; x++){
              for(var z=-1; z<2; z++){
                place = (x&1) && (z&1) ? rand & 1 : true
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top + 1, wz + z, leaf)
                }
              }
            }
            
            //layer 2 leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = (x===2 || x===-2) && (z===2 || z==-2) ? rand & 1 : true
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top, wz + z, leaf)
                }
              }
            }
            
            rand = floor(random(4096))
            //layer 1 leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = x===2 || x===-2 || z===2 || z==-2 ? !(rand & 1) : false
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top - 1, wz + z, leaf)
                }
              }
            }
            
            rand = floor(random(40964096))
            //drooping leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = x===2 || x===-2 || z===2 || z==-2
                rand >>>= 1
                if(place){
                  var h = rand & 4 && rand & 8 ? rand & 3 : 0
                  if(h){
                    world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
                    for(var y=0; y<h; y++){
                      world.spawnBlock(wx + x, top - 2 - y, wz + z, leaf)
                    }
                  }
                }
              }
            }
            
            if(b === 2){
              rand = floor(random(40964096))
              //vines
              for(var x=-2; x<3; x++){
                for(var z=-2; z<3; z++){
                  place = x===2 || x===-2 || z===2 || z==-2
                  rand >>>= 1
                  if(place){
                    var h = (rand & 4 && rand & 8) ? (rand & (tall-2)) - 1 : 0
                    if(h){
                      world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
                      for(var y=0; y<h; y++){
                        world.spawnBlock(wx + x, top - 2 - y, wz + z, blockIds.weepingVinesPlant)
                      }
                      world.spawnBlock(wx + x, top - 2 - h, wz + z, blockIds.weepingVines)
                    }
                  }
                }
              }
            }
            
          }
          
          //flowers and vines
          if (random() < 0.05 && this.getBlock(i, ground, k) === blockIds.grass) {
            var flower = flowers[Math.round(random(flowers.length-1))]
            world.spawnBlock(wx, ground+1, wz, flower);
          }
          var block = this.getBlock(i, ground, k)
          if(random() < 0.05){
            if(block === blockIds.crimsonNylium){
              world.spawnBlock(wx, ground+1, wz, blockIds.crimsonRoots);
            }else if(block === blockIds.warpedNylium){
              world.spawnBlock(wx, ground+1, wz, blockIds.warpedRoots);
            }
          }

          if(this.type === "nether"){
            let l
            for(l=0; l<16; l++){
              let x = random(0, 16)
              let y = random(10, 177)
              let z = random(0, 16)
              if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack){
                world.setBlock(wx+x,y,wz+z, blockIds.netherQuartzOre)
              }
            }
            
            for(l=0; l<10; l++){
              let x = random(0, 16)
              let y = random(10, 177)
              let z = random(0, 16)
              if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack){
                world.setBlock(wx+x,y,wz+z, blockIds.netherGoldOre)
              }
            }
          }else{
            // Blocks of each per chunk in Minecraft
            // Coal: 185.5
            // Iron: 111.5
            // Gold: 10.4
            // Redstone: 29.1
            // Diamond: 3.7
            // Lapis: 4.1
            ground -= 4

            if (random() < 3.7 / 256) {
              let y = random() * 16 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre)
              }
            }

            if (random() < 111.5 / 256) {
              let y = random() * 64 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre)
              }
            }

            if (random() < 185.5 / 256) {
              let y = random() * ground | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre)
              }
            }

            if (random() < 10.4 / 256) {
              let y = random() * 32 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre)
              }
            }

            if (random() < 29.1 / 256) {
              let y = random() * 16 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre)
              }
            }

            if (random() < 4.1 / 256) {
              let y = random() * 32 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre)
              }
            }
				  }
          
        }
			}

			this.populated = true
		}
		genMesh() {
			let start = performance.now()
			let barray = bigArray
			let index = 0
			for (let i = 0; i < this.sections.length; i++) {
				index = this.sections[i].genMesh(barray, index)
			}
			let arrayDone = performance.now()

			if (!this.buffer) {
				this.buffer = gl.createBuffer()
			}
			let data = barray.slice(0, index)

			let maxY = 0
			let minY = 255
			let y = 0
			for (let i = 1; i < data.length; i += 6) {
				y = data[i]
				maxY = max(maxY, y)
				minY = min(minY, y)
			}
			this.maxY = maxY
			this.minY = minY
			this.faces = data.length / 32
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
			gl.enableVertexAttribArray(glCache.aVertex)
			gl.enableVertexAttribArray(glCache.aTexture)
			gl.enableVertexAttribArray(glCache.aShadow)
			gl.enableVertexAttribArray(glCache.aSkylight)
			gl.enableVertexAttribArray(glCache.aBlocklight)
			gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 32, 0)
			gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 32, 12)
			gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 32, 20)
			gl.vertexAttribPointer(glCache.aSkylight, 1, gl.FLOAT, false, 32, 24)
			gl.vertexAttribPointer(glCache.aBlocklight, 1, gl.FLOAT, false, 32, 28)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			this.lazy = false
		}
		tick() {
			if (this.edited) {
				for (let i = 0; i < this.sections.length; i++) {
					if (this.sections[i].edited) {
						this.sections[i].tick()
					}
				}
			}
		}
		load() {
			let chunkX = this.x >> 4
			let chunkZ = this.z >> 4
			let load = null
			
			for (let i = 0; i < world.loadFrom.length; i++) {
				load = world.loadFrom[i]
				if (load.x === chunkX && load.z === chunkZ) {
					let y = load.y * 16
					for (let j in load.blocks) {
            if(blockData[load.blocks[j]]){ // if a block doesn't exsist, they won't be generated
						  world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j])
            }
					}
					world.loadFrom.splice(i--, 1)
				}
			}
			this.loaded = true
		}
	}

	class Contacts {
		constructor() {
			this.array = []
			this.size = 0
		}
		add(x, y, z, block) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
			}
			this.size++
		}
		clear() {
			this.size = 0
		}
	}

	class Entity {
		constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns) {
			this.x = x
			this.y = y
			this.z = z
			this.previousX = x
			this.previousY = y
			this.previousZ = z
			this.canStepX = true
			this.canStepY = true
			this.pitch = pitch
			this.yaw = yaw
			this.velx = velx
			this.vely = vely
			this.velz = velz
			this.width = width
			this.height = height
			this.depth = depth
      this.offsetY = 0
			this.contacts = new Contacts()
			this.lastUpdate = performance.now()
			this.onGround = false
			this.despawns = despawns
			this.spawn = this.lastUpdate
			this.canDespawn = false
			this.faces = faces
			this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
		updateVelocity(now) {
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt
			this.vely += -0.02 * dt
			if (this.vely < -1.5) {
				this.vely = -1.5
			}

			this.velz += (this.velz * 0.9 - this.velz) * dt
			this.velx += (this.velx * 0.9 - this.velx) * dt
			// this.vely += (this.vely * 0.9 - this.vely) * dt
		}
		collided(x, y, z, vx, vy, vz, block) {
			let verts = blockData[block].shape.verts
			let px = roundBits(this.x - this.width / 2 - x)
			let py = roundBits(this.y - this.height / 2 - y)
			let pz = roundBits(this.z - this.depth / 2 - z)
			let pxx = roundBits(this.x + this.width / 2 - x)
			let pyy = roundBits(this.y + this.height / 2 - y)
			let pzz = roundBits(this.z + this.depth / 2 - z)
			let minX, minY, minZ, maxX, maxY, maxZ, min, max

			//Top and bottom faces
			let faces = verts[0]
			if (vy <= 0) {
				faces = verts[1]
			}
			if (!vx && !vz) {
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minZ = min[2]
					max = face.max
					maxX = max[0]
					maxZ = max[2]
					if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
						if (vy <= 0) {
							this.onGround = true
							this.y = round((face[1] + y + this.height / 2) * 10000) / 10000
							this.vely = 0
							return false
						} else {
							return true
						}
					}
				}
				return false
			}

			//West and East faces
			if (vx < 0) {
				faces = verts[4]
			} else if (vx > 0) {
				faces = verts[5]
			}
			if (vx) {
				let col = false
				for (let face of faces) {
					min = face.min
					minZ = min[2]
					minY = min[1]
					max = face.max
					maxZ = max[2]
					maxY = max[1]
					if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
						if (maxY - py > 0.5) {
							this.canStepX = false
						}
						col = true
					}
				}
				return col
			}

			//South and North faces
			if (vz < 0) {
				faces = verts[2]
			} else if (vz > 0) {
				faces = verts[3]
			}
			if (vz) {
				let col = false
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minY = min[1]
					max = face.max
					maxX = max[0]
					maxY = max[1]
					if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
						if (maxY - py > 0.5) {
							this.canStepZ = false
						}
						col = true
					}
				}
				return col
			}
		}
		move(now) {
			let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null

			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = world.getBlock(x, y, z)
						if (block && blockData[block].solid) {
							this.contacts.add(x, y, z, block)
						}
					}
				}
			}
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt

			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z

			this.canStepX = false
			this.canStepY = false
			this.onGround = false
			//Check collisions in the Y direction
			this.y += this.vely * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, this.vely, 0, block[3])) {
					this.y = this.previousY
					this.vely = 0
					break
				}
			}

			if (this.y === this.previousY) {
				this.canStepX = true
				this.canStepZ = true
			}

			//Check collisions in the X direction
			this.x += this.velx * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], this.velx, 0, 0, block[3])) {
					if (this.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.x = this.previousX
					this.velx = 0
					break
				}
			}

			//Check collisions in the Z direction
			this.z += this.velz * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, 0, this.velz, block[3])) {
					if (this.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.z = this.previousZ
					this.velz = 0
					break
				}
			}

			this.lastUpdate = now
			this.contacts.clear()
		}
		update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
		}
		render() {
			const offsetY = this.offsetY
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y + offsetY, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1)
			const skysLight = world.getLight(x, y, z, 0) * (skyLight / 15)
			const lightLevel = min(max(skysLight, blockLight) * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
	}

	class Item extends Entity {
		constructor(x, y, z, velx, vely, velz, blockID) {
			const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
			super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      this.block = blockID
      this.type = "Item"
		}
    update() {
      let now = performance.now()
      this.yaw += 0.01;
      if(this.yaw > Math.PI*2){
        this.yaw -= Math.PI*2
      }
      
			this.updateVelocity(now)
		  this.move(now)
      
      let xDist = this.x - p.x
      let yDist = this.y - p.y
      let zDist = this.z - p.z
      let pickup = xDist > -1 && xDist < 1 && yDist > -1.5 && yDist < 1 && zDist > -1 && zDist < 1
      if(pickup){
        var dist = dist2(this.x, this.z, p.x, p.z)
        pickup = (1 >= dist) && (dist >= -1)
      }
      
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
        
			}
      if(pickup && newInvItem(this.block)){
        this.canDespawn = true
        updateHUD = true
      }
      
      this.offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
    }
	}
  win.Item = Item
  class BlockEntity extends Entity{
    constructor(blockID, x,y,z, solidOnGround, cacheBlocks){
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      super(x, y, z, 0, 0, 0, 0, 0, 0.996, 0.996, 0.996, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      this.block = blockID
      this.type = "BlockEntity"
      this.solidOnGround = solidOnGround
      this.cacheBlocks = cacheBlocks
      
      if(cacheBlocks){
        this.cached = {}
        this.cached[block] = {
          vertices:new Float32Array(shapeVerts.flat(Infinity)),
          texture:new Float32Array(texture),
          faces:size
        }
      }
    }
    changeBlock(blockID){
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture),
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      if(this.cacheBlocks){
        this.cached[block] = {
          vertices:new Float32Array(shapeVerts.flat(Infinity)),
          texture:new Float32Array(texture),
          faces:size
        }
      }
      //caches but isn't used
      
    }
    update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      if(this.onGround && this.solidOnGround){
        var x = round(this.x), y = round(this.y), z = round(this.z)
        var b = world.getBlock(x, y-1, z)
        if(blockData[b] && blockData[b].shape === shapes.cube){
          world.setBlock(x,y,z, this.block)
        }else{
          // non cube block breaks falling blocks
          world.addEntity(new Item(x,y,z, 0,0,0, this.block))
        }
        this.canDespawn = true
      }
		}
  }
  win.BlockEntity = BlockEntity
  
  //character is seen in 3rd person mode
  class Character extends Entity{
    constructor(blockID){
      const block = blockData[blockID & 255]
			const tex = block.textures
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
			super(0, 0, 0, 0, 0, 0, 0, 0, 0.6, 1.7, 0.6, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
    }
    update(){
      this.offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
    }
  }
  window.Player = Character
  var logged = false;
  //People, if you want cows, you need to put this in the console: world.entities.push(new Cow(p2.x, p2.y, p2.z))
  //I'm probaly not going to keep working on this.
  //Too hard
  class Cow extends Entity{
    constructor(x, y, z){
			const tex = ["cow","cow","cowSide","cowSide","cowSide","cowSide"]
			const shape = shapes.cow
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < blockSides.length; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      
      this.moveTime = 0
      this.dirx = 0
      this.dirz = 0
    }
    AI(now){
      let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt
      if(this.moveTime > 0){
        this.moveTime --
        this.velx += this.dirx / 100
        this.velz += this.dirz / 100
      }else if(Math.random()>0.8){
        this.yaw += (Math.random()>0.5 ? 0.05 : -0.05)
        if(this.yaw > Math.PI*2){
          this.yaw -= Math.PI*2
        }
        if(this.yaw < 0){
          this.yaw += Math.PI*2
        }
        this.dirx = Math.cos(this.yaw)
        this.dirz = -Math.sin(this.yaw)
        this.moveTime = Math.random()*240
      }
    }
    update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
      this.AI(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
		}
  }
  win.Cow = Cow

	let analytics = {
		totalTickTime: 0,
		worstFrameTime: 0,
		totalRenderTime: 0,
		totalFrameTime: 0,
		lastUpdate: 0,
		frames: 1,
		displayedTickTime: "0",
		displayedRenderTime: "0",
		displayedFrameTime: "0",
		displayedwFrameTime: 0,
		fps: 0,
	}
	function chunkDist(c) {
		let dx = p.x - c.x
		let dz = p.z - c.z
		if (dx > 16) {
			dx -= 16
		} else if (dx > 0) {
			dx = 0
		}
		if (dz > 16) {
			dz -= 16
		} else if (dz > 0) {
			dz = 0
		}
		return Math.sqrt(dx * dx + dz * dz)
	}
	function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
		let dx1 = p.x - c1.x - 8
		let dy1 = p.z - c1.z - 8
		let dx2 = p.x - c2.x - 8
		let dy2 = p.z - c2.z - 8
		return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
	}
	function fillReqs(x, z) {
		// Chunks must all be loaded first.
		var done = true
		for (let i = x - 3; i <= x + 3; i++) {
			for (let j = z - 3; j <= z + 3; j++) {
				let chunk = world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
				if (!chunk.generated) {
					world.generateQueue.push(chunk)
					done = false
				}
				if (!chunk.populated && i >= x - 2 && i <= x + 2 && j >= z - 2 && j <= z + 2) {
					world.populateQueue.push(chunk)
					done = false
				}
				if (world.loadFrom.length && !chunk.loaded && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.loadQueue.push(chunk)
					done = false
				} else if (!world.loadFrom.length && !chunk.loaded) {
					chunk.loaded = true
				}
				if (!chunk.lit && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.lightingQueue.push(chunk)
					done = false
				}
			}
		}
		return done
	}
	function maxDist(x, z, x2, z2) {
		let ax = abs(x2 - x)
		let az = abs(z2 - z)
		return max(ax, az)
	}
	function renderFilter(chunk) {
		return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= settings.renderDistance
	}

	function debug(message) {
		let ellapsed = performance.now() - debug.start
		if (ellapsed > 30) {
			console.log(message, ellapsed.toFixed(2), "milliseconds")
		}
	}
  
  function login(){
    return new Promise((resolve, reject) => {
      var w = open("https://www.guineapigbridge.repl.co/website/login.html", "_blank","width=100")
      function onmsg(event){
        if (event.source !== w) return;
        if (event.data.startsWith("logged:")){
          w.close()
          window.removeEventListener("message", onmsg);
          resolve(event.data.replace("logged:",''))
        }else if(event.data === "canceled"){
          w.close()
          window.removeEventListener("message", onmsg);
          reject()
        }
      }
      window.addEventListener("message", onmsg);
    })
  }

  var achexUsername = "player"+Date.now()
  win.username = ""
  async function loggedIn(){
    await fetch("https://server.guineapigbridge.repl.co/getuser", {credentials:"include"}).then(r => r.text()).then(r => logged=r)
    if(logged){
      username = logged
      return logged
    }else{
      if(confirm("Your not logged in. Head over to https://www.guineapigbridge.repl.co/website/login.html to login.")){
        var logged
        await login().then(r => logged=r).catch(r => logged=r)
        if(logged){
          username = logged
          return logged
        }
      }
      return false
      changeScene("main menu")
    }
  }
  async function getWorlds(){
    var logged = await loggedIn()
    if(!logged){
      return []
    }
    var worlds
    await fetch("https://server.guineapigbridge.repl.co/worlds").then(r => r.json()).then(r => worlds=r)
    return worlds
  }
  var multiplayer = null
  var players = {}
  win.players = players
  /*const hub = "Geekycraft"
  function sendHub(obj){
    let str = JSON.stringify({
      "toH": hub,
      "msg": JSON.stringify(obj)
    })
    multiplayer.send(str)
    return str
  }
  function sendUser(user, obj){
    let str = JSON.stringify({
      "to": user,
      "msg": JSON.stringify(obj)
    })
    multiplayer.send(str)
    return str
  }*/
  function send(msg, to){
    msg.FROM = achexUsername
    msg.USER = username
    if(to) msg.TO = to
    multiplayer.send(JSON.stringify(msg))
  }
  var host
  function initMultiplayer(target){
    if(multiplayer) return
    var ban = []
    host = false
    if(!target){
      target = world.id || 0
      host = true
    }
    players = {} //empty
    multiplayer = new WebSocket("wss://server.guineapigbridge.repl.co/ws?target="+target)
    multiplayer.onopen = e => {
			/*multiplayer.send(JSON.stringify({
        "auth": achexUsername,
        "passwd":"none"
      }))
      multiplayer.send(JSON.stringify({
        "joinHub":hub,
        "passwd":"none"
      }))*/
      send({
        "type":"connect",
        username: username,
        id: achexUsername
      })
      if(host){
        send({
          "type":"init",
          name: world.name
        })
      }
      send({
        "type":"getSave"
      })

      multiplayer.pos = setInterval(() => {
        if(world){
          send({type:"pos", data:p3, dimension: world.type})
          //if(host)send({type:"entityPos", data: world.getEntities(), dimension: world.type})
        }
      }, 500)
		}
		multiplayer.onmessage = msg => {
			let packet = JSON.parse(msg.data)
			var author = packet.FROM //should be the id
      var data = packet//.msg ? JSON.parse(packet.msg) : {}
      
      if(data.type === "getSave" && host){
        if(ban.includes(data.USER)){
          send({
            type: "ban",
            data: data.USER
          }, author)
        }else{
          send({
            type:"loadSave",
            data:world.getSaveString(),
            nether:world.getNetherSaveString(),
            mod: world.mod,
            id: world.id || Date.now(),
            dimension: world.type || "overworld"
          }, author)
        }
      }else if(data.type === "loadSave"){
        dimensions = {
          overworld: new World(),
          nether: new World("nether")
        }
        world = dimensions.overworld
        win.world = world

        world.id = data.id

        if (data.data) {
          try {
            world.loadSave(data.data)
          }catch(e) {
            alert("Unable to load save code")
            return
          }
        }
        if (data.nether) {
          let world = dimensions.nether
          try {
            world.loadSave(data.nether)
          }catch(e) {
            alert("Unable to load nether save code")
            return
          }
        }
        try{
          world.mod = data.mod
          mod = Object.constructor("return "+data.mod)()
        }catch(e){console.log("error loading mod: "+e)}
        if(survival){
          setHotbar([0,0,0,0,0,0,0,0,0])
        }
        world = dimensions[data.dimension || "overworld"]
        changeScene("loading")
      }else if(data.type === "pos"){
        var pos = data.data
        if(!players[author]){
          players[author] = new Player(abs( (pos.username || "").hashCode()) % 80 + 1)
        }
        let thisplayer = players[author]
        thisplayer.x = pos.x
        thisplayer.y = pos.y - 1
        thisplayer.z = pos.z
        thisplayer.yaw = pos.ry
        thisplayer.dimension = data.dimension
        if(thisplayer.username !== pos.username){
          thisplayer.username = pos.username
        }
      }else if(data.type === "dc"){
        delete players[data.data]
      }else if(data.type === "setBlock"){
        let pos = data.data
        let world = dimensions[pos.dimension]
        let prevBlock = world.getBlock(pos.x, pos.y, pos.z)
        world.setBlock(pos.x, pos.y, pos.z, pos.block, false, false, true)
        if(pos.block){
          if(!prevBlock){
            blockSound(pos.block, "place", pos.x, pos.y, pos.z)
          }
        }else{
          blockSound(prevBlock, "dig", pos.x, pos.y, pos.z)
        }
      }/*else if(data.type === "entityPos"){
        if(data.data){
          for(var i=0; i<data.data.length; i++){
            world.posEntity(data.data[i])
          }
        }else{
          world.posEntity(data)
        }
        //still needs to position it in the right dimension, not the current one
        //server needs to pass these to other players
      }else if(data.type === "entityDelete"){
        world.deleteEntity(data.id, true)
      }*/else if(data.type === "message"){
        Messages.write(data.data, data.username)
      }else if(data.type === "error"){
        alert(data.data)
      }
		}

		multiplayer.onclose = () => {
			alert("Connection lost!")
      clearInterval(multiplayer.pos)
      multiplayer = null
		}
		multiplayer.onerror = () => {
      multiplayer.close()
    }
    
    win.ban = username => {
      if(!host) return alert("Only the host can ban")
      send({
        type: "ban",
        data: username
      })
      if(!ban.includes(username)) ban.push(username)
    }
  }
  
  function getNetherBiome(biome) {
    if(biome > 0.4 && biome < 0.5){
      return 1
    }else if(biome > 0.4){
      return 2
    }
    return 0
  }
  function getDimension(){
    if(world.type === ""){
      return "overworld"
    }else return world.type
  }

  let skyLight = 0
	let fogDist = 16
	class World {
		constructor(type) {
			generatedChunks = 0
			fogDist = 16
			p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)

      this.type = type || ""
      this.spawnPoint = {
        x: 0,
        y: p.y,
        z: 0
      }

			//Initialize the world's arrays
			this.chunks = []
			this.loaded = []
			this.sortedChunks = []
			this.offsetX = 0
			this.offsetZ = 0
			this.lwidth = 0
			this.chunkGenQueue = []
			this.populateQueue = []
			this.generateQueue = []
			this.lightingQueue = []
			this.loadQueue = []
			this.meshQueue = []
			this.loadFrom = []
			this.entities = []
			this.lastChunk = ","
		}
		genChunk(chunk) {
			let x = chunk.x >> 4
			let z = chunk.z >> 4
			let trueX = chunk.x
			let trueZ = chunk.z

			if (chunk.generated) {
				return false
			}
			let hide = !loadString
			let smoothness = generator.smooth
			let hilliness = generator.height
      let biomeSmooth = generator.biomeSmooth
      //{ for the nether terrain
      const biomeSize = 1//0.001 // smaller = bigger
			const flatness = 40 // bigger = flatter
			const overhang = 3 // bigger = more overhang; flatter = less overhang
			const bottom = 4 // Minimum height of the ground
			const hillSize = 0.008 // smaller = bigger; 0.005 to 0.01 seems the be a reasonable range
      //}
			let gen = 0
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					gen = superflat === "island" && this.type === "" ? win.islandGenerator.GetHeight(x*16+i, z*16+k) : (superflat ? 4 : Math.round(noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra)
          if(this.type === "nether" && superflat){
            gen = Math.round(noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra
          }
					chunk.tops[k * 16 + i] = gen
          if(this.type === "nether"){
            let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
            let b = getNetherBiome(biome)
            let block = blockIds.netherrack
            if(b === 1){
              block = blockIds.warpedNylium
            }else if(b === 2){
              block = blockIds.crimsonNylium
            }
            const smo = noise((trueX + i) * biomeSize, (trueZ + k) * biomeSize) * flatness + 40
            let top = 0
            let solid = true
            for (let j = 1; j < 128; j++) {
              if (noise((trueX + i)/smo, overhang*j/smo, (trueZ + k)/smo) - (j - bottom) * hillSize > 0) {
                chunk.setBlock(i, j, k, blockIds.netherrack)
                top = j
                solid = true
              } else if (solid) {
                chunk.setBlock(i, j - 1, k, block)
                /*if (chunk.getBlock(i, j - 2, k)) chunk.setBlock(i, j - 2, k, block)
                if (chunk.getBlock(i, j - 3, k)) chunk.setBlock(i, j - 3, k, block)
                if (chunk.getBlock(i, j - 4, k)) chunk.setBlock(i, j - 4, k, block)*/
                solid = false
              } else if(j < 60){
                chunk.setBlock(i, j-1, k, blockIds.Lava)
                if(chunk.getBlock(i, j - 2, k) === block) chunk.setBlock(i, j-2, k, blockIds.netherrack)
              }
            }

            chunk.tops[k * 16 + i] = top
            chunk.setBlock(i, 0, k, blockIds.bedrock)
            
            block = blockIds.netherrack
            for(let j=1; j<gen; j++){
              chunk.setBlock(i, maxHeight - 50 - j, k, block)
            }
            chunk.setBlock(i,maxHeight-50,k, blockIds.bedrock)
          }else if (superflat === "island") {
                    if (win.islandGenerator.GetWaterDepth(x*16+i, z*16+k) > 0) {
                        chunk.setBlock(i, gen, k, blockIds.Water);
				        chunk.setBlock(i, gen - 1, k, blockIds.Water)
					    chunk.setBlock(i, gen - 2, k, blockIds.dirt)
					    chunk.setBlock(i, gen - 3, k, blockIds.dirt)
                    }   else {
                        let biomeHere =win.islandGenerator.GetBiomeType(x*16+i, z*16+k);
                        if (biomeHere === -3161286) {
                            chunk.setBlock(i, gen, k, blockIds.sand)
                            chunk.setBlock(i, gen - 1, k, blockIds.sand)
    					    chunk.setBlock(i, gen - 2, k, blockIds.sand)
    					    chunk.setBlock(i, gen - 3, k, blockIds.sand)
                        }   else if (biomeHere === -1) {
                            chunk.setBlock(i, gen, k, blockIds.whiteConcrete)
                            chunk.setBlock(i, gen - 1, k, blockIds.whiteConcrete)
    					    chunk.setBlock(i, gen - 2, k, blockIds.stone)
    					    chunk.setBlock(i, gen - 3, k, blockIds.stone)
                        }   else if (biomeHere === -4934476 || biomeHere === -8355712 || biomeHere === -6963874) {
                            chunk.setBlock(i, gen, k, blockIds.stone)
                            chunk.setBlock(i, gen - 1, k, blockIds.stone)
    					    chunk.setBlock(i, gen - 2, k, blockIds.stone)
    					    chunk.setBlock(i, gen - 3, k, blockIds.stone)
                        } else if (biomeHere === -65536) {
                            chunk.setBlock(i, gen, k, blockIds.Lava)
					        chunk.setBlock(i, gen - 1, k, blockIds.stone)
    					    chunk.setBlock(i, gen - 2, k, blockIds.stone)
    					    chunk.setBlock(i, gen - 3, k, blockIds.stone)
                        } else {
					        chunk.setBlock(i, gen, k, blockIds.grass)
					        chunk.setBlock(i, gen - 1, k, blockIds.dirt)
    					    chunk.setBlock(i, gen - 2, k, blockIds.dirt)
    					    chunk.setBlock(i, gen - 3, k, blockIds.dirt)
                        }
                    }
          } else if(superflat){
            chunk.tops[k * 16 + i] = gen;

            chunk.setBlock(i, gen, k, blockIds.grass);
            chunk.setBlock(i, gen - 1, k, blockIds.dirt);
            chunk.setBlock(i, gen - 2, k, blockIds.dirt);
            chunk.setBlock(i, gen - 3, k, blockIds.dirt);
          }else{
            let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth);
            if(biome > 0.25){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.sand);
              chunk.setBlock(i, gen - 1, k, blockIds.sand);
              chunk.setBlock(i, gen - 2, k, blockIds.sand);
              chunk.setBlock(i, gen - 3, k, blockIds.sand);
              if(gen<60) {
                    gen = 59;
                    chunk.setBlock(i, gen, k, blockIds.Water);
                    chunk.setBlock(i, gen - 1, k, blockIds.Water);
                    chunk.setBlock(i, gen - 2, k, blockIds.gravel);
                    chunk.setBlock(i, gen - 3, k, blockIds.gravel);
              }
              if(gen>120){
                  chunk.setBlock(i, gen, k, blockIds.stone);
              }
              if(gen>140){
                  chunk.setBlock(i, gen, k, blockIds.sand);
              }
            }

            if(biome < 0.5){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.grass);
              chunk.setBlock(i, gen - 1, k, blockIds.dirt);
              chunk.setBlock(i, gen - 2, k, blockIds.dirt);
              chunk.setBlock(i, gen - 3, k, blockIds.dirt);
              if(gen<60) {
                  gen = 59;
                  chunk.setBlock(i, gen, k, blockIds.Water);
                  chunk.setBlock(i, gen - 1, k, blockIds.Water);
                  chunk.setBlock(i, gen - 2, k, blockIds.gravel);
                  chunk.setBlock(i, gen - 3, k, blockIds.gravel);
              }
            }
          }
          if(this.type !== "nether"){
            for (let j = 1; j < gen - 3; j++) {
              chunk.setBlock(i, j, k, blockIds.stone)
            }
            chunk.setBlock(i, 0, k, blockIds.bedrock)
          }
				}
			}
			chunk.generated = true
		}
		getAdjacentSubchunks(x, y, z, lights) {
			let minChunkX = x - 16 >> 4
			let maxChunkX = x + 16 >> 4
			let minChunkY = y - 16 >> 4
			let maxChunkY = y + 16 >> 4
			let minChunkZ = z - 16 >> 4
			let maxChunkZ = z + 16 >> 4
			let section = null
			let ret = []
			for (x = minChunkX; x <= maxChunkX; x++) {
				for (let y = minChunkY; y <= maxChunkY; y++) {
					for (z = minChunkZ; z <= maxChunkZ; z++) {
						if (y < 0) {
							ret.push(lights ? fullSection.light : fullSection.blocks)
						} else if (this.chunks[x] && this.chunks[x][z]) {
							section = this.chunks[x][z].sections[y] || emptySection
							ret.push(lights ? section.light : section.blocks)
						} else {
							ret.push(lights ? emptySection.light : emptySection.blocks)
						}
					}
				}
			}
			return ret
		}
		updateBlock(x, y, z, lazy, leaveMe) {
			let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
			if (chunk && chunk.buffer) {
				chunk.updateBlock(x & 15, y, z & 15, this, lazy, leaveMe)
			}
		}
		getChunk(x, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			return this.loaded[X * this.lwidth + Z]
		}
		getWorldBlock(x, y, z) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return blockIds.air
			}
			return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15)
		}
		getBlock(x, y, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (y > maxHeight) {
				return blockIds.air
			} else if (y < 0) {
				return blockIds.bedrock
			} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
				return this.getWorldBlock(x, y, z)
			}
			return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15)
		}
		setBlock(x, y, z, blockID, lazy, leaveSelf, remote) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return
			}
			let chunk = this.chunks[x >> 4][z >> 4]

			let xm = x & 15
			let zm = z & 15
			if (blockID) {
				chunk.setBlock(xm, y, zm, blockID, !lazy)
				let data = blockData[blockID]
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, true, data.lightLevel)
				}
			} else {
				let data = blockData[chunk.getBlock(xm, y, zm)]
				chunk.deleteBlock(xm, y, zm, !lazy)
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, false, data.lightLevel)
				}
			}

			if (lazy) {
				return
			}
      if(multiplayer && !remote){
        send({type:"setBlock", data:{x:x, y:y, z:z, block:blockID, dimension:getDimension()}})
      }

			//Update the 6 adjacent blocks and 1 changed block
			if (xm && xm !== 15 && zm && zm !== 15) {
				chunk.updateBlock(xm - 1, y, zm, this, lazy)
				chunk.updateBlock(xm + 1, y, zm, this, lazy)
				chunk.updateBlock(xm, y - 1, zm, this, lazy)
				chunk.updateBlock(xm, y + 1, zm, this, lazy)
				chunk.updateBlock(xm, y, zm - 1, this, lazy)
				chunk.updateBlock(xm, y, zm + 1, this, lazy)
			}
			else {
				this.updateBlock(x - 1, y, z, lazy)
				this.updateBlock(x + 1, y, z, lazy)
				this.updateBlock(x, y - 1, z, lazy)
				this.updateBlock(x, y + 1, z, lazy)
				this.updateBlock(x, y, z - 1, lazy)
				this.updateBlock(x, y, z + 1, lazy)
			}

			chunk.updateBlock(xm, y, zm, this, lazy, leaveSelf)

			// Update the corner chunks so shadows in adjacent chunks update correctly
			if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy); }
			if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy); }
			if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy); }
			if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy); }
		}
		getLight(x, y, z, blockLight = 0) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
        if(this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]){
          return this.chunks[x >> 4][z >> 4].getLight(x & 15, y, z & 15, blockLight)
        }else return 0
			}
			return this.loaded[X * this.lwidth + Z].getLight(x & 15, y, z & 15, blockLight)
		}
		setLight(x, y, z, level, block) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			return this.loaded[X * this.lwidth + Z].setLight(x & 15, y, z & 15, level, block)
		}
		updateLight(x, y, z, place, blockLight = 0) {
			let chunk = this.getChunk(x, z)
			let cx = x & 15
			let cz = z & 15
			let center = chunk.getLight(cx, y, cz, 0)
			let blight = chunk.getLight(cx, y, cz, 1)
			let up = this.getLight(x, y+1, z)
			let down = this.getLight(x, y-1, z)
			let north = this.getLight(x, y, z+1)
			let south = this.getLight(x, y, z-1)
			let east = this.getLight(x+1, y, z)
			let west = this.getLight(x-1, y, z)

			let spread = []
			if (!place) { // Block was removed; increase light levels
				if ((up & 15) === 15) {
					for (let i = y; i > 0; i--) {
						if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 15)
							spread.push(x, i, z)
						} else {
							break
						}
					}
					chunk.spreadLight(spread, 14, true)
				} else {
					center = max(up, down, north, south, east, west)
					if (center > 0) center -= 1
					this.setLight(x, y, z, center)
					if (center > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, center - 1, true)
					}
				}

				// Block light levels
				if (!blockLight || blockLight < blight) {
					spread.length = 0
					up = this.getLight(x, y+1, z, 1)
					down = this.getLight(x, y-1, z, 1)
					north = this.getLight(x, y, z+1, 1)
					south = this.getLight(x, y, z-1, 1)
					east = this.getLight(x+1, y, z, 1)
					west = this.getLight(x-1, y, z, 1)
					blight = max(up, down, north, south, east, west)
					if (blight > 0) blight -= 1
					this.setLight(x, y, z, blight, 1)
					if (blight > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, blight - 1, true, 1)
					}
				}
			}
			else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
				let respread = []
				for (let i = 0; i <= center + 1; i++) respread[i] = []
				chunk.setLight(cx, y, cz, 0, 0)
				chunk.setLight(cx, y, cz, 0, 1)
				spread.push(x, y, z)

				// Sky light
				if (center === 15) {
					for (let i = y-1; i > 0; i--) {
						if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 0)
							spread.push(x, i, z)
						} else {
							break
						}
					}
				}
				chunk.unSpreadLight(spread, center - 1, respread)
				chunk.reSpreadLight(respread)

				// Block light
				if (blight) {
					respread.length = 0
					for (let i = 0; i <= 15/*blight + 1*/; i++) respread[i] = []
					spread.length = 0
					spread.push(x, y, z)
					chunk.unSpreadLight(spread, blight - 1, respread, 1)
					chunk.reSpreadLight(respread, 1)
				}
			}
			if (place && blockLight) { // Light block was placed
				this.setLight(x, y, z, blockLight, 1)
				spread.length = 0
				spread.push(x, y, z)
				chunk.spreadLight(spread, blockLight - 1, true, 1)

			} else if (!place && blockLight) { // Light block was removed
				this.setLight(x, y, z, 0, 1)
				spread.push(x, y, z)
				let respread = []
				for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
				chunk.unSpreadLight(spread, blockLight - 1, respread, 1)
				chunk.reSpreadLight(respread, 1)
			}
		}
		spawnBlock(x, y, z, blockID) {
			//Sets a block anywhere without causing block updates around it. Only to be used in world gen.
      
      if(blockData[blockID].crossShape) blockID |= CROSS
      if(blockData[blockID].tallcrossShape) blockID |= TALLCROSS
      if(blockData[blockID].cactus) blockID |= CACTUS
      
			let chunkX = x >> 4
			let chunkZ = z >> 4
			if (!this.chunks[chunkX]) {
				this.chunks[chunkX] = []
			}
			let chunk = this.chunks[chunkX][chunkZ]
			if (!chunk) {
				chunk = new Chunk(chunkX * 16, chunkZ * 16)
				this.chunks[chunkX][chunkZ] = chunk
			}
			if (chunk.buffer) {
				//Only used if spawning a block post-gen
				this.setBlock(x, y, z, blockID, true)
			} else if (!chunk.getBlock(x & 15, y, z & 15)) {
				chunk.setBlock(x & 15, y, z & 15, blockID)
			}
		}
    getEntity(id){
      for(var i=0; i<this.entities.length; i++){
        if(this.entities[i].id === id){
          return i
        }
      }
    }
    addEntity(ent, remote){
      ent.id = Date.now()
      if(multiplayer && !remote){
        //host controls entities
        send({type:"entityPos", id:ent.id, entType:ent.type, pos:{x:ent.x, y:ent.y, z:ent.z, yaw:ent.yaw, pitch:ent.pitch, block:ent.block}})
        this.entities.push(ent)
      }else{
        this.entities.push(ent)
      }
    }
    deleteEntity(id, remote, i){
      i = (i || i===0) ? i : this.getEntity(id)
      if(!(i || i===0)) return
      var ent = this.entities[i]
      if(multiplayer && !remote){
        send({type:"entityDelete", id:ent.id})
      }
      this.entities.splice(i, 1)
    }
    posEntity(d){ //for multiplayer.onmessage only
      let p = d.pos
      var i = this.getEntity(d.id)
      var ent
      if(i || i===0){
        ent = this.entities[i]
      }else{
        switch(d.entType){
          case "Item":
            ent = new Item(0, 0, 0, 0, 0, 0, p.block)
            break
          case "BlockEntity":
            ent = new BlockEntity(p.block)
            break
          default:
            break
        }
        if(ent)this.addEntity(ent, true)
      }
      if(!ent) return
      ent.x = p.x
      ent.y = p.y
      ent.z = p.z
      ent.yaw = p.yaw
      ent.pitch = p.pitch
    }
    getEntities(){
      var arr = []
      this.entities.forEach(ent => {
        arr.push({
          id:ent.id,
          entType:ent.type,
          pos: {x:ent.x, y:ent.y, z:ent.z, yaw:ent.yaw, pitch:ent.pitch, block:ent.block}
        })
      })
      return arr
    }
		tick() {
			let tickStart = performance.now()
			let maxChunkX = (p.x >> 4) + settings.renderDistance
			let maxChunkZ = (p.z >> 4) + settings.renderDistance
			let chunk = maxChunkX + "," + maxChunkZ
			if (chunk !== this.lastChunk) {
				this.lastChunk = chunk
				this.loadChunks()
				this.chunkGenQueue.sort(sortChunks)
			}

			if (Key.leftMouse && !Key.control && p.lastBreak < Date.now() - 250 && screen === "play" && !survival) { // if survival breaking isn't instant
				changeWorldBlock(0)
			}
			if ((Key.rightMouse || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250 && !p.autoBuild) {
				newWorldBlock()
			}
			if (Key.leftMouse && p.autoBreak && !Key.control) {
				changeWorldBlock(0)
			}
      if ((Key.rightMouse || Key.leftMouse && Key.control) && p.autoBuild) {
				newWorldBlock()
			}

			for (let i = 0; i < this.sortedChunks.length; i++) {
				this.sortedChunks[i].tick()
			}

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.update()
				if (entity.canDespawn) {
					this.deleteEntity(0, false, i)
				}
			}
      updtPlayer()
      if(multiplayer){
        for(let i in players){
          players[i].update()
        }
      }

			do {
				let doneWork = false
				debug.start = performance.now()
				if (this.meshQueue.length) {
					// Update all chunk meshes.
					let len = this.meshQueue.length - 1
					do {
						this.meshQueue.pop().genMesh()
					} while(this.meshQueue.length)
					doneWork = true
					debug("Meshes")
				}

				if (this.generateQueue.length && !doneWork) {
					let chunk = this.generateQueue.pop()
					this.genChunk(chunk)
					doneWork = true
				}
				if (this.populateQueue.length && !doneWork) {
					let chunk = this.populateQueue[this.populateQueue.length - 1]
					if (!chunk.caves) {
						chunk.carveCaves()
						debug("Carve caves")
					} else if (!chunk.populated) {
						chunk.populate()
						this.populateQueue.pop()
					}
					doneWork = true
				}

				if (this.loadQueue.length && !doneWork) {
					this.loadQueue.pop().load()
					doneWork = true
					if (!this.loadQueue.length) {
						return
					}
				}
				if (this.lightingQueue.length && !doneWork) {
					this.lightingQueue.pop().fillLight()
					doneWork = true
				}

				if (this.chunkGenQueue.length && !doneWork) {
					let chunk = this.chunkGenQueue[0]
					if (!fillReqs(chunk.x >> 4, chunk.z >> 4)) {}
					else if (!chunk.optimized) {
						chunk.optimize(this)
						debug("Optimize")
					} else if (!chunk.buffer) {
						chunk.genMesh()
						debug("Initial mesh")
					} else {
						this.chunkGenQueue.shift()
						generatedChunks++
					}
					doneWork = true
				}
				if (!doneWork) {
					break
				}
			} while(performance.now() - tickStart < 5)
		}
		render() {
			initModelView(p)
      if(this.type === "nether"){
        skyLight = 0
        gl.clearColor(0, 0, 0, 1)
      }else{
			  skyLight = min(max(abs(Date.now() % 1200000 - 600000) / 60000 - 5, 0.1), 1)
        gl.clearColor(sky[0] * skyLight, sky[1] * skyLight, sky[2] * skyLight, 1)
      }
			gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)

			renderedChunks = 0

			let dist = (settings.renderDistance) * 16
			if (this.chunkGenQueue.length) {
				this.chunkGenQueue.sort(sortChunks)
				let chunk = this.chunkGenQueue[0]
				dist = min(dist, chunkDist(chunk))
			}
			if (dist !== fogDist) {
				if (fogDist < dist - 0.1) fogDist += (dist - fogDist) / 120
				else if (fogDist > dist + 0.1) fogDist += (dist - fogDist) / 30
				else fogDist = dist
			}
			gl.uniform3f(glCache.uPos, p.x, p.y, p.z)
			gl.uniform1f(glCache.uDist, fogDist)
			// this is interesting because uTime is not actually based on time
			// if you are going to change this to use actual time change line 4487 as well
			// since it depends on it
			gl.uniform1f(glCache.uTime, skyLight)
      gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])

			let c = this.sortedChunks
			for (let chunk of c) {
				chunk.render()
			}

			gl.uniform3f(glCache.uPos, 0, 0, 0)

			gl.useProgram(programEntity)

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.render()
			}
      if(multiplayer){
        for(let i in players){
          if(players[i].dimension === world.type) players[i].render()
        }
      }
      renderPlayer()

			gl.useProgram(program3D)

      if(crack.idx > -1 && survival){
        block2(crack.pos[0], crack.pos[1], crack.pos[2], 0, p, true)
      }
			if(hitBox.pos) {
				blockOutlines = true
				blockFill = false
				block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, p)
				blockOutlines = false
				blockFill = true
			}
      
		}
		loadChunks() {
			let renderDistance = settings.renderDistance + 3
			let cx = p.x >> 4
			let cz = p.z >> 4
			p.cx = cx
			p.cz = cz
			let minChunkX = cx - renderDistance
			let maxChunkX = cx + renderDistance
			let minChunkZ = cz - renderDistance
			let maxChunkZ = cz + renderDistance

			this.offsetX = -minChunkX
			this.offsetZ = -minChunkZ
			this.lwidth = renderDistance * 2 + 1
			this.chunkGenQueue.length = 0
			this.lightingQueue.length = 0
			this.populateQueue.length = 0
			this.generateQueue.length = 0

			if (this.loaded.length > this.lwidth * this.lwidth) {
				this.loaded.length = this.lwidth * this.lwidth
			}

			let i = 0
			for (let x = minChunkX; x <= maxChunkX; x++) {
				for (let z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk
					if (!this.chunks[x]) {
						this.chunks[x] = []
					}
					if (!this.chunks[x][z]) {
						chunk = new Chunk(x * 16, z * 16)
						if (maxDist(cx, cz, x, z) <= settings.renderDistance) {
							this.chunkGenQueue.push(chunk)
						}
						this.chunks[x][z] = chunk
					}
					chunk = this.chunks[x][z]
					if (!chunk.buffer && !this.chunkGenQueue.includes(chunk) && maxDist(cx, cz, x, z) <= settings.renderDistance) {
						this.chunkGenQueue.push(chunk)
					}
					this.loaded[i++] = chunk
				}
			}
			this.sortedChunks = this.loaded.filter(renderFilter)
			this.sortedChunks.sort(sortChunks)
		}
    getThisSaveString(){
      let world = this
      
      let edited = []
			for (let x in this.chunks) {
				for (let z in this.chunks[x]) {
					let chunk = this.chunks[x][z]
					if (chunk.edited) {
						for (let y = 0; y < chunk.sections.length; y++) {
							if (chunk.sections[y].edited) {
								edited.push([ chunk.sections[y], chunk.cleanSections[y] ])
							}
						}
					}
				}
			}

			let pallete = {}
			for (let chunks of edited) {
				let changes = false
				chunks[0].blocks.forEach((id, i) => {
					if (id !== chunks[1][i]) {
						pallete[id] = true
						changes = true
					}
				})
				if (!changes) {
					chunks[0].edited = false
				}
			}

			let blocks = Object.keys(pallete).map(n => Number(n))
			pallete = {}
			blocks.forEach((block, index) => pallete[block] = index)

			let rnd = round
			let options = p.flying | (superflat==="island" ? 2 : superflat) << 1 | p.spectator << 2 | caves << 3 | trees << 4 | survival << 5

			let str = world.name + ";" + worldSeed.toString(36) + ";"
				+ rnd(p.x).toString(36) + "," + rnd(p.y).toString(36) + "," + rnd(p.z).toString(36) + ","
				+ (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + "," + options.toString(36) + ";"
				+ (this.version || version) + ";"
				+ blocks.map(b => b.toString(36)).join(",") + ";"

			for (let i = 0; i < edited.length; i++) {
				if (!edited[i][0].edited) {
					continue
				}
				let real = edited[i][0]
				let blocks = real.blocks
				let original = edited[i][1]
				str += (real.x / 16).toString(36) + "," + (real.y / 16).toString(36) + "," + (real.z / 16).toString(36) + ","
				for (let j = 0; j < original.length; j++) {
					if (blocks[j] !== original[j]) {
						str += (pallete[blocks[j]] << 12 | j).toString(36) + ","
					}
				}
				str = str.substr(0, str.length - 1); //Remove trailing comma
				str += ";"
			}
			if (str.match(/;$/)) str = str.substr(0, str.length - 1)
      
			return str
    }
		getSaveString() {
      let world = this
      if(this.type !== "") world = dimensions.overworld //save overworld
      
			return world.getThisSaveString()
		}
    getNetherSaveString(){
      let world = this
      if(this.type !== "nether") world = dimensions.nether //save nether
      
			return world.getThisSaveString()
    }
    getInv(){
      let str = ""
      let arr = []
      for(let i=0; i<inventory.hotbar.length; i++){
        if(inventory.hotbar[i]){
          arr.push(inventory.hotbar[i].id)
          arr.push(inventory.hotbar[i].amount)
        }else{
          arr.push(0)
          arr.push(0)
        }
      }
      str += arr.join(",") + "|"
      arr = []
      for(i=0; i<invItems.length; i++){
        if(invItems[i]){
          arr.push(invItems[i].id)
          arr.push(invItems[i].amount)
        }else{
          arr.push(0)
          arr.push(0)
        }
      }
      str += arr.join(",")
      return str
    }
    getSurvivStr(){
      //survival stuff like player health
      let str = ""
      str += p.health + ","
      str += witherEffect + ","
      str += witherTime + ","
      str += witherDamage + ","
      str += world.spawnPoint.x + "," + world.spawnPoint.y + "," + world.spawnPoint.z
      return str
    }
		loadSave(str) {
			let data = str.split(";")
			if (!str.includes("Alpha")) {
				return this.loadOldSave(str)
			}

			this.name = data.shift()
			worldSeed = parseInt(data.shift(), 36)
			seedHash(worldSeed)
			caveNoise = openSimplexNoise(worldSeed)
			noiseProfile.noiseSeed(worldSeed)

			let playerData = data.shift().split(",")
			p.x = parseInt(playerData[0], 36)
			p.y = parseInt(playerData[1], 36)
			p.z = parseInt(playerData[2], 36)
			p.rx = parseInt(playerData[3], 36) / 100
			p.ry = parseInt(playerData[4], 36) / 100
			let options = parseInt(playerData[5], 36)
			p.flying = options & 1
			p.spectator = options >> 2 & 1
			superflat = options >> 1 & 3
      if(superflat === 0){superflat = false}
      if(superflat === 1){superflat = true}
      if(superflat === 2){superflat = "island"}
			caves = options >> 3 & 1
			trees = options >> 4 & 1
      survival = (options >> 5 & 1) ? true : false

			let version = data.shift()
			this.version = version

			// if (version.split(" ")[1].split(".").join("") < 70) {
			// 	alert("This save code is for an older version. 0.7.0 or later is needed")
			// }

			let pallete = data.shift().split(",").map(n => parseInt(n, 36))
			this.loadFrom = []

			for (let i = 0; data.length; i++) {
				let blocks = data.shift().split(",")
				this.loadFrom.push({
					x: parseInt(blocks.shift(), 36),
					y: parseInt(blocks.shift(), 36),
					z: parseInt(blocks.shift(), 36),
					blocks: [],
				})
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36)
					let index = block & 0xffffff
					let pid = block >> 12
					this.loadFrom[i].blocks[index] = pallete[pid]
				}
			}
		}
    loadInv(str){
      let arr = str.split("|")
      let inv = arr[1].split(",")
      let hotb = arr[0].split(",")
      
      let len = inventory.hotbar.length
      inventory.hotbar = []
      for(let i=0; i<len*2; i+=2){
        if(hotb[i]){
          inventory.hotbar.push({
            id: parseInt(hotb[i]),
            amount: parseInt(hotb[i+1])
          })
        }else inventory.hotbar.push(0)
      }
      invItems = []
      for(let i=0; i<inv.length; i+=2){
        invItems.push({
          id: parseInt(inv[i]),
          amount: parseInt(inv[i+1])
        })
      }
    }
    loadSurvivStr(str){
      let arr = str.split(",")
      p.health = parseInt(arr[0])
      witherEffect = parseInt(arr[1])
      witherTime = parseInt(arr[2])
      witherDamage = parseInt(arr[3])
      world.spawnPoint.x = parseInt(arr[4]) || 0
      world.spawnPoint.y = parseInt(arr[5]) || 0
      world.spawnPoint.z = parseInt(arr[6]) || 0
    }
		loadOldSave(str) {
			let data = str.split(";");
			worldSeed = parseInt(data.shift(), 36);
			this.id = Date.now()
			this.name = "Old World " + (Math.random() * 1000 | 0)
			seedHash(worldSeed);
			caveNoise = openSimplexNoise(worldSeed);
			noiseProfile.noiseSeed(worldSeed);
			let playerData = data.shift().split(",");
			p.x = parseInt(playerData[0], 36);
			p.y = parseInt(playerData[1], 36);
			p.z = parseInt(playerData[2], 36);
			p.rx = parseInt(playerData[3], 36) / 100;
			p.ry = parseInt(playerData[4], 36) / 100;
			let editCount = parseInt(data.shift(), 36);

			this.loadFrom = [];

			let coords = data.shift().split(",").map(function(n) {
				return parseInt(n, 36);
			});
			for (let j = 0; j < coords.length; j += 3) {
				this.loadFrom.push({
					x: coords[j],
					y: coords[j + 1],
					z: coords[j + 2],
					blocks: [],
				})
			}

			for (let i = 0; data.length > 0; i++) {
				let blocks = data.shift().split(",");
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36);
					let index = block >> 8;
					let id = block & 0x7f | (block & 0x80) << 1;
					this.loadFrom[i].blocks[index] = id;
				}
			}
		}
	}
  win.World = World

	let defineWorld = function() {
		let tickStart = performance.now()
		world.tick()
		analytics.totalTickTime += performance.now() - tickStart
		let renderStart = performance.now()
    p2.x = round(p.x)
	  p2.y = round(p.y)
		p2.z = round(p.z)
    p3.x = p.x
    p3.y = p.y
    p3.z = p.z
    p3.ry = p.ry
    p3.survival = survival
    p3.username = username || ""
    let prevX
    let prevY
    let prevZ
    let prevRotX
    let prevRotY
    if(p.thirdPerson){
      prevX = p.x
      prevY = p.y
      prevZ = p.z
      prevRotX = p.rx
      prevRotY = p.ry
      /*p.rx += Math.PI
      p.ry += Math.PI*/ //third person back, not front
      var n = getRotation(p.rx-Math.PI2, p.ry-Math.PI2)
      p.x -= n.x * 4
      p.y -= n.y * 4
      p.z -= n.z * 4
    }
		world.render(prevX, prevY, prevZ, prevRotX, prevRotY)
    if(p.thirdPerson){
      p.x = prevX
      p.y = prevY
      p.z = prevZ
      p.rx = prevRotX
      p.ry = prevRotY
    }
		analytics.totalRenderTime += performance.now() - renderStart
	}
  
  let renderPlayer = function(){
    if(!p.thirdPerson) return
    
    p.character.render()
  }
  let updtPlayer = function(){
    p.character.x = p.x
    p.character.y = p.y
    p.character.z = p.z
    
    p.character.update()
  }

	let controls = function() {
		move.x = 0
		move.z = 0
		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt

		if(Key.w) move.z += p.speed
		if(Key.s) move.z -= p.speed
		if(Key.a) move.x += p.speed
		if(Key.d) move.x -= p.speed
		if (p.flying) {
			if(Key[" "]) p.velocity.y += 0.06 * dt
			if(Key.shift) p.velocity.y -= 0.06 * dt
		}
		if(Key.arrowleft) p.ry -= 0.1 * dt
		if(Key.arrowright) p.ry += 0.1 * dt
		if(Key.arrowup) p.rx += 0.1 * dt
		if(Key.arrowdown) p.rx -= 0.1 * dt

		if (!p.sprinting && Key.q && !p.sneaking && Key.w) {
			p.FOV(settings.fov + 10, 250)
			p.sprinting = true
		}

		if(p.sprinting) {
			move.x *= p.sprintSpeed
			move.z *= p.sprintSpeed
		}
		if(p.flying) {
			move.x *= p.flySpeed
			move.z *= p.flySpeed
		}
		if (!move.x && !move.z) {
			if (p.sprinting) {
				p.FOV(settings.fov, 100)
			}
			p.sprinting = false
		} else if(abs(move.x) > 0 && abs(move.z) > 0) {
			move.x *= move.ang
			move.z *= move.ang
		}

		//Update the velocity, rather than the position.
		let co = cos(p.ry)
		let si = sin(p.ry)
		let friction = p.onGround ? 1 : 0.3
		p.velocity.x += (co * move.x - si * move.z) * friction * dt
		p.velocity.z += (si * move.x + co * move.z) * friction * dt

		const TAU = Math.PI * 2
		const PI1_2 = Math.PI / 2
		while(p.ry > TAU) p.ry -= TAU
		while(p.ry < 0)   p.ry += TAU
		if(p.rx > PI1_2)  p.rx = PI1_2
		if(p.rx < -PI1_2) p.rx = -PI1_2

		p.setDirection()
	}

	// Mouse sensitivity variable, used for the settings buttons and in the "mmoved" function
	let mouseS = 300

	class Slider {
		constructor(x, y, w, h, scenes, label, min, max, settingName, callback) {
			this.x = x
			this.y = y
			this.h = h
			this.w = Math.max(w, 350)
			this.name = settingName
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.label = label
			this.min = min
			this.max = max
			this.sliding = false
			this.callback = callback
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let current = (settings[this.name] - this.min) / (this.max - this.min)

			// Outline
			ctx.beginPath()
			strokeWeight(2)
			stroke(0)
			fill(85)
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			ctx.stroke()
			ctx.fill()

			// Slider bar
			let value = round(settings[this.name])
			ctx.beginPath()
			fill(130)
			let x = this.x - (this.w - 10) / 2 + (this.w - 10) * current - 5
			ctx.fillRect(x, this.y - this.h / 2, 10, this.h)

			//Label
			fill(255, 255, 255)
			textSize(16)
			ctx.textAlign = 'center'
			text(`${this.label}: ${value}`, this.x, this.y + this.h / 8)
		}
		click() {
			if (!mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2) {
				let current = (mouseX - this.x + this.w / 2) / this.w
				if (current < 0) current = 0
				if (current > 1) current = 1
				this.sliding = true
				settings[this.name] = current * (this.max - this.min) + this.min
				this.callback(current * (this.max - this.min) + this.min)
				this.draw()
			}
		}
		drag() {
			if (!this.sliding || !this.scenes.includes(screen)) {
				return false
			}

			let current = (mouseX - this.x + this.w / 2) / this.w
			if (current < 0) current = 0
			if (current > 1) current = 1
			settings[this.name] = current * (this.max - this.min) + this.min
			this.callback(current * (this.max - this.min) + this.min)
		}
		release() {
			this.sliding = false
		}

		static draw() {
			for (let slider of Slider.all) {
				slider.draw()
			}
		}
		static click() {
			for (let slider of Slider.all) {
				slider.click()
			}
		}
		static release() {
			for (let slider of Slider.all) {
				slider.release()
			}
		}
		static drag() {
			if (mouseDown) {
				for (let slider of Slider.all) {
					slider.drag()
				}
			}
		}
		static add(x, y, w, h, scenes, label, min, max, defaut, callback) {
			Slider.all.push(new Slider(x, y, w, h, scenes, label, min, max, defaut, callback))
		}
	}
	Slider.all = []
	class Button {
		constructor(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			this.x = x
			this.y = y
			this.h = h
			this.w = w
			this.index = 0
			this.disabled = disabled || (() => false)
			this.hoverText = !hoverText || typeof hoverText === "string" ? (() => hoverText) : hoverText
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.labels = Array.isArray(labels) ? labels : [labels]
			this.callback = callback
		}

		mouseIsOver() {
			return mouseX >= this.x - this.w / 2 && mouseX <= this.x + this.w / 2 && mouseY >= this.y - this.h / 2 && mouseY <= this.y + this.h / 2
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let hovering = this.mouseIsOver()
			let disabled = this.disabled()
			let hoverText = this.hoverText()

			// Outline
			ctx.beginPath()
			
			strokeWeight(6)
      stroke(80)
			if (disabled) {
				fill(60)
				stroke(20)
			} else {
				if (hovering) {
    				cursor(HAND)
    				fill(100, 120, 200)
    				stroke(100,80,160)
    		}else{
    		    fill(120)
    		}
			}
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			
			ctx.stroke()
			ctx.fill()
			
			ctx.beginPath()
			stroke(200)
			if (hovering && !disabled)stroke(200, 200, 255);
			if(disabled)stroke(130);
			strokeWeight(3.5)
			if(disabled){
			    ctx.moveTo(this.x + (this.w / 2) + 2, this.y - this.h / 2-2)
    			ctx.lineTo(this.x + (this.w / 2) + 2, this.y + (this.h / 2)+1)
    			ctx.lineTo(this.x - this.w / 2 - 1, this.y + (this.h / 2)+1)
			}else{
    			ctx.moveTo(this.x - this.w / 2 - 2, this.y + (this.h / 2)-2)
    			ctx.lineTo(this.x - this.w / 2 - 2, this.y - this.h / 2-2)
    			ctx.lineTo(this.x + (this.w / 2)+1, this.y - this.h / 2-2)
			}
			ctx.stroke()

            stroke(0)
            strokeWeight(1)
            ctx.strokeRect(this.x-this.w/2-4, this.y-this.h/2-4, this.w+8, this.h+8)

			//Label
			textSize(16)
			ctx.textAlign = 'center'
			fill(0)
			text(this.labels[this.index], this.x +2, this.y + this.h / 8 +2)
			disabled ? fill(255) : (hovering ? fill(255,255,0) : fill(255) )
			text(this.labels[this.index], this.x, this.y + this.h / 8)
			
			if (hovering && hoverText) {
				hoverbox.innerText = hoverText
				hoverbox.classList.remove("hidden")
				if (mouseY < height / 2) {
					hoverbox.style.bottom = ""
					hoverbox.style.top = mouseY + 10 + "px"
				} else {
					hoverbox.style.top = ""
					hoverbox.style.bottom = height - mouseY + 10 + "px"
				}
				if (mouseX < width / 2) {
					hoverbox.style.right = ""
					hoverbox.style.left = mouseX + 10 + "px"
				} else {
					hoverbox.style.left = ""
					hoverbox.style.right = width - mouseX + 10 + "px"
				}
			}
		}
		click() {
			if (this.disabled() || !mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (this.mouseIsOver()) {
				this.index = (this.index + 1) % this.labels.length
				this.callback(this.labels[this.index])
				return true
			}
		}

		static draw() {
			hoverbox.classList.add("hidden")
			for (let button of Button.all) {
				button.draw()
			}
		}
		static click() {
			for (let button of Button.all) {
				if (button.click()) {
					Button.draw()
          playSound("click")
					break
				}
			}
		}
		static add(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			Button.all.push(new Button(x, y, w, h, labels, scenes, callback, disabled, hoverText))
		}
	}
	Button.all = []

	var initEverything
	function initButtons() {
		Button.all = []
		Slider.all = []
		const nothing = () => false
		const always = () => true

		// Main menu buttons
		Button.add(width / 2, height / 2 - 20, 400, 40, "Singleplayer", "main menu", r => changeScene("loadsave menu"))
if(!touchScreen){		
Button.add(width / 2, height / 2 + 35, 400, 40, "Multiplayer", "main menu", r => {
      changeScene("multiplayer menu")
      initServersMenu()
    }, null, "If you want multiplayer, why don't you contact your friends?")

		Button.add(width / 2, height / 2 + 90, 400, 40, "Options", "main menu", r => changeScene("options"))
    Button.add(width / 2, height / 2 + 145, 400, 40, "Marketplace", "main menu", r => changeScene("marketplace"))
}
if(touchScreen){
	Button.add(width / 2, height / 2 + 35, 400, 40, "Options", "main menu", r => changeScene("options"))
    Button.add(width / 2, height / 2 + 90, 400, 40, "Marketplace", "main menu", r => changeScene("marketplace"))
}
		// Creation menu buttons
		if(!touchScreen){
		Button.add(width / 2, 225, 300, 40, ["World Type: Normal", "World Type: Superflat", "World Type: Island"], "creation menu", r => {superflat = r === "World Type: Superflat"; if(r==="World Type: Island")superflat="island"})
		Button.add(width / 2, 275, 300, 40, ["Trees: On", "Trees: Off"], "creation menu", r => trees = r === "Trees: On", function() {
			if (superflat === true) {
				this.index = 1
				trees = false
			}
			return superflat === true
		})
		Button.add(width / 2, 325, 300, 40, ["Caves: On", "Caves: Off"], "creation menu", r => caves = r === "Caves: On", function() {
			if (superflat === true) {
				this.index = 1
				caves = false
			}
			return superflat === true
		})
		Button.add(width / 2, 375, 300,40, ["Game Mode: Creative", "Game Mode: Survival"], "creation menu", r => survival = r === "Game Mode: Survival")
		Button.add(width / 2, 425, 300, 40, "Difficulty: Peaceful", "creation menu", nothing, always, "Coming soon\n\nPlease stop asking for mobs. Adding them will take a very long time. I know a lot of people want them, so just be patient.")
		Button.add(width / 2, 475, 300, 40, "Create New World", "creation menu", r => {
      dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			world.id = Date.now()
			let name = boxCenterTop.value || "World"
			let number = ""
			while(true) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				} else {
					name = name + number
					break
				}
			}
			world.name = name.replace(/;/g, "\u037e")
			win.world = world
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)

      if(survival) setHotbar([blockIds.craftingTable,0,0,0,0,0,0,0,0])
			changeScene("loading")
		})
		Button.add(width / 2, 525, 300, 40, "Cancel", "creation menu", r => changeScene(previousScreen))
		}
		if(touchScreen){
			Button.add(width / 2, 225, 300, 40, "Create New World", "creation menu", r => {
      dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			world.id = Date.now()
			let name = boxCenterTop.value || "World"
			let number = ""
			while(true) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				} else {
					name = name + number
					break
				}
			}
			world.name = name.replace(/;/g, "\u037e")
			win.world = world
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)

      if(survival) setHotbar([blockIds.craftingTable,0,0,0,0,0,0,0,0])
			changeScene("loading")
		})
		Button.add(width / 2, 275, 300, 40, "Cancel", "creation menu", r => changeScene(previousScreen))
		}
		// Loadsave menu buttons
		const selected = () => !selectedWorld || !worlds[selectedWorld]
		let w4 = min(width / 4 - 10, 220)
		let x4 = w4 / 2 + 5
		let w2 = min(width / 2 - 10, 450)
		let x2 = w2 / 2 + 5
		let mid = width / 2
		Button.add(mid - 3 * x4, height - 30, w4, 40, "Edit", "loadsave menu", r => changeScene("editworld"), () => (selected() || !worlds[selectedWorld].edited))
		Button.add(mid - x4, height - 30, w4, 40, "Delete", "loadsave menu", r => {
			if (worlds[selectedWorld] && confirm(`Are you sure you want to delete ${worlds[selectedWorld].name}?`)) {
				deleteFromDB(selectedWorld)
				window.worlds.removeChild(document.getElementById(selectedWorld))
				delete worlds[selectedWorld]
				selectedWorld = 0
			}
		}, () => (selected() || !worlds[selectedWorld].edited), "Delete the world forever.")
		Button.add(mid + x4, height - 30, w4, 40, "Export", "loadsave menu", r => {
			boxCenterTop.value = worlds[selectedWorld].code
		}, selected, "Export the save code into the text box above for copy/paste.")
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "loadsave menu", r => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "loadsave menu", r => {
			dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			win.world = world

			let code
      let inv
      let surviv
      let mod
      let nether
			if (!selectedWorld) {
				code = boxCenterTop.value
			} else {
				let data = worlds[selectedWorld]
				if (data) {
					code = data.code
					world.id = data.id
					world.edited = data.edited
          inv = data.inv
          surviv = data.surviv
          nether = data.nether
          try{
            world.mod = data.mod
            mod = Object.constructor("return "+data.mod)()
          }catch(e){console.log("error loading mod: "+e)}
				}
			}
			
			if (code) {
				try {
					world.loadSave(code)
					world.id = world.id || Date.now()
				}
				catch(e) {
					alert("Unable to load save")
					return
				}
			}
      if (nether) {
        let world = dimensions.nether
				try {
					world.loadSave(nether)
					world.id = world.id || Date.now()
				}
				catch(e) {
					alert("Unable to load save")
					return
				}
			}
      if(inv){
        world.loadInv(inv)
      }else if(survival) setHotbar([blockIds.craftingTable,0,0,0,0,0,0,0,0])
      if(surviv) world.loadSurvivStr(surviv)
      if(mod){
        try{mod()}catch(e){console.log(e)}
      }
      changeScene("loading")
		}, () => !(!selectedWorld && boxCenterTop.value) && !worlds[selectedWorld])
		Button.add(mid + x2, height - 75, w2, 40, "Create New World", "loadsave menu", r => changeScene("creation menu"))

    // Edit world menu
		Button.add(mid, height / 2, w2, 40, "Save", "editworld", r => {
			let w = worlds[selectedWorld]
			w.name = boxCenterTop.value.replace(/;/g, "\u037e")
			let split = w.code.split(";")
			split[0] = w.name
			w.code = split.join(";")
      saveToDB(w.id, w).then(success => {
				initWorldsMenu()
				changeScene("loadsave menu")
			}).catch(e => console.error(e))
		})
		Button.add(mid, height / 2 + 50, w2, 40, "Back", "editworld", r => changeScene(previousScreen))
    
    // Multiplayer buttons
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "multiplayer menu", r => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "multiplayer menu", async() => {
      initMultiplayer(servers[selectedWorld].id)
    }, () => !servers[selectedWorld])

    //play buttons
    if(touchScreen){
      Button.add(mid-14, 14, 20,20, "/", "play", Messages.showInput)
      Button.add(mid+14, 14, 20,20, "❚❚", "play", r => changeScene("pause"))
    }

		// Pause buttons
    if(!touchScreen){
		Button.add(width / 2, 225, 300, 40, "Resume", "pause", play)
		Button.add(width / 2, 275, 300, 40, "Options", "pause", r => changeScene("options"))
		Button.add(width / 2, 325, 300, 40, "Save", "pause", save, nothing, () => `Save the world to your computer/browser. Doesn't work in incognito.\n\nLast saved ${timeString(Date.now() - world.edited)}.`)
		Button.add(width / 2, 375, 300, 40, "Get Save Code", "pause", r => {
			savebox.classList.remove("hidden")
			saveDirections.classList.remove("hidden")
			savebox.value = world.getSaveString()
		})
		Button.add(width / 2, 425, 300, 40, "Exit Without Saving", "pause", r => {
			savebox.value = world.getSaveString()
			initWorldsMenu()
      if(multiplayer) multiplayer.close()
			changeScene("main menu")
		})
    Button.add(width / 2, 475, 300, 40, "Enable multiplayer", "pause", async r => {
      var logged
      await loggedIn().then(r => logged = r)
      if(logged){
			  initMultiplayer()
      }
		}, () => multiplayer)
  }if(touchScreen){
    Button.add(width / 2, 225, 300, 40, "Resume", "pause", play)
		Button.add(width / 2, 275, 300, 40, "Options", "pause", r => changeScene("options"))
		Button.add(width / 2, 325, 300, 40, "Save", "pause", save, nothing, () => `Save the world to your computer/browser. Doesn't work in incognito.\n\nLast saved ${timeString(Date.now() - world.edited)}.`)
    Button.add(width / 2, 375, 300, 40, "Exit Without Saving", "pause", r => {
			savebox.value = world.getSaveString()
			initWorldsMenu()
      if(multiplayer) multiplayer.close()
			changeScene("main menu")
		})
  }
    // You Died buttons
    Button.add(width / 2, 225, 300, 40, "Respawn", "dead", r => {
      let spawn = world.spawnPoint
      
      p.x = spawn.x
      p.z = spawn.z
      /*p.y = 0
      while(world.getBlock(0, p.y, 0)){
        p.y ++;
        if(p.y > maxHeight) break;
      }*/
      p.y = spawn.y
      
      p.health = 18
      witherEffect = 0
      updateHUD = true
      play()
    })
		
		// Options buttons
		Button.add(width / 2, 430, width / 3, 40, ["Reach distance: "+normReach, "Reach distance: "+bigReach], "options", r => {
      if(r === "Reach distance: "+normReach){
        reach = normReach
      }else reach = bigReach
    })
    Button.add(width / 2, 500, width / 3, 40, ["Sound: On", "Sound: Off"], "options", r => soundOn = r === "Sound: On")
    Button.add(width / 2, 570, width / 3, 40, "Back", "options", r => changeScene(previousScreen))
    
    // Marketplace buttons
    Button.add(60, 40, 80, 30, "Back", "marketplace", r => changeScene(previousScreen))
		Button.add(mid - x2, height - 75, w2, 40, "Download", "marketplace", saveFromMarketplace, () => !marketplace[selectedWorld])
    
		// Comingsoon menu buttons
		Button.add(width / 2, 395, width / 3, 40, "Back", "comingsoon menu", r => changeScene(previousScreen))

		// Settings Sliders
		Slider.add(width/2, 245, width / 3, 40, "options", "Render Distance", 1, 32, "renderDistance", val => settings.renderDistance = round(val))
		Slider.add(width/2, 305, width / 3, 40, "options", "FOV", 30, 110, "fov", val => {
			p.FOV(val)
			if (world) {
				p.setDirection()
				world.render()
			}
		})
		Slider.add(width/2, 365, width / 3, 40, "options", "Mouse Sensitivity", 30, 400, "mouseSense", val => settings.mouseSense = val)
	}
	function initTextures() {
		let textureSize = 256
		let scale = 1 / 16
		let texturePixels = new Uint8Array(textureSize * textureSize * 4)
		textureMap = {}
		textureCoords = []

		setPixel = function(textureNum, x, y, r, g, b, a) {
			let texX = textureNum & 15
			let texY = textureNum >> 4
			let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4
			texturePixels[offset] = r
			texturePixels[offset + 1] = g
			texturePixels[offset + 2] = b
			texturePixels[offset + 3] = a !== undefined ? a : 255
		}
		getPixels = function(str) {
			// var w = parseInt(str.substr(0, 2), 36)
			// var h = parseInt(str.substr(2, 2), 36)
			var colors = []
			var pixels = []
			var dCount = 0
			for (;str[4 + dCount] === "0"; dCount++) {}
			var ccount = parseInt(str.substr(4+dCount, dCount+1), 36)
			for (var i = 0; i < ccount; i++) {
				var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36)
				colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ])
			}
			for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
				let num = parseInt(str[i], 36)
				pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3])
			}
			return pixels
		};

		{
      //get amount of textures
      var t = 0
      for(var i in textures) t++
      t = Math.ceil(t / 16) * 16
      
			// Specify the texture coords for each index
			const s = scale
			for (let i = 0; i < t; i++) {
				let texX = i & 15
				let texY = i >> 4
				let offsetX = texX * s
				let offsetY = texY * s
				textureCoords.push(new Float32Array([ offsetX, offsetY, offsetX + s, offsetY, offsetX + s, offsetY + s, offsetX, offsetY + s ]))
			}

			// Set all of the textures into 1 big tiled texture
			let n = 0
			for (let i in textures) {
				if (typeof textures[i] === "function") {
					textures[i](n)
				} else if (typeof textures[i] === "string") {
					let pix = getPixels(textures[i])
					for (let j = 0; j < pix.length; j += 4) {
						setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3])
					}
				}
				textureMap[i] = n
				n++
			}

			//Set the hitbox texture to 1 pixel
			let arr = new Float32Array(192)
			for (let i = 0; i < 192; i += 2) {
				arr[i] = textureCoords[textureMap.hitbox][0] + 0.01
				arr[i + 1] = textureCoords[textureMap.hitbox][1] + 0.01
			}
			textureCoords[textureMap.hitbox] = arr
		}

		// Big texture with everything in it
		textureAtlas = gl.createTexture()
		gl.activeTexture(gl.TEXTURE0)
		gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		gl.uniform1i(glCache.uSampler, 0)

		// Dirt texture for the background
		let dirtPixels = new Uint8Array(getPixels(textures.dirt))
		dirtTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE1)
		gl.bindTexture(gl.TEXTURE_2D, dirtTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, dirtPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    // Netherrack texture for the background
		let netherPixels = new Uint8Array(getPixels(textures.netherrack))
		netherTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE2)
		gl.bindTexture(gl.TEXTURE_2D, netherTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, netherPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)

		genIcons()
	}
	function drawIcon(x, y, id) {
    if(!blockIcons[id]) return
    
		id = id < 0xff ? (id | blockMode) : id
		x =  x / (3 * height) - 0.1666 * width / height
		y = y / (3 * height) - 0.1666
		initModelView(null, x, y, 0, 0, 0)

		let buffer = blockIcons[id]
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
		gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 24, 0)
		gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 24, 12)
		gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 24, 20)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
		gl.drawElements(gl.TRIANGLES, blockIcons.lengths[id], gl.UNSIGNED_INT, 0)
	}

	function hotbar() {
		FOV(90)
    let s = inventory.size

    fill(255)
    ctx.font = "14px VT323"
    ctx.textAlign = "right"
		for(let i = 0; i < inventory.hotbar.length; i ++) {
      let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  let y = height - inventory.size
			if(inventory.hotbar[i].id) {
				drawIcon(x, y, inventory.hotbar[i].id)
        ctx.fillText(inventory.hotbar[i].amount, x+(s/2), y+(s/2))
			}
		}
    ctx.textAlign = "left"
	}
	function hud() {
		if (p.spectator) {
			return
		}

		hotbar()

		let s = inventory.size
		let x = width / 2 + 0.5
		let y = height / 2 + 0.5

		// Crosshair
		if (!p.spectator) {
			ctx.lineWidth = 1
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.moveTo(x - 10, y)
			ctx.lineTo(x + 10, y)
			ctx.moveTo(x, y - 10)
			ctx.lineTo(x, y + 10)
			ctx.stroke()
		}

		//Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5

		ctx.strokeStyle = "black"
		ctx.lineWidth = 2
		ctx.beginPath()
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= 9; i++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		ctx.strokeStyle = "white"
		ctx.lineWidth = 2
		ctx.beginPath()

		ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s)

    //Health bar
    if(survival){
      var outline = (healEffect < 40 && healEffect > 30) || (healEffect < 20 && healEffect > 10)
      var heartNum = Math.ceil(p.health)
      let wither = witherEffect > 0
      for(var i=0; i<heartNum; i+=2){
        var heartX = (i * 10) + x;
        if(heartNum === i+1){
          ctx.drawImage(images[wither ? "witherHalfHeart":"halfHeart"], heartX, y-24, 20, 20);
        }else{
          ctx.drawImage(images[wither ? "witherHeart":"heart"], heartX, y-24, 20, 20);
        }
        if(outline){
          ctx.drawImage(images.whiteHeart, heartX, y-24, 20, 20);
        }
      }
      for(; i<18; i+=2){
        var heartX = (i * 10) + x;
        ctx.drawImage(images.deadHeart, heartX, y-24, 20, 20);
        if(outline){
          ctx.drawImage(images.whiteHeart, heartX, y-24, 20, 20);
        }
      }
    }

		let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
		+ "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
		+ "Render Time: " + analytics.displayedRenderTime + "ms\n"
		+ "Tick Time: " + analytics.displayedTickTime + "ms\n"
		+ "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
		+ "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
		+ "FPS: " + analytics.fps

		if (p.autoBreak) {
			text("Super breaker enabled", 5, height - 89, 12)
		}
    if (p.autoBuild) {
			text("Hyper builder enabled", 5, height - 101, 12)
		}
    if (multiplayer) {
			let closest = Infinity
			let cname = "Yourself"
			for (let name in players) {
				let pos = players[name]
        if(pos.dimension === world.type){
          let distance = sqrt((pos.x - p2.x)*(pos.x - p2.x) + (pos.y+1 - p2.y)*(pos.y+1 - p2.y) + (pos.z - p2.z)*(pos.z - p2.z))
          if (distance < closest) {
            closest = distance
            cname = pos.username
          }
        }
			}
      if(cname === "Yourself") closest = 0
      var info = round(closest)+" blocks away"
      if(closest === 0) info = "Right here"
			text(`Closest player: ${cname} (${info})`, 5, height - 113, 12)
		}

		ctx.textAlign = 'right'
		text(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0)
		ctx.textAlign = 'left'
		text(str, 5, height - 77, 12)
    
    
	}
  window.invScroll = 0;
	function drawInv() {
		let x = 0
		let y = 0
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13

		gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		ctx.fillStyle = "rgb(127, 127, 127)"
		ctx.fillRect(0, 0, canvas.width, canvas.height)
		FOV(90)

    let count = 1;
    if(survival){
      count = invLength
    }else{
      for (let i = 1; i < BLOCK_COUNT; i++) {
        if(!blockData[i].hidden)count ++;
      }
    }
    let invHeight = Math.ceil(count / perRow) * s
    let invWinH = s * 9;

    // Scrollbar
    var barW = 20
    var barH = height * (invWinH/invHeight);
    if(mouseDown && mouseX >= width-barW){
      invScroll = map(mouseY, (barH/2), height-(barH/2), 0, invHeight);
      if(invScroll > invHeight) invScroll = invHeight
      if(invScroll < 0) invScroll = 0
    }
    var barYCent = map(invScroll, 0, invHeight, (barH/2), height-(barH/2));
    var barTop = barYCent - (barH/2);
    fill(200)
    ctx.fillRect(width-barW, barTop, barW, barH)

		// Draw the grid
    ctx.translate(0, -(invScroll % s))
		ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
		for (y = 0; y < 10; y++) {
			ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s)
			ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s)
		}
		y--
		for (x = 0; x < perRow + 1; x++) {
			ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2)
			ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s)
		}
    ctx.translate(0, invScroll % s)

		// Hotbar
		x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= inventory.hotbar.length; i ++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			x += s * overHot
			ctx.lineWidth = 2
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.strokeRect(x, y, s, s)
		}
    
		//Box highlight in inv
		let overInv = Math.round(((mouseY + invScroll) - 50) / s) * perRow + Math.round((mouseX - 50) / s)
		if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow * s + 50 - s2
			y = (overInv / perRow | 0) * s + 50 - s2
      y -= invScroll
      if(mouseY < s*9.5){
        ctx.lineWidth = 2
        ctx.strokeStyle = "white"
        ctx.beginPath()
        ctx.strokeRect(x, y, s, s)
      }
		}

		if (inventory.holding && inventory.holding.id) {
			drawIcon(mouseX, mouseY, inventory.holding.id)
		}
    
    if(survival){
      fill(255)
      ctx.font = "14px VT323"
      ctx.textAlign = "right"
      for (let i = 0; i < invLength; i++) {
        if(invItems[i] && invItems[i].id){
          x = (i) % perRow * s + 50
          y = ((i) / perRow | 0) * s + 50
          drawIcon(x, y - invScroll, invItems[i].id)
          ctx.fillText(invItems[i].amount, x+(s/2), y+(s/2))
        }
      }
      ctx.textAlign = "left"
    }else{
      let invIdx = 0;
      for (let i = 1; i < BLOCK_COUNT; i++) {
        invIdx ++;
        if(blockData[i].hidden){
          while(blockData[i].hidden) i++
        }

        x = (invIdx - 1) % perRow * s + 50
        y = ((invIdx - 1) / perRow | 0) * s + 50
        y -= invScroll
        if(y < s*9.5){
          drawIcon(x, y, i)
        }
      }
    }
    
		hotbar()
		//hud()
		ctx.drawImage(gl.canvas, 0, 0)
    
    // show block name on hover
    if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow
			y = (overInv / perRow | 0)
      
      var wrongidx = x+(y*perRow)+1;
      var idx=1;
      if(survival){
        idx = wrongidx - 1
      }else{
        for(var i=1; i<wrongidx; i++){
          idx++;
          if(blockData[i+1] && blockData[i+1].hidden){
            /*let i2 = idx
            while(blockData[i2] && blockData[i2].hidden){
              i2++
              idx++
            }*/
            idx++
          }
        }
      }
      let name;
      if(survival){
        let id = invItems[idx] ? invItems[idx].id : 0
        name = id ? blockData[id].name : "";
      }else{
        name = blockData[idx] ? blockData[idx].name : "";
      }
      if((name !== "") && mouseY<s*9.5){
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10, mouseY+13+2);
      }
		}
	}
	function clickInv(dontRedraw) {
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13
		let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
    
    if(!survival){
      var idx = 0;
      for(var i=1; i<over+1; i++){
        if(!blockData[i]) break;

        idx ++;
        if(blockData[i+1] && blockData[i+1].hidden)idx++;
      }
      over = idx;
    }
    
    let count = survival ? invLength : BLOCK_COUNT - 1
    
    //for crafting
    let offX = width - s*4
    let offY = s * 2
    
		let x = width / 2 - 9 / 2 * s + 25
		let y = height - s * 1.5
		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			let temp = inventory.hotbar[overHot]
			inventory.hotbar[overHot] = inventory.holding
			inventory.holding = temp
		} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
      if(survival){
        if(invItems[over] && invItems[over].id){
          let temp = inventory.holding
          inventory.holding = invItems[over]
          invItems[over] = {id:0,amount:0}
          if(temp && temp.id){
            invItems[over] = temp
          }
        }else if(inventory.holding){
          invItems[over] = inventory.holding
          inventory.holding = 0
        }
      }else{
			  inventory.holding = {id:over + 1, amount:64}
      }
		} else if(screen === "crafting" && mouseX>offX && mouseX<offX+(s*3) && mouseY>offY && mouseY<offY+(s*3)){
      let X = Math.floor((mouseX - offX) / s)
      let Y = Math.floor((mouseY - offY) / s)
      let idx = (Y*3)+X
      let temp = inventory.holding
      inventory.holding = inventory.crafting[idx]
      inventory.crafting[idx] = temp
    }else{
			inventory.holding = 0
		}

		if(!dontRedraw)drawScreens.inventory()
	}

  function drawCrafting() {
    drawInv()
    let s = inventory.size
    let s2 = s/2
    
    gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
    
    let offX = width - s*4
    let offY = s * 2
    //draw grid
    ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
    let y = s*3+offY
    let x
    for(x=0; x<4; x++){
      ctx.moveTo(x*s+offX, offY)
      ctx.lineTo(x*s+offX, y)
    }
    x = s*3+offX
    for(y=0; y<4; y++){
      ctx.moveTo(offX, y*s+offY)
      ctx.lineTo(x, y*s+offY)
    }
    ctx.stroke()
    
    //icons
    ctx.font = "14px VT323"
    ctx.textAlign = "right"
    fill(255)
    for(y=0; y<3; y++){
      for(x=0; x<3; x++){
        let idx = (y*3) + x
        if(inventory.crafting[idx] && inventory.crafting[idx].id){
          let X = x*s+offX, Y = y*s+offY
          drawIcon(X+s2,Y+s2, inventory.crafting[idx].id)
          ctx.fillText(inventory.crafting[idx].amount, X+s, Y+s)
        }
      }
    }
    
    x = Math.floor((mouseX - offX) / s)
    y = Math.floor((mouseY - offY) / s)
    let over = (y * 3) + x
    if(!(x >= 0 && x < 3 && y >= 0 && y < 3)){
      over = -1
    }else if(over > -1 && over < 9){
      ctx.lineWidth = 2
      ctx.strokeStyle = "white"
      ctx.strokeRect(x*s+offX, y*s+offY, s,s)
    }
    
    x = offX + (s)
    y = offY + (s*4)
    over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    ctx.lineWidth = over?2:1
    ctx.strokeStyle = over?"white":"black"
    ctx.strokeRect(x,y, s,s)
    if(inventory.craftingRes && inventory.craftingRes.id){
      drawIcon(x+s2, y+s2, inventory.craftingRes.id)
      ctx.font = "14px VT323"
      ctx.textAlign = "right"
      fill(255)
      ctx.fillText(inventory.craftingRes.amount, x+s, y+s)
    }
    
    ctx.drawImage(gl.canvas,0,0)
    ctx.textAlign = "left"
    
    if(inventory.craftingRes && inventory.craftingRes.id){
      let name = blockData[inventory.craftingRes.id].name
      if(name !== "" && over){
        ctx.textAlign = "left"
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10, mouseY+13+2);
      }
    }
  }
  
  function clickCrafting() {
    clickInv(true)
    
    let s = inventory.size
    let s2 = s/2
    let offX = width - s*4
    let offY = s * 2
    
    let x = offX + (s)
    let y = offY + (s*4)
    let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    if(over && inventory.craftingRes && inventory.craftingRes.id){
      inventory.holding = Object.assign({}, inventory.craftingRes)
      for(let i=0; i<9; i++){
        let block = inventory.crafting[i]
        if(block && block.id){
          block.amount --
          if(block.amount < 1)inventory.crafting[i].id = 0
        }
      }
    }
    
    let arr = []
    inventory.crafting.forEach((v) => arr.push(v?v.id:0))
    let recipe = inventory.craftingStr = arr.join(",")
    if(crafts[recipe]){
      inventory.craftingRes = crafts[recipe]
    }else inventory.craftingRes = 0
    
    drawScreens.crafting()
  }

	let unpauseDelay = 0
	function mmoved(e) {
		let mouseS = settings.mouseSense / 30000
		p.rx -= e.movementY * mouseS
		p.ry += e.movementX * mouseS

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2
		}
	}
	function trackMouse(e) {
		if (screen !== "play") {
			cursor("")
			mouseX = e.x
			mouseY = e.y
      if(screen !== "main menu" && screen !== "options"){
        drawScreens[screen]()
        Button.draw()
        Slider.draw()
      }
			Slider.drag()
		}
	}
	document.onmousemove = trackMouse
  
  //added by me from mobile test Geekycraft
	let pTouch = {x: -100, y: 0};
	canvas.addEventListener("touchstart", function(e) {
	    pTouch.x = e.changedTouches[0].pageX;
	    pTouch.y = e.changedTouches[0].pageY;
	}, false);
	canvas.addEventListener("touchmove", function(e) {
	    e.movementY = e.changedTouches[0].pageY - pTouch.y;
	    e.movementX = e.changedTouches[0].pageX - pTouch.x;
	    pTouch.x = e.changedTouches[0].pageX;
	    pTouch.y = e.changedTouches[0].pageY;
	    mmoved(e);
	    e.preventDefault();
	}, false);
	//end added part
	canvas.addEventListener("touchstart",function(){
	    mouseDown=true
	})
	canvas.addEventListener("touchend",() => mouseDown=false)
  canvas.addEventListener("touchcancel",() => mouseDown=false)
  
	document.onpointerlockchange = function() {
		if (doc.pointerLockElement === canvas) {
			doc.onmousemove = mmoved
		} else {
			doc.onmousemove = trackMouse
			if (screen === "play" && !freezeFrame) {
				changeScene("pause")
				unpauseDelay = Date.now() + 1000
			}
		}
		for (let key in Key) {
			Key[key] = false
		}
	}
	canvas.onmousedown = function(e) {
		mouseX = e.x
		mouseY = e.y
		mouseDown = true
		let block, index
		switch(e.button) {
			case 0:
				Key.leftMouse = true
				break
			case 1:
				Key.middleMouse = true
				if (!hitBox.pos) break
				updateHUD = true
				block = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) & 0x3ff
				index = inventory.hotbar.indexOf(block)
				if (index >= 0) {
					inventory.hotbarSlot = index
				} else {
					inventory.hotbar[inventory.hotbarSlot] = block
				}
				break
			case 2:
				Key.rightMouse = true
				break
		}
		if(screen === "play") {
			if (doc.pointerLockElement !== canvas) {
				getPointer()
				p.lastBreak = Date.now()
			} else {
				place = false
				if(e.button === 0) {
					if(Key.control) {
						place = true
					} else if(!survival){
						changeWorldBlock(0)
					}
				}
				holding = inventory.hotbar[inventory.hotbarSlot].id
				if(e.button === 2 && holding) {
					place = true
				}
				if(place) {
					newWorldBlock()
				}
			}
		} else if (screen === "inventory") {
			clickInv()
		} else if (screen === "crafting") {
      clickCrafting()
    }

		Button.click()
		Slider.click()
	}
	canvas.onmouseup = function(e) {
		switch(e.button) {
			case 0:
				Key.leftMouse = false
				break
			case 1:
				Key.middleMouse = false
				break
			case 2:
				Key.rightMouse = false
				break
		}
		mouseDown = false
		Slider.release()
	}
  
  for(var onscreencontrol in onscreenControls){
	    var onscreencontrolElement = onscreenControls[onscreencontrol]
	    onscreencontrolElement.value = onscreencontrol
	    onscreencontrolElement.onmousedown=function(){
	        canvas.onkeydown({key:this.value})
	    }
	    onscreencontrolElement.onmouseup=function(){
	        canvas.onkeyup({key:this.value})
	    }
	    onscreencontrolElement.addEventListener("touchstart",onscreencontrolElement.onmousedown)
	    onscreencontrolElement.addEventListener("touchend",onscreencontrolElement.onmouseup)
      onscreencontrolElement.addEventListener("touchcancel",onscreencontrolElement.onmouseup)
	}
	onscreenControls[" "].addEventListener("click",function(){
    if (!survival && !p.spectator) {//fly toggle
			if (Date.now() < p.lastJump + 400) {
				p.flying ^= true
			} else {
				p.lastJump = Date.now()
			}
		}
	})
  let lastForward = 0
  onscreenControls.w.addEventListener("touchstart",function(){
			if (Date.now() < lastForward + 400) { //sprint toggle
				player.sprinting = true
			} else {
				lastForward = Date.now()
			}
	})
  onscreenControls.w.addEventListener("touchend",() => p.sprinting = false)
  onscreenControls.w.addEventListener("touchcancel",() => p.sprinting = false)
	onscreenControls[" "].addEventListener("mousedown",function(){
	    Key[" "]=true
	})
	onscreenControls[" "].addEventListener("mouseup",function(){
	    Key[" "]=false
	})
	onscreenControls[" "].addEventListener("touchstart",function(){
	    Key[" "]=true
	})
	onscreenControls[" "].addEventListener("touchend",function(){
	    Key[" "]=false
	})
	
  onscreenControl_Element.onclick = e => {mouseX = e.x; mouseY = e.y}
  
  let changeSlot = () => {
    for(let i = 0; i < inventory.hotbar.length; i ++) {
      let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  let y = height - inventory.size
      
      x -= inventory.size/2
		  y -= inventory.size/2
			if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
			  inventory.hotbarSlot = i
			  holding = inventory.hotbar[inventory.hotbarSlot]
			  updateHUD = true
			}
		}
  }
	onscreenControl_Element.addEventListener("click",changeSlot)
	onscreenControl_Element.addEventListener("touchend",changeSlot)
  
	canvas.onkeydown = function(e) {
		let k = e.key.toLowerCase()
		if (e.preventDefault && k === " ") {
			e.preventDefault()
		}
		if (e.repeat || Key[k]) {
			return
		}
		Key[k] = true

		if (k === "t") {
			initTextures()
		}

		if (k === "enter") {
			blockMode = blockMode === CUBE ? SLAB : (blockMode === SLAB ? STAIR : (blockMode === STAIR ? FENCE : (blockMode === FENCE ? WALLPOST : (blockMode === WALLPOST ? WALL : (blockMode === WALL ? WALLU : (blockMode === WALLU ? FENCQ : CUBE))))))
			updateHUD = true
		}

		if (screen === "play") {
			if(k === "p") {
				releasePointer()
				changeScene("pause")
			}

			if(k === "b") {
				p.autoBreak = !p.autoBreak
				updateHUD = true
        if(survival) p.autoBreak = false
			}
      if(k === "h") {
				p.autoBuild = !p.autoBuild
				updateHUD = true
        if(survival) p.autoBuild = false
			}

			if (k === " " && !p.spectator) {
				if (Date.now() < p.lastJump + 400) {
					p.flying ^= true
          if(survival) p.flying = false
				} else {
					p.lastJump = Date.now()
				}
			}

			if (k === "z") {
				p.FOV(10, 300)
			}

			if (k === "shift" && !p.flying) {
				p.sneaking = true
				if (p.sprinting) {
					p.FOV(settings.fov, 100)
				}
				p.sprinting = false
				p.speed = 0.03
				p.bottomH = 1.32
			}

			if (k === "l" && !survival) {
				p.spectator = !p.spectator
				p.flying = true
				p.onGround = false
				updateHUD = true
			}
      if (k === "o"){
        p.thirdPerson = !p.thirdPerson
      }

			if (k === "e") {
				changeScene("inventory")
				releasePointer()
			}

			if (k === ";") {
				releasePointer()
				freezeFrame = true
			}
      
      if(k === "/"){
        Messages.showInput()
      }

			if (Key.backspace && inventory.hotbar[inventory.hotbarSlot] && inventory.hotbar[inventory.hotbarSlot].id) {
				let d = p.direction
        let block = holding || inventory.hotbar[inventory.hotbarSlot].id
        block = block < 0xff ? block | blockMode : block
				world.addEntity(new Item(p.x + (d.x), p.y + (d.y), p.z + (d.z), d.x/4, d.y/4, d.z/4, block))
        if(survival){
          inventory.hotbar[inventory.hotbarSlot].amount --
          updateHUD = true
        }
			}

			if(Number(k)) {
				inventory.hotbarSlot = Number(k) - 1
				holding = inventory.hotbar[inventory.hotbarSlot].id
				updateHUD = true
			}
		} else if (screen === "pause") {
			if(k === "p") {
				play()
			}
		} else if (screen === "inventory" || screen === "crafting") {
			if (k === "e") {
				play()
			}
			if (k === "enter") {
				drawScreens.inventory()
			}
		}
	}
	canvas.onkeyup = function(e) {
		let k = e.key.toLowerCase()
		Key[k] = false
		if(k === "escape" && (screen === "pause" || screen === "inventory" || screen === "options" && previousScreen === "pause") && Date.now() > unpauseDelay) {
			play()
		}
		if (screen === "play") {
			if (k === "z") {
				p.FOV(settings.fov, 300)
			}

			if (k === "shift" && p.sneaking) {
				p.sneaking = false
				p.speed = 0.075
				p.bottomH = 1.62
				// p.y += 0.3
			}
		}
	}
	canvas.onblur = function() {
		for (let key in Key) {
			Key[key] = false
		}
		mouseDown = false
		Slider.release()
	}
	canvas.oncontextmenu = function(e) {
		e.preventDefault()
	}
	window.onbeforeunload = e => { 
		if (screen === "play" && Key.control) {
			releasePointer()
			e.preventDefault()
			e.returnValue = "Q is the sprint button; Ctrl + W closes the page."
			return true
		}
	}
	canvas.onwheel = e => {
		e.preventDefault()
		e.stopPropagation()
		if (e.deltaY > 0) {
			inventory.hotbarSlot++
		} else if (e.deltaY < 0) {
			inventory.hotbarSlot--
		}
		if (inventory.hotbarSlot > 8) {
			inventory.hotbarSlot = 0
		} else if (inventory.hotbarSlot < 0) {
			inventory.hotbarSlot = 8
		}

		updateHUD = true
		holding = inventory.hotbar[inventory.hotbarSlot].id
	}
	document.onwheel = e => {} // Shouldn't do anything, but it helps with a Khan Academy bug somewhat
	window.onresize = e => {
		width = window.innerWidth
		height = window.innerHeight
		canvas.height = height
		canvas.width = width
    ctx.imageSmoothingEnabled = false
		gl.canvas.height = height
		gl.canvas.width = width
		gl.viewport(0, 0, width, height)
		initButtons()
		initBackgrounds()
		inventory.size = 40 * min(width, height) / 600
		genIcons()
		use3d()
		p.FOV(p.currentFov + 0.0001)

		if (screen === "play") {
			play()
		} else {
			drawScreens[screen]()
			Button.draw()
			Slider.draw()
		}
	}

	function use2d() {
		gl.disableVertexAttribArray(glCache.aTexture)
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aVertex)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.useProgram(program2D)
		
		gl.enableVertexAttribArray(glCache.aVertex2)
		gl.enableVertexAttribArray(glCache.aTexture2)
		gl.enableVertexAttribArray(glCache.aShadow2)
	}
	function use3d() {
		gl.disableVertexAttribArray(glCache.aTexture2)
		gl.disableVertexAttribArray(glCache.aShadow2)
		gl.disableVertexAttribArray(glCache.aVertex2)
		gl.useProgram(program3D)
		
		gl.enableVertexAttribArray(glCache.aVertex)
		gl.enableVertexAttribArray(glCache.aTexture)
		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
	}

	let maxLoad = 1
	function startLoad() {
		// Runs when the loading screen is opened; cache the player's position
		p2.x = p.x
		p2.y = p.y
		p2.z = p.z
		maxLoad = world.loadFrom.length + 9
	}
	function initWebgl() {
		if (!win.gl) {
			let canv = document.createElement('canvas')
			canv.width = ctx.canvas.width
			canv.height = ctx.canvas.height
			canv.style.position = "absolute"
			canv.style.zIndex = -1
			canv.style.top = "0px"
			canv.style.left = "0px"
			gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false })
			let ext = gl.getExtension('OES_element_index_uint')
			if (!ext) {
				alert("Please use a supported browser, or update your current browser.")
			}
			gl.viewport(0, 0, canv.width, canv.height)
			gl.enable(gl.DEPTH_TEST)
			gl.enable(gl.BLEND)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
			win.gl = gl
			glExtensions = []
			const availableExtensions = gl.getSupportedExtensions()
			for (let i = 0; i < availableExtensions.length; i++) {
				const extensionName = availableExtensions[i]
				glExtensions[extensionName.replace(/[A-Z]+_/g, "")] = gl.getExtension(extensionName)
			}
		} else {
			gl = win.gl
		}

		if (!document.body.contains(gl.canvas)) {
			document.body.append(gl.canvas)
		}

		modelView = new Float32Array(16)
		glCache = {}
		win.glCache = glCache
		program3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D)
		program2D = createProgramObject(gl, vertexShaderSrc2D, fragmentShaderSrc2D)
		programEntity = createProgramObject(gl, vertexShaderSrcEntity, fragmentShaderSrcEntity)
		
		gl.useProgram(program2D)
		glCache.uSampler2 = gl.getUniformLocation(program2D, "uSampler")
		glCache.aTexture2 = gl.getAttribLocation(program2D, "aTexture")
		glCache.aVertex2 = gl.getAttribLocation(program2D, "aVertex")
		glCache.aShadow2 = gl.getAttribLocation(program2D, "aShadow")

		gl.useProgram(programEntity)
		glCache.uSamplerEntity = gl.getUniformLocation(programEntity, "uSampler")
		glCache.uLightLevelEntity = gl.getUniformLocation(programEntity, "uLightLevel")
		glCache.uViewEntity = gl.getUniformLocation(programEntity, "uView")
		glCache.aTextureEntity = gl.getAttribLocation(programEntity, "aTexture")
		glCache.aVertexEntity = gl.getAttribLocation(programEntity, "aVertex")

		gl.useProgram(program3D)
		glCache.uSampler = gl.getUniformLocation(program3D, "uSampler")
		glCache.uPos = gl.getUniformLocation(program3D, "uPos")
		glCache.uDist = gl.getUniformLocation(program3D, "uDist")
		glCache.uTime = gl.getUniformLocation(program3D, "uTime")
		glCache.aShadow = gl.getAttribLocation(program3D, "aShadow")
		glCache.aSkylight = gl.getAttribLocation(program3D, "aSkylight")
		glCache.aBlocklight = gl.getAttribLocation(program3D, "aBlocklight")
		glCache.aTexture = gl.getAttribLocation(program3D, "aTexture")
		glCache.aVertex = gl.getAttribLocation(program3D, "aVertex")
    glCache.skyColor = gl.getUniformLocation(program3D, "skyColor")

		gl.uniform1f(glCache.uDist, 1000)

		//Send the block textures to the GPU
		initTextures()
		initShapes()

		// These buffers are only used for drawing the main menu blocks
		sideEdgeBuffers = {}
		for (let side in shapes.cube.verts) {
			let edgeBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapes.cube.verts[side][0]), gl.STATIC_DRAW)
			sideEdgeBuffers[side] = edgeBuffer
		}
		texCoordsBuffers = []
		for (let t in textureCoords) {
			let buff = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buff)
			gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW)
			texCoordsBuffers.push(buff)
		}

		//Bind the Vertex Array Object (VAO) that will be used to draw everything
		indexBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW)

		//Tell it not to render the insides of blocks
		gl.enable(gl.CULL_FACE)
		gl.cullFace(gl.BACK)

		gl.lineWidth(2)
		blockOutlines = false
		gl.enable(gl.POLYGON_OFFSET_FILL)
		gl.polygonOffset(1, 1)
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
	}
	function initBackgrounds() {
		// Home screen background
    const HALF_PI = Math.PI / 2
    var mainBG = document.createElement("canvas");
    mainBG.width = gl.canvas.width;
    mainBG.height = gl.canvas.height;
    var mainBGRot = -HALF_PI / 3;
    win.renderMainBG = function(){
      mainBGRot += 0.01;
      if(mainBGRot > Math.PI*2){
        mainBGRot = 0;
      }
      
      use3d()
      gl.clearColor(sky[0], sky[1], sky[2], 1.0)
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
      FOV(100)
      initModelView(null, 0, 0.5, 0, -HALF_PI / 25, mainBGRot/*-HALF_PI / 3*/)
      gl.disableVertexAttribArray(glCache.aShadow)
      gl.disableVertexAttribArray(glCache.aSkylight)
      gl.disableVertexAttribArray(glCache.aBlocklight)
      gl.vertexAttrib1f(glCache.aShadow, 1.0)
      gl.vertexAttrib1f(glCache.aSkylight, 1.0)
      gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
        const blocks = Int8Array.of(
          7, 4, 1, 7,
          7, 4, 2, 7,
          7, 4, 3, 7,
          7, 4, 4, 7,
          7, 5, 1, 7,
          7, 5, 2, 7,
          7, 5, 3, 7,
          6, 4, 0, 7,
          6, 4, 1, 7,
          6, 4, 2, 7,
          6, 4, 3, 7,
          6, 4, 4, 7,
          6, 5, 0, 7,
          6, 5, 1, 7,
          6, 5, 2, 7,
          6, 5, 3, 7,
          6, 5, 4, 7,
          6, 6, 3, 7,
          6, 6, 4, 7,
          6, 7, 3, 7,
          5, 0, -1, 1,
          5, 0, 0, 1,
          5, 0, 1, 1,
          5, 0, 2, 1,
          5, 1, 2, 29,
          5, 2, 2, 29,
          5, 3, 2, 29,
          5, 4, 2, 29,
          5, 5, 2, 29,
          5, 6, 2, 29,
          5, 4, 0, 7,
          5, 4, 1, 7,
          5, 4, 3, 7,
          5, 4, 4, 7,
          5, 5, 0, 7,
          5, 5, 1, 7,
          5, 5, 3, 7,
          5, 5, 4, 7,
          5, 6, 1, 7,
          5, 6, 3, 7,
          5, 7, 1, 7,
          5, 7, 2, 7,
          5, 7, 3, 7,
          4, -1, -1, 1,
          4, -1, 0, 1,
          4, -1, 1, 1,
          4, -1, 2, 1,
          4, 0, 3, 1,
          4, 0, 4, 1,
          4, 0, 5, 1,
          4, 0, 6, 1,
          4, 0, 7, 1,
          4, 0, 8, 1,
          4, 0, 9, 1,
          4, 0, 10, 1,
          4, 4, 0, 7,
          4, 4, 1, 7,
          4, 4, 2, 7,
          4, 4, 3, 7,
          4, 4, 4, 7,
          4, 5, 0, 7,
          4, 5, 1, 7,
          4, 5, 2, 7,
          4, 5, 3, 7,
          4, 5, 4, 7,
          4, 6, 1, 7,
          4, 6, 2, 7,
          4, 6, 3, 7,
          4, 7, 4, 7,
          3, -1, -1, 1,
          3, -1, 0, 1,
          3, -1, 1, 1,
          3, -1, 2, 1,
          3, -1, 3, 1,
          3, -1, 4, 1,
          3, 0, 5, 1,
          3, 0, 6, 1,
          3, 0, 7, 1,
          3, 0, 8, 1,
          3, 0, 9, 1,
          3, 0, 10, 1,
          3, 4, 1, 7,
          3, 4, 2, 7,
          3, 4, 3, 7,
          3, 4, 4, 7,
          3, 5, 1, 7,
          3, 5, 2, 7,
          3, 5, 3, 7,
          2, -1, -1, 1,
          2, -1, 0, 1,
          2, -1, 1, 1,
          2, -1, 2, 1,
          2, -1, 3, 1,
          2, -1, 4, 1,
          2, -1, 5, 1,
          2, -1, 6, 1,
          2, -1, 7, 1,
          2, 0, 8, 1,
          2, 0, 9, 1,
          2, 0, 10, 1,
          1, -2, -1, 1,
          1, -2, 0, 1,
          1, -2, 1, 1,
          1, -2, 2, 1,
          1, -2, 3, 1,
          1, -1, 4, 1,
          1, -1, 5, 1,
          1, -1, 6, 1,
          1, -1, 7, 1,
          1, -1, 8, 1,
          1, -1, 9, 1,
          1, -1, 10, 1,
          0, -2, -1, 1,
          0, -2, 0, 1,
          0, -2, 1, 1,
          0, -2, 2, 1,
          0, -2, 3, 1,
          0, -2, 4, 1,
          0, -2, 5, 1,
          0, -1, 6, 1,
          0, -1, 7, 1,
          0, -1, 8, 1,
          0, -1, 9, 1,
          0, -1, 10, 1,
          -1, -2, -1, 1,
          -1, -2, 0, 1,
          -1, -2, 1, 1,
          -1, -2, 2, 1,
          -1, -2, 3, 1,
          -1, -2, 4, 1,
          -1, -2, 5, 1,
          -1, -2, 6, 1,
          -1, -2, 7, 1,
          -1, -1, 8, 1,
          -1, -1, 9, 1,
          -1, -1, 10, 1,
          -2, -2, -1, 1,
          -2, -2, 0, 1,
          -2, -2, 1, 1,
          -2, -2, 2, 1,
          -2, -2, 3, 1,
          -2, -2, 4, 1,
          -2, -2, 5, 1,
          -2, -2, 6, 1,
          -2, -2, 7, 1,
          -2, -2, 8, 1,
          -2, -2, 9, 1,
          -2, -1, 10, 1,
          -3, -2, -1, 1,
          -3, -2, 0, 1,
          -3, -2, 1, 1,
          -3, -2, 2, 1,
          -3, -2, 3, 1,
          -3, -2, 4, 1,
          -3, -2, 5, 1,
          -3, -2, 6, 1,
          -3, -2, 7, 1,
          -3, -2, 8, 1,
          -3, -2, 9, 1,
          -3, -2, 10, 1,
          -3, -2, 11, 1,
          -3, -2, 12, 1,
          -4, -2, -1, 1,
          -4, -2, 0, 1,
          -4, -2, 1, 1,
          -4, -2, 2, 1,
          -4, -2, 3, 1,
          -4, -2, 4, 1,
          -4, -2, 5, 1,
          -4, -2, 6, 1,
          -4, -2, 7, 1,
          -4, -2, 8, 1,
          -4, -2, 9, 1,
          -4, -2, 10, 1,
          -4, -2, 11, 1,
          -4, -2, 12, 1,
          -5, -2, -1, 1,
          -5, -2, 0, 1,
          -5, -2, 1, 1,
          -5, -2, 2, 1,
          -5, -2, 3, 1,
          -5, -2, 4, 1,
          -5, -2, 5, 1,
          -5, -2, 6, 1,
          -5, -2, 7, 1,
          -5, -2, 8, 1,
          -5, -2, 9, 1,
          -5, -2, 10, 1,
          -5, -2, 11, 1,
          -5, -2, 12, 1,
          -6, -2, -1, 1,
          -6, -2, 0, 1,
          -6, -2, 1, 1,
          -6, -2, 2, 1,
          -6, -2, 3, 1,
          -6, -2, 4, 1,
          -6, -2, 5, 1,
          -6, -2, 6, 1,
          -6, -2, 7, 1,
          -6, -2, 8, 1,
          -6, -2, 9, 1,
          -6, -2, 10, 1,
          -6, -2, 11, 1,
          -7, -2, 3, 1,
          -7, -2, 4, 1,
          -7, -2, 5, 1,
          -7, -2, 6, 1,
          -7, -2, 7, 1,
          -7, -2, 8, 1,
          -7, -2, 9, 1,
          -8, -2, 2, 1,
          -8, -2, 3, 1,
          -8, -2, 4, 1,
          -8, -2, 5, 1,
          -8, -2, 6, 1,
          -8, -2, 7, 1,
          -8, -2, 8, 1,
        );

      gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])
      for (let i = 0; i < blocks.length; i += 4) {
        block2(blocks[i + 0], blocks[i + 1], blocks[i + 2], blocks[i + 3])
      }

      gl.enableVertexAttribArray(glCache.aShadow)
      gl.enableVertexAttribArray(glCache.aSkylight)
      gl.enableVertexAttribArray(glCache.aBlocklight)
      
      ctx.drawImage(gl.canvas, 0,0)
    }

		// Dirt background
		use2d()
		let aspect = width / height
		let stack = height / 96
		let bright = 0.4
		if (dirtBuffer) {
			gl.deleteBuffer(dirtBuffer)
		}
		dirtBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, dirtBuffer)
		let bgCoords = new Float32Array([
			-1, -1, 0, stack, bright,
			1, -1, stack * aspect, stack, bright,
			1, 1, stack * aspect, 0, bright,
			-1, 1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 1)
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		let pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		dirtbg = ctx.createImageData(width, height)
		dirtbg.data.set(pixels)
    
    // Netherrack background
		bright = 0.4
		if (netherBuffer) {
			gl.deleteBuffer(netherBuffer)
		}
		netherBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, netherBuffer)
		bgCoords = new Float32Array([
			-1, -1, 0, stack, bright,
			1, -1, stack * aspect, stack, bright,
			1, 1, stack * aspect, 0, bright,
			-1, 1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 2) //netherrack textures uses TEXTURE2 so the number is 2
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		netherbg = ctx.createImageData(width, height)
		netherbg.data.set(pixels)
	}
	function initPlayer() {
		p = new Camera()
		p.speed = 0.075
		p.velocity = new PVector(0, 0, 0)
		p.pos = new Float32Array(3)
		p.sprintSpeed = 1.5
		p.flySpeed = 2.5
		p.x = 8
		p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
		p.z = 8
		p.previousX = 8
		p.previousY = 70
		p.previousZ = 8
		p.w = 3 / 8
		p.bottomH = 1.62
		p.topH = 0.18
		p.onGround = false
		p.jumpSpeed = 0.3
		p.sprinting = false
		p.maxYVelocity = 1.5
		p.gravityStength = -0.032
		p.lastUpdate = performance.now()
		p.lastBreak = Date.now()
		p.lastPlace = Date.now()
		p.lastJump = Date.now()
		p.autoBreak = false
    p.autoBuild = false
		p.flying = false
		p.sneaking = false
		p.spectator = false
    p.health = 18
    p.lastY = 0 //y the last time it touched the ground
    p.character = new Character(abs(username.hashCode()) % 80 + 1)
    p.thirdPerson = false
		
		win.player = p
		win.p2 = p2
	}
	function initWorldsMenu() {
		while (window.worlds.firstChild) {
			window.worlds.removeChild(window.worlds.firstChild)
		}
		selectedWorld = 0
		window.boxCenterTop.value = ""

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		function addWorld(name, version, size, id, edited) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + name + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
			div.innerHTML += `${size.toLocaleString()} bytes used`
			
			window.worlds.appendChild(div)
		}

		worlds = {}
		if (loadString) {
			try {
				let tempWorld = new World()
				tempWorld.loadSave(loadString)
				let now = Date.now()
				addWorld(`${tempWorld.name} (Pre-loaded)`, tempWorld.version, loadString.length, now)
				worlds[now] = {
					code: loadString,
					id: now
				}
			}
			catch(e) {
				console.log("Unable to load hardcoded save.")
				console.error(e)
			}
		}
		loadFromDB().then(res => {
			if(res && res.length) {
				let index = res.findIndex(obj => obj.id === "settings")
				if (index >= 0) {
					Object.assign(settings, res[index].data) // Stored data overrides any hardcoded settings
					p.FOV(settings.fov)
					res.splice(index, 1)
				}
			}
			
			if (res && res.length) {
				res = res.map(d => d.data).filter(d => d && d.code).sort((a, b) => b.edited - a.edited)
				for (let data of res) {
					addWorld(data.name, data.version, (data.code.length + 60), data.id, data.edited)
					worlds[data.id] = data
				}
			}
			window.worlds.onclick = Button.draw
			window.boxCenterTop.onkeyup = Button.draw
		}).catch(e => console.error(e))

		superflat = false
		trees = true
		caves = true
    survival = false
	}
  var servers = {}
  async function initServersMenu() {
		while (window.servers.firstChild) {
			window.servers.removeChild(window.servers.firstChild)
		}
		selectedWorld = null

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		function addWorld(name, id, host, players) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + name + "</strong>" + br
      div.innerHTML += "Hosted by "+host + br
      div.innerHTML += players.length+" player"+(players.length===1 ? "" : "s")+" online"
			
      servers[id] = {
        id:id,
        name:name,
        host:host
      }
			window.servers.appendChild(div)
		}

		var worlds;
    await getWorlds().then(r => worlds=r)
    worlds.forEach(r => addWorld(r.name, r.id, r.host, r.players))
    
		window.servers.onclick = Button.draw

		superflat = false
		trees = true
		caves = true
    survival = false
	}
  let marketplace = {}; win.marketplaceData = null
  async function initMarketplace(){
    marketplaceData = await fetch("https://geeky-people.herokuapp.com/index.json")
    await new Promise((resolve, reject) => {
      marketplaceData.text().then(r => {marketplaceData = JSON.parse(r); resolve()})
    })
    
    marketplace = {}
    window.marketplace.innerHTML = ""
    const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}
    function addWorld(name, version, size, id, edited) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + name + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
			div.innerHTML += `${size.toLocaleString()} bytes used`
			
			window.marketplace.appendChild(div)
      
      superflat = false
      trees = true
      caves = true
      survival = false
		}
    let tempWorld = new World()
    marketplaceData.forEach(data => {
      let loadString, mod
      if(typeof data === "object"){
        loadString = data.loadString
        mod = data.mod
      }else loadString = data
      
      tempWorld.loadSave(loadString)
		  let now = Date.now()
			addWorld(tempWorld.name, tempWorld.version, loadString.length, now)
			marketplace[now] = {
				code: loadString,
				id: now,
        name: tempWorld.name,
        version: tempWorld.version,
        mod: mod,
			}
    })
    window.marketplace.onclick = Button.draw
  }
  function saveFromMarketplace(){
    let save = marketplace[selectedWorld]
    saveToDB(save.id, {
			id: save.id,
			edited: Date.now(),
			name: save.name,
			version: save.version,
			code: save.code,
      mod: save.mod
		})
    initWorldsMenu()
    changeScene("loadsave menu")
  }
  
  var sounds = {
    click: "click.ogg",
    damage: {
      bigfall: "damage/fallbig.ogg",
      smallfall: "damage/fallsmall.ogg",
      hit1: "damage/hit1.ogg",
      hit2: "damage/hit2.ogg",
      hit3: "damage/hit3.ogg"
    },
    block: {
      grass: {
        dig1: "grass/dig1.ogg",
        dig2: "grass/dig2.ogg",
        dig3: "grass/dig3.ogg",
        dig4: "grass/dig4.ogg",
        step1: "grass/step1.ogg",
        step2: "grass/step2.ogg",
        step3: "grass/step3.ogg",
        step4: "grass/step4.ogg",
        step5: "grass/step5.ogg",
        step6: "grass/step6.ogg",
      },
      stone: {
        dig1: "stone/dig1.ogg",
        dig2: "stone/dig2.ogg",
        dig3: "stone/dig3.ogg",
        dig4: "stone/dig4.ogg",
        step1: "stone/step1.ogg",
        step2: "stone/step2.ogg",
        step3: "stone/step3.ogg",
        step4: "stone/step4.ogg",
        step5: "stone/step5.ogg",
        step6: "stone/step6.ogg",
      },
      gravel: {
        dig1: "gravel/dig1.ogg",
        dig2: "gravel/dig2.ogg",
        dig3: "gravel/dig3.ogg",
        dig4: "gravel/dig4.ogg",
        step1: "gravel/step1.ogg",
        step2: "gravel/step2.ogg",
        step3: "gravel/step3.ogg",
        step4: "gravel/step4.ogg",
      },
      sand: {
        dig1: "sand/dig1.ogg",
        dig2: "sand/dig2.ogg",
        dig3: "sand/dig3.ogg",
        dig4: "sand/dig4.ogg",
        step1: "sand/step1.ogg",
        step2: "sand/step2.ogg",
        step3: "sand/step3.ogg",
        step4: "sand/step4.ogg",
        step5: "sand/step5.ogg",
      },
      basalt: {
        dig1: "basalt/dig1.ogg",
        dig2: "basalt/dig2.ogg",
        dig3: "basalt/dig3.ogg",
        dig4: "basalt/dig4.ogg",
        dig5: "basalt/dig5.ogg",
        step1: "basalt/step1.ogg",
        step2: "basalt/step2.ogg",
        step3: "basalt/step3.ogg",
        step4: "basalt/step4.ogg",
        step5: "basalt/step5.ogg",
        step6: "basalt/step6.ogg",
      },
      chain: {
        dig1: "chain/dig1.ogg",
        dig2: "chain/dig2.ogg",
        dig3: "chain/dig3.ogg",
        dig4: "chain/dig4.ogg",
        step1: "chain/step1.ogg",
        step2: "chain/step2.ogg",
        step3: "chain/step3.ogg",
        step4: "chain/step4.ogg",
        step5: "chain/step5.ogg",
        step6: "chain/step6.ogg",
      },
      cloth: {
        dig1: "cloth/dig1.ogg",
        dig2: "cloth/dig2.ogg",
        dig3: "cloth/dig3.ogg",
        dig4: "cloth/dig4.ogg",
        step1: "cloth/step1.ogg",
        step2: "cloth/step2.ogg",
        step3: "cloth/step3.ogg",
        step4: "cloth/step4.ogg",
      },
      fungus: {
        dig1: "fungus/dig1.ogg",
        dig2: "fungus/dig2.ogg",
        dig3: "fungus/dig3.ogg",
        dig4: "fungus/dig4.ogg",
        dig5: "fungus/dig3.ogg",
        dig6: "fungus/dig4.ogg",
      },
      glass: {
        dig1: "glass/dig1.ogg",
        dig2: "glass/dig2.ogg",
        dig3: "glass/dig3.ogg",
      },
      lantern: {
        dig1: "lantern/dig1.ogg",
        dig2: "lantern/dig2.ogg",
        dig3: "lantern/dig3.ogg",
        dig4: "lantern/dig4.ogg",
        dig5: "lantern/dig5.ogg",
        dig6: "lantern/dig6.ogg",
        step1: "lantern/step1.ogg",
        step2: "lantern/step2.ogg",
        step3: "lantern/step3.ogg",
        step4: "lantern/step4.ogg",
        step5: "lantern/step5.ogg",
        step6: "lantern/step6.ogg",
      },
      nether_bricks: {
        dig1: "nether_bricks/dig1.ogg",
        dig2: "nether_bricks/dig2.ogg",
        dig3: "nether_bricks/dig3.ogg",
        dig4: "nether_bricks/dig4.ogg",
        dig5: "nether_bricks/dig5.ogg",
        dig6: "nether_bricks/dig6.ogg",
        step1: "nether_bricks/step1.ogg",
        step2: "nether_bricks/step2.ogg",
        step3: "nether_bricks/step3.ogg",
        step4: "nether_bricks/step4.ogg",
        step5: "nether_bricks/step5.ogg",
        step6: "nether_bricks/step6.ogg",
      },
      nether_ore: {
        dig1: "nether_ore/dig1.ogg",
        dig2: "nether_ore/dig2.ogg",
        dig3: "nether_ore/dig3.ogg",
        dig4: "nether_ore/dig4.ogg",
        step1: "nether_ore/step1.ogg",
        step2: "nether_ore/step2.ogg",
        step3: "nether_ore/step3.ogg",
        step4: "nether_ore/step4.ogg",
        step5: "nether_ore/step5.ogg",
      },
      nether_sprouts: {
        dig1: "nether_sprouts/dig1.ogg",
        dig2: "nether_sprouts/dig2.ogg",
        dig3: "nether_sprouts/dig3.ogg",
        dig4: "nether_sprouts/dig4.ogg",
        step1: "nether_sprouts/step1.ogg",
        step2: "nether_sprouts/step2.ogg",
        step3: "nether_sprouts/step3.ogg",
        step4: "nether_sprouts/step4.ogg",
        step5: "nether_sprouts/step5.ogg",
      },
      netherite: {
        dig1: "netherite/dig1.ogg",
        dig2: "netherite/dig2.ogg",
        dig3: "netherite/dig3.ogg",
        dig4: "netherite/dig4.ogg",
        step1: "netherite/step1.ogg",
        step2: "netherite/step2.ogg",
        step3: "netherite/step3.ogg",
        step4: "netherite/step4.ogg",
        step5: "netherite/step5.ogg",
        step6: "netherite/step6.ogg",
      },
      netherrack: {
        dig1: "netherrack/dig1.ogg",
        dig2: "netherrack/dig2.ogg",
        dig3: "netherrack/dig3.ogg",
        dig4: "netherrack/dig4.ogg",
        dig5: "netherrack/dig5.ogg",
        dig6: "netherrack/dig6.ogg",
        step1: "netherrack/step1.ogg",
        step2: "netherrack/step2.ogg",
        step3: "netherrack/step3.ogg",
        step4: "netherrack/step4.ogg",
        step5: "netherrack/step5.ogg",
        step6: "netherrack/step6.ogg",
      },
      netherwart: {
        dig1: "netherwart/dig1.ogg",
        dig2: "netherwart/dig2.ogg",
        dig3: "netherwart/dig3.ogg",
        dig4: "netherwart/dig4.ogg",
        dig5: "netherwart/dig5.ogg",
        dig6: "netherwart/dig6.ogg",
        step1: "netherwart/step1.ogg",
        step2: "netherwart/step2.ogg",
        step3: "netherwart/step3.ogg",
        step4: "netherwart/step4.ogg",
        step5: "netherwart/step5.ogg",
      },
      nylium: {
        dig1: "nylium/dig1.ogg",
        dig2: "nylium/dig2.ogg",
        dig3: "nylium/dig3.ogg",
        dig4: "nylium/dig4.ogg",
        dig5: "nylium/dig5.ogg",
        dig6: "nylium/dig6.ogg",
        step1: "nylium/step1.ogg",
        step2: "nylium/step2.ogg",
        step3: "nylium/step3.ogg",
        step4: "nylium/step4.ogg",
        step5: "nylium/step5.ogg",
        step6: "nylium/step6.ogg",
      },
      roots: {
        dig1: "roots/dig1.ogg",
        dig2: "roots/dig2.ogg",
        dig3: "roots/dig3.ogg",
        dig4: "roots/dig4.ogg",
        dig5: "roots/dig5.ogg",
        dig6: "roots/dig6.ogg",
        step1: "roots/step1.ogg",
        step2: "roots/step2.ogg",
        step3: "roots/step3.ogg",
        step4: "roots/step4.ogg",
        step5: "roots/step5.ogg",
      },
      shroomlight: {
        dig1: "shroomlight/dig1.ogg",
        dig2: "shroomlight/dig2.ogg",
        dig3: "shroomlight/dig3.ogg",
        dig4: "shroomlight/dig4.ogg",
        dig5: "shroomlight/dig5.ogg",
        step1: "shroomlight/step1.ogg",
        step2: "shroomlight/step2.ogg",
        step3: "shroomlight/step3.ogg",
        step4: "shroomlight/step4.ogg",
        step5: "shroomlight/step5.ogg",
        step6: "shroomlight/step6.ogg",
      },
      soul_sand: {
        dig1: "soul_sand/dig1.ogg",
        dig2: "soul_sand/dig2.ogg",
        dig3: "soul_sand/dig3.ogg",
        dig4: "soul_sand/dig4.ogg",
        dig5: "soul_sand/dig5.ogg",
        dig6: "soul_sand/dig6.ogg",
        dig7: "soul_sand/dig7.ogg",
        dig8: "soul_sand/dig8.ogg",
        dig9: "soul_sand/dig9.ogg",
        step1: "soul_sand/step1.ogg",
        step2: "soul_sand/step2.ogg",
        step3: "soul_sand/step3.ogg",
        step4: "soul_sand/step4.ogg",
        step5: "soul_sand/step5.ogg",
      },
      stem: {
        dig1: "stem/dig1.ogg",
        dig2: "stem/dig2.ogg",
        dig3: "stem/dig3.ogg",
        dig4: "stem/dig4.ogg",
        dig5: "stem/dig5.ogg",
        dig6: "stem/dig6.ogg",
        step1: "stem/step1.ogg",
        step2: "stem/step2.ogg",
        step3: "stem/step3.ogg",
        step4: "stem/step4.ogg",
        step5: "stem/step5.ogg",
        step6: "stem/step6.ogg",
      },
      wood: {
        dig1: "wood/dig1.ogg",
        dig2: "wood/dig2.ogg",
        dig3: "wood/dig3.ogg",
        dig4: "wood/dig4.ogg",
        step1: "wood/step1.ogg",
        step2: "wood/step2.ogg",
        step3: "wood/step3.ogg",
        step4: "wood/step4.ogg",
        step5: "wood/step5.ogg",
        step6: "wood/step6.ogg",
      },
    },
    entity: {
      generic: {
        explode1: "random/explode1.ogg",
        explode2: "random/explode2.ogg",
        explode3: "random/explode3.ogg",
        explode4: "random/explode4.ogg",
      },
      tnt: {
        fuse: "random/fuse.ogg"
      },
    }
  }
  win.sounds = sounds
  function loadSoundBuffer(url){
    return new Promise((resolve, reject) => {
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.responseType = 'arraybuffer';
      request.onerror = reject

      request.onload = function() {
        audioCtx.decodeAudioData(request.response, function(buffer) {
          resolve(buffer)
        }, reject);
      }
      request.send();
    })
  }
  async function initAudioCtx(){
    try{
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
    }catch(e) {
      alert('Web Audio API is not supported in this browser');
      return
    }
    
    async function loadSoundsObj(obj){
      for(var i in obj){
        if(typeof obj[i] === "object"){
          loadSoundsObj(obj[i])
        }else{
          var url = "https://data.thingmaker.repl.co/sounds/"+obj[i]
          await loadSoundBuffer(url).then(buffer => {
            obj[i] = buffer
            loadDone()
          }).catch(() => {
            loadDone()
          })
        }
      }
    }
    loadSoundsObj(sounds)
  }
  function playSound(name, start, volume){ //from https://www.html5rocks.com/en/tutorials/webaudio/intro/
    if(!soundOn) return
    var sound
    if(name.includes(".")){
      sound = sounds
      name = name.split(".")
      for(var i=0; i<name.length; i++){
        var n = name[i]
        if(sound[n]){
          sound = sound[n]
        }else return
      }
    }else sound = sounds[name]
    var buffer = sound
    if(audioCtx && (typeof buffer !== "string")){
      var source = audioCtx.createBufferSource();
      source.buffer = buffer;
      if( (!(volume || volume === 0)) || volume === 1){
        source.connect(audioCtx.destination);
      }else{
        var gainNode = audioCtx.createGain();
        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.value = volume;
      }
      source.start(start || 0);
    }
  }
  win.playSound = playSound
  function blockSound(blockID, type, x,y,z){
    var block = blockData[blockID]
    var volume = 1
    if((x || x===0) && (y || y===0) && (z || z===0)){
      var falloff = volume > 16 ? 16*volume : 16
      var dist = dist3(x,y,z, p2.x, p2.y, p2.z)
      volume = dist > falloff ? volume - ((dist - falloff) / 4) : volume
      if(volume < 0) volume = 0
    }
    
    var sound
    switch(type){
      case "place":
        sound = block.placeSound || block.digSound
        break;
      case "dig":
        sound = block.digSound
        break;
      case "step":
        sound = block.stepSound
        break;
      case "breaking":
        sound = block.stepSound
        break;
    }
    if(Array.isArray(sound)){
      sound = sound[Math.floor(Math.random()*sound.length)]
    }
    if(sound){
      playSound(sound, 0, volume)
    }
  }
  win.blockSound = blockSound
  function hitSound(){
    var i = Math.ceil(Math.random()*3)
    playSound("damage.hit"+i)
  }
  win.hitSound = hitSound
  var explodeSounds = ["entity.generic.explode1", "entity.generic.explode2", "entity.generic.explode3", "entity.generic.explode4"]
  function explodeSound(x,y,z){
    var sound = explodeSounds[Math.floor(Math.random()*explodeSounds.length)]
    playSound(sound, 0, posSound(x,y,z))
  }
  win.explodeSound = explodeSound
  function posSound(x,y,z){
    var volume = 1
    if((x || x===0) && (y || y===0) && (z || z===0)){
      var falloff = volume > 16 ? 16*volume : 16
      var dist = dist3(x,y,z, p2.x, p2.y, p2.z)
      volume = dist > falloff ? volume - ((dist - falloff) / 4) : volume
      if(volume < 0) volume = 0
    }
    return volume
  }
  
  let maxHTTPLoad = 0, loaded = 0
  win.allLoaded = false
  function findObjValueAmount(obj){
    for(var i in obj){
      if(typeof obj[i] === "object"){
        findObjValueAmount(obj[i])
      }else maxHTTPLoad ++
    }
  }
  findObjValueAmount(sounds)
  loader.innerHTML = `<span class="name">Geekycraft</span>Loading 0% 0/${maxHTTPLoad}`
  function loadDone(){
    loaded ++
    let percent = Math.floor(loaded * 100 / maxHTTPLoad)
    loader.innerHTML = `<span class="name">Geekycraft</span>Loading ${percent}% ${loaded}/${maxHTTPLoad}`
    if(loaded === maxHTTPLoad){
      loader.classList.add("hidden")
      allLoaded = true
    }
  }
  
  function createNewWorld(){
      dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			world.id = Date.now()
			let name = boxCenterTop.value || "World"
			let number = ""
			while(true) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				} else {
					name = name + number
					break
				}
			}
			world.name = name.replace(/;/g, "\u037e")
			win.world = world
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)

      if(survival) setHotbar([blockIds.craftingTable,0,0,0,0,0,0,0,0])
			changeScene("loading")
  }
	
	function initEverything() {
		console.log("Initializing world.")

		worldSeed = Math.random() * 2000000000 | 0
    console.log("worldSeed "+worldSeed)
		seedHash(worldSeed)
		caveNoise = openSimplexNoise(worldSeed)
		noiseProfile.noiseSeed(worldSeed)

    win.islandGenerator = new Generator();
    
		generatedChunks = 0

    crack.shape = shapes.cube

		initWebgl()
    initPlayer()

		if (win.location.origin === "https://www.kasandbox.org" && (loadString || Geekycraft.toString().length !== 183240)) {
			// Prevent Ctrl F
			message.innerHTML = '.oot lanigiro eht tuo kcehc ot>rb<erus eb ,siht ekil uoy fI>rb<.dralliW yb >a/<nahKeniM>"wen_"=tegrat "8676731005517465/cm/sc/gro.ymedacanahk.www//:sptth"=ferh a< fo>rb<ffo-nips a si margorp sihT'.split("").reverse().join("")
		}

		initBackgrounds()
		
		drawScreens[screen]()
		Button.draw()
		Slider.draw()

		p.FOV(settings.fov)
		initWorldsMenu()
    //initServersMenu() //dont do because it will alert
    initMarketplace()
		initButtons()
    
    initAudioCtx()
	}

	// Define all the scene draw functions
	(function() {
    var splashs = [
      "Multiplayer!",
      "Survival!",
      "Flowers? Make a garden!",
      "HOW DID YOU COME TO THIS CRAPPY WEBSITE?",
      "Nether!",
      "Can't break bedrock."
    ]
    let splash = ""
    function rdmSplash(){
      splash = splashs[Math.floor(Math.random()*splashs.length)]
    }
    rdmSplash()
    setInterval(() => rdmSplash(), 60000)
		function title() {
			let title = "Geekycraft"
			let subtext = "JAVASCRIPT EDITION"
			let font = "VT323,monospace"
			strokeWeight(1)
			ctx.textAlign = 'center'

			ctx.font = "bold 120px " + font
			fill(/*30*/70)
			text(title, width / 2, 158)
			//fill(40)
			text(title, width / 2, 155)
			ctx.font = "bold 121px " + font
			//fill(50)
			text(title, width / 2, 152)
			//fill(70)
			text(title, width / 2, 150)
			//fill(90)
			ctx.font = "bold 122px " + font
			text(title, width / 2, 148)
			fill(110)
			text(title, width / 2, 145)

			ctx.font = "bold 32px " + font
			fill(50)
			text(subtext, width / 2-1, 180)
			text(subtext, width / 2+1, 180)
			text(subtext, width / 2, 179)
			text(subtext, width / 2, 181)
			ctx.font = "bold 32px " + font
			fill(150)
			text(subtext, width / 2, 180)
      
      fill(230,220,0)
			ctx.translate(width/2 + 280,170)
			ctx.rotate(-Math.PI/8);
			ctx.font = "bold "+(Math.round((size/40)*6+30))+"px " + font
			text(splash, 0,0)
			ctx.rotate(Math.PI/8);
			ctx.translate(-(width/2+280),-170)
		}
		const clear = () => ctx.clearRect(0, 0, canvas.width, canvas.height)
		const dirt = () => ctx.putImageData(dirtbg, 0, 0)
    const nether = () => ctx.putImageData(netherbg, 0, 0)

    var size = 0
    var sizes = 0
    var sizess = 1
		drawScreens["main menu"] = () => {
      sizes += sizess
      if((sizes > 10) || (sizes < -10)){
        sizess = -sizess
      }
      size += sizes
			title()
			fill(220)
			ctx.font = "20px VT323"
			ctx.textAlign = 'left'
			text("Minecraft " + version, width - (width - 2), height - 2)
		}

		drawScreens.play = () => {
      for(var i=0; i<9; i++){
        if(inventory.hotbar[i].id && inventory.hotbar[i].amount < 1){
          inventory.hotbar[i] = 0
          holding = inventory.hotbar[inventory.hotbarSlot].id
          updateHUD = true
        }
      }
      
			controls()
			runGravity()
      
      if(survival){
        cracks()
      }
      var now = Date.now()
      if(witherEffect>0){
        witherEffect --;
        if(survival && now-lastBlockHarm > witherTime){
          lastBlockHarm = now
          p.health -= witherDamage
          harmEffect = 40
          hitSound()
          updateHUD = true;
        }
      }
      
      if(now - lastHeal > healTime) {
        lastHeal = now
        if(p.health < 18){
          p.health += 1
          healEffect = 40
          updateHUD = true
        }
      }
			if(p.health > 18) {
			  p.health = 18;
			}
      
      if(harmEffect > 0){
        harmEffect --
        updateHUD = true
      }
      if(healEffect > 0){
        healEffect --
        updateHUD = true
      }
      
			var posInfo = resolveContactsAndUpdatePosition()
      if(posInfo.damage && survival && now-lastBlockHarm > 500){
        lastBlockHarm = now
        p.health -= posInfo.damage
        harmEffect = 40
        hitSound()
        updateHUD = true;
      }

			if (updateHUD) {
				clear()
				gl.clearColor(0, 0, 0, 0)
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
				hud()
				ctx.drawImage(gl.canvas, 0, 0)
				updateHUD = false
				freezeFrame = false

				gl.clearColor(sky[0], sky[1], sky[2], 1.0)
			}
			defineWorld()
      
      if(harmEffect > 0){
        fill(255,0,0, harmEffect)
        ctx.fillRect(0,0,width,height)
      }
      if(portalEffect > 0){
        fill(255,0,255, portalEffect)
        ctx.fillRect(0,0,width,height)
        updateHUD = true
        portalEffect --
      }
      
      if(mouseDown && touchScreen){
		if (p.lastBreak < Date.now() - 250 && screen === "play" && !survival && p.onGround) { // if survival breaking isn't instant
			changeWorldBlock(0)
		}
		else if (p.lastPlace < Date.now()-250&& screen === "play" && !survival && !p.onGround) {
			newWorldBlock()
		}
		ctx.beginPath()
        fill(255)
        strokeWeight(2)
        ellipse(pTouch.x, pTouch.y, 70,70)
        ctx.stroke()
        updateHUD=true
      }
      
      if(p.health < 1){
        changeScene("dead")
        releasePointer()
        
        drawScreens.dead()
        Button.draw()
        Slider.draw()
      }
      
      if(posInfo.ontouch){
        posInfo.ontouch(posInfo.x, posInfo.y, posInfo.z)
      }
      
      if((Key.w || Key.a || Key.s || Key.d) && p.onGround){
        let limit = 500
        if(p.sprinting) limit = 350
        if(now - lastStepSound > limit){
          lastStepSound = now
          blockSound(world.getBlock(p2.x, p2.y-2, p2.z), "step")
        }
      }
		}

    drawScreens.dead = () => {
      ctx.drawImage(gl.canvas, 0, 0)
      
      ctx.fillStyle = "rgba(255,0,0,50%)"
      ctx.fillRect(0,0,width,height)
      
      fill(0)
      ctx.font = "50px Arial"
      ctx.textAlign = "center"
      ctx.fillText("You died", width/2, 100)
      
    }
    
		drawScreens.loading = () => {
      win.world = world = dimensions.overworld
			// This is really stupid, but it basically works by teleporting the player around to each chunk I'd like to load.
			// If chunks loaded from a save aren't generated, they're deleted from the save, so this loads them all.
			let frameStart = win.performance.now()+1
			let sub = maxLoad - world.loadFrom.length - 9
            if (superflat === "island") {
                if (win.islandGenerator.stage < 10) {
                    if (!win.islandGenerator.seedSet) {
                        win.islandGenerator.SetSeed(noiseProfile.seed)
                    }
                    win.islandGenerator.Generate(frameStart);
                }   else {
                    let standing = true
        			if (world.loadFrom.length) {
        				let load = world.loadFrom[0]
        				p.x = load.x * 16
        				p.y = load.y * 16
        				p.z = load.z * 16
        				standing = false
        			} else {
        				p.x = p2.x
        				p.y = p2.y
        				p.z = p2.z
        
        				let cx = p.x >> 4
        				let cz = p.z >> 4
        
        				for (let x = cx - 1; x <= cx + 1; x++) {
        					for (let z = cz - 1; z <= cz + 1; z++) {
        						if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
        							standing = false
        						} else {
        							sub++
        						}
        					}
        				}
        			}
        
        			if (standing) {
        				play()
        				return
        			}
			        world.tick()
                }
            }   else {
                let standing = true
    			if (world.loadFrom.length) {
    				let load = world.loadFrom[0]
    				p.x = load.x * 16
    				p.y = load.y * 16
    				p.z = load.z * 16
    				standing = false
    			} else {
    				p.x = p2.x
    				p.y = p2.y
    				p.z = p2.z
    
    				let cx = p.x >> 4
    				let cz = p.z >> 4
    
    				for (let x = cx - 1; x <= cx + 1; x++) {
    					for (let z = cz - 1; z <= cz + 1; z++) {
    						if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
    							standing = false
    						} else {
    							sub++
    						}
    					}
    				}
    			}
    
    			if (standing) {
    				play()
    				return
    			}
		        world.tick()
          }

			let progress = Math.round( (superflat==="island"?50:100) * sub / maxLoad)
			if(superflat === "island")progress += Math.round((win.islandGenerator.stage/9.0+win.islandGenerator.h/win.islandGenerator.size*3/9)*50)
			
			dirt()
			fill(255)
			textSize(30)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
		}
    drawScreens.netherLoading = () => {
      win.world = world = dimensions.nether
			let frameStart = win.performance.now()+1
			let sub = maxLoad - world.loadFrom.length - 9
      let standing = true
      if (world.loadFrom.length) {
        let load = world.loadFrom[0]
        p.x = load.x * 16
        p.y = load.y * 16
        p.z = load.z * 16
        standing = false
      } else {
        p.x = p2.x
        p.y = p2.y
        p.z = p2.z

        let cx = p.x >> 4
        let cz = p.z >> 4

        for (let x = cx - 1; x <= cx + 1; x++) {
          for (let z = cz - 1; z <= cz + 1; z++) {
            if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
              standing = false
            } else {
              sub++
            }
          }
        }
      }

      if (standing) {
        play()
        return
      }
      world.tick()

			let progress = Math.round(100 * sub / maxLoad)
			
			nether()
			fill(255)
			textSize(30)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
		}

		drawScreens.inventory = drawInv
    
    drawScreens.crafting = drawCrafting

		drawScreens.pause = () => {
			strokeWeight(1)
			clear()
			ctx.drawImage(gl.canvas, 0, 0)

			textSize(60)
			fill(0, 0, 0)
			ctx.textAlign = 'center'
			text("Paused", width / 2, 60)
		}

		drawScreens.options = () => {
			clear()
		}
		drawScreens["creation menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Create New World", width / 2, 20)
		}
		drawScreens["loadsave menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Select World", width / 2, 20)
		}
    drawScreens["multiplayer menu"] = () => {
      dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Multiplayer (Alpha)", width / 2, 20)
    }
		drawScreens.editworld = dirt
    drawScreens.marketplace = () => {
      dirt()
      ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Marketplace", width / 2, 20)
    }
	})()

	// Give the font time to load and redraw the homescreen
	setTimeout(e => {
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
	}, 100)

	let debugMenu = false
	function gameLoop() {
		let frameStart = performance.now()
		if (!gl) {
			initEverything()
			releasePointer()
		}

    if(allLoaded){
      if (screen === "play" || screen === "loading" || screen === "netherLoading") {
        drawScreens[screen]()
        if(touchScreen && screen === "play") Button.draw()
      }

      if(screen === "main menu" || screen === "options"){
        if(screen === "options"){
          if(previousScreen === "main menu"){
            renderMainBG()
          }
        }else{
          renderMainBG()
        }
        drawScreens[screen]()
        Button.draw()
        Slider.draw()
      }
    }

		if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
			analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1)
			analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1)
			analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1)
			analytics.fps = round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate))
			analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1)
			analytics.frames = 0
			analytics.totalRenderTime = 0
			analytics.totalTickTime = 0
			analytics.totalFrameTime = 0
			analytics.worstFrameTime = 0
			analytics.lastUpdate = Date.now()
			updateHUD = true
		}

		analytics.frames++
		analytics.totalFrameTime += performance.now() - frameStart
		analytics.worstFrameTime = max(performance.now() - frameStart, analytics.worstFrameTime)
		win.raf = requestAnimationFrame(gameLoop)
	}
	return gameLoop
}

var init = Geekycraft()
if (window.parent.raf) {
	window.cancelAnimationFrame(window.parent.raf)
	console.log("Canceled", window.parent.raf)
}
init()


	</script>
    
    <script>
function hcyl(bottom, height, radius, id) {
    let radsq = radius * radius
    let innerRadsq = (radius - 1.2) * (radius - 1.2)
    height += bottom
    for (let x = -radius; x <= radius; x++) {
        for (let y = bottom; y < height; y++) {
            for (let z = -radius; z <= radius; z++) {
                let d = x * x + z * z
                if (d < radsq && d >= innerRadsq) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function cyl(bottom, height, radius, id) {
    let radsq = radius * radius
    height += bottom
    for (let x = -radius; x <= radius; x++) {
        for (let y = bottom; y < height; y++) {
            for (let z = -radius; z <= radius; z++) {
                let d = x * x + z * z
                if (d < radsq) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function sphereoid(w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d
    let w3 = (w - 1.5) * (w - 1.5)
    let h3 = (h - 1.5) * (h - 1.5)
    let d3 = (d - 1.5) * (d - 1.5)

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                let n2 = x * x / w3 + y * y / h3 + z * z / d3
                if (n < 1 && n2 >= 1) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function sphereoidAt(X,Y,Z,w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d
    let w3 = (w - 1.5) * (w - 1.5)
    let h3 = (h - 1.5) * (h - 1.5)
    let d3 = (d - 1.5) * (d - 1.5)

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                let n2 = x * x / w3 + y * y / h3 + z * z / d3
                if (n < 1 && n2 >= 1) {
                    world.setBlock(X + x, Y + y, Z + z, id)
                }
            }
        }
    }
}

function explode(x,y,z, radius){
  world.setBlock(x,y,z,blockIds.air);
  for(var i=radius; i>0; i--){
    sphereoidAt(x,y,z,i,i,i, blockIds.air)
  }
  explodeSound(x,y,z)
}

if (("serviceWorker" in navigator) && location.origin === "https://geeky-people.herokuapp.com/geekycraft.html") {
  window.addEventListener("load", function() {
    navigator.serviceWorker
      .register("/sw.js")
      .then(res => console.log("service worker registered"))
      .catch(err => console.log("service worker not registered", err))
  })
}
    </script>
	</body>
</html>
