<!DOCTYPE html>
<!-- @MineKhan version Alpha 1.0.3

	Notes and accreditation:
!!Willard is another person, not me!!
My credits (not Willard's)
 * Thanks to Red Monster (https://www.khanacademy.org/profile/monsterred) for the block shapes
 * Shoos10 (https://www.khanacademy.org/profile/kaid_651789387350300127259402) created the Island World type
 * I created the survival mode

Willard's credits
 * This program (MineKhan) was made by Willard (me). The original is https://www.khanacademy.org/cs/mc/5647155001376768 (just adding this so that spin-offs have it)
 * Zushah helped me with some of the menus in the 0.6 update via GitHub. https://www.khanacademy.org/profile/zushah77
 * Element118 helped speed up the process of adding new textures significantly. https://www.khanacademy.org/profile/element118
 * Danielkshin made the current main menu background. https://www.khanacademy.org/profile/danielkshin

 * This program originated as a spin-off of ScusCraft by ScusX.
 * It's 99% different code at this point, but I still never would have made it this far without his code for reference.
 * ScusCraft can be found here: https://www.khanacademy.org/computer-programming/scuscraft-3d/5145400332058624
 * My original spin-off can be found here: https://www.khanacademy.org/computer-programming/high-performance-minecraft/5330738124357632
 * While porting the code from PJS to a webpage, I copied the PJS source code for a few of their helper functions from here: https://raw.githubusercontent.com/Khan/processing-js/master/processing.js
 * The textures are 100% copied from real Minecraft, and are the property of Mojang and Microsoft with whom I have no association.
 * The real Minecraft game can be bought and downloaded at https://www.minecraft.net/en-us/


 * Chunks are kept in memory until you restart. So don't explore too far or memory usage will grow until it crashes unrecoverably.
-->

<html>
	<head>
		<meta charset="utf-8">
		<title>MineKhan Alpha 1.0.3</title>
       <!--Metadata-->
    <meta name="keywords" content="Minekhan"> <!--search "Minekhan" on Google-->
    <meta name="description" content="Minekhan with survival and nether and many more features">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" id="themeColor">
    
		<link id="vtfont" href="assets/fonts/css2.css&display=swap" rel="stylesheet">
    <style>@font-face{font-family: 'VT323'; src:url('assets/fonts/mojangles.ttf');}</style>
		<link rel="shortcut icon" type="image/ico" href="assets/favicon.ico">
    <link rel="manifest" href="assets/manifest.json">
	</head>
	<style>
		body {
			overflow: hidden; /* Hide scrollbars */
		}
    button, #onscreenControls, canvas, #loader{
		  /*get rid of user select*/
			-webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
		}
		.world-select {
			width: 99vw;
			min-width: 300px;
			height: calc(100vh - 220px);
			position: absolute;
			bottom: 120px;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			margin: 0 auto;
		}
		.world {
			width: 50%;
			height: auto;
			border: 1px solid black;
			font-size: 13px;
			font-family: 'VT323', 'Courier New', Courier, monospace;
			color: rgb(180, 180, 180);
			margin: 0 auto;
			margin-top: 15px;
			padding: 5px;
			cursor: pointer;
      position:relative;
		}
    .world .thumbnail{
      float:left;
      margin-right:8px;
      width:70px;
      height:70px;
    }
    .world .thumbnailHover{
      position:absolute;
      left:5px;
      top:5px;
      background:#fff8;
      opacity:0;
      width:70px;
      height:70px;
      background-image: url("assets/images/world_selection.png");
      background-position: 0 0;
      background-size: 800%;
      image-rendering: pixelated;
    }
    .world:hover .thumbnailHover{
      opacity:1;
    }
    .world .thumbnailHover:hover{
      background-position: 0 -70px;
    }
    .world .ping{
      float:right;
    }
    .world .ping .img{
      width:20px;
      height:14px;
      image-rendering:pixelated;
      background-image: url("assets/images/ping.png");
      background-position: 0 0;
      background-size: 40px 600%;
    }
    .world-select .message{
      font-size: 15px;
			font-family: 'VT323', 'Courier New', Courier, monospace;
			color: rgb(180, 180, 180);
      margin-top: 15px;
      text-align:center;
    }
		strong {
			color: white;
		}
    a{
      color:#37f;
      text-decoration:none;
    }
    a:hover{
      text-decoration:underline;
    }
		.selected {
			outline: 3px solid white;
		}
		input[type=text] {
			background-color: black;
			caret-color: white;
			border: 2px solid gray;
			color: white;
			font-size: 24px;
			padding-left: 12px;
		}
		input[type=text]:focus {
			border: 2px solid lightgray;
		}
		#boxcentertop {
			z-index: 1;
			width: 80vw;
			max-width: 400px;
			height: 50px;
			position: relative;
			top: 30px;
			display: block;
			margin: 0 auto;
		}
    #editworld{
      z-index: 1;
			width: 80vw;
			max-width: 400px;
      position:relative;
      top:90px;
      margin:0 auto;
    }
    #editworld input{
      width:100%;
      height: 50px;
			display: block;
			margin: 10px 0;
    }
		.hidden {
			display: none !important;
		}
		#onhover {
			background-color: rgba(0, 0, 0, 0.9);
			color: rgb(200, 200, 200);
			font-family: VT323, 'Courier New', Courier, monospace;
      font-size:13px;
			word-wrap: normal;
			width: auto;
			max-width: 400px;
			position: absolute;
			z-index: 1;
			padding: 10px;
			cursor: default;
		}
		#quota {
			display: block;
			position: absolute;
			width: 99vw;
			margin: 0 auto;
			bottom: 110px;
			z-index: 1;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			text-align: center;
			color: white;
		}
    #messagesHolder{
      position:absolute;
      z-index:2;
      top:0px;
      left:0px;
      background:#000a;
      color:white;
      font:18px 'VT323';
      max-height:100%;
    }
    #messageInput{
      border:none;
      background:transparent;
      width:100%;
      min-width:100px;
      color:white;
      font:18px 'VT323';
    }
    /*#messages{
      display: flex;
      align-items: flex-end;
    }*/
    #help{
      position:absolute;
      z-index:2;
      top:50px;
      left:0px;
      width:100vw;
      height:calc(100vh - 50px);
      background:#0000;
      color:white;
      font:15px VT323;
      display:flex;
      flex-direction:row;
    }
    #help > .nav{
      width:20%;
      background:#0008;
    }
    #help > .nav > a{
      display:block;
      padding:8px;
      width:100%;
      text-decoration:none;
      color:white;
      cursor:pointer;
    }
    #help > .content{
      width:80%;
      padding:10px;
      overflow:scroll;
      background:#0004;
    }
    #help > .content > div{
      margin-bottom:100px;
    }
    #help > .content pre{
      font:15px VT323;
    }
    #help h1{font-size:25px;}
    #help h2{font-size:18px;}
    #help img{max-width:100%;}
    #onscreenControls{
		    position:fixed;
		    font-family:monospace;
		    bottom:10px;
		    width:100%;
		}
		#onscreenControls button{
		    margin:0;
        min-width:calc(100% / 13);
        min-height:40px;
        border-radius:0px;
        background:#888;
        border-color:#aaa #666 #666 #aaa;
        border-width:2px;
        border-style:solid;
        color:white;
        outline:none;
		}
		#onscreenControls button:active{
	      background:#9a9a9a;
        border-color:#888 #aaa #aaa #888;
		}
		#onscreenControls #buttonsRight{
		    position:absolute;
		    bottom:10px;
		    right:10px;
		}
    #onscreenControls #buttonsTop{
		    position:absolute;
		    top:10px;
        left:10px;
        width:calc(100% - 20px);
        display:flex;
        align-items:center;
		}
    #loader{
      background:#111;
      color:white;
      position:absolute;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      font-size:30px;
      font-family:Arial;
      display:flex;
      justify-content:center;
      align-items:center;
      flex-direction:column;
      z-index:2;
    }
    #loader .name{
      width:433px;
      /*
        font-size:60px;
        font-family:VT323;
      */
    }
    #loader .name > img{
      width:100%;
    }
    #loadingImg{
      width:42px;
      image-rendering:pixelated;
    }
    #loadBar{
      border:2px solid #eee;
      width:40%;
      padding:2px;
    }
    #loadBar div{
      height:10px;
      width:0px;
      background:#eee;
    }
    .darklinks a{
      color:blue;
    }
    
    .collapsible{
      color:black;
    }
    .collapsible .title{
      background-color: #777;
      color: white;
      cursor: pointer;
      padding: 18px;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
    }

    .collapsible .title:hover {
      background-color: #555;
    }
    .collapsible .title:after {
      content: '\02795'; /* Unicode character for "plus" sign (+) */
      font-size: 13px;
      color: white;
      float: right;
      margin-left: 5px;
    }
    .collapsible .title.active:after{
      content: "\2796"; /* Unicode character for "minus" sign (-) */
    }

    .collapsible .content {
      padding: 0 18px;
      background-color: #f1f1f1;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.2s ease-out;
    }
    
    .recipe{
      background:#7f7f7f;
      border:1px solid black;
      padding:10px;
      margin:20px;
      display:inline-block;
    }
    .recipe .grid {
      display:inline-block;
      outline: 2px solid black;
    }
    .recipe .grid > img, .recipe .grid > div {
      outline: 1px solid black;
      display:inline-block;
    }
    .recipe .result{
      outline: 1px solid black;
      display:inline-block;
      position:relative;
    }
    .recipe .result .number{
      position:absolute;
      color:white;
      bottom:0;
      right:0;
      font-size:14px;
    }
	</style>
	<body>
	<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
	<input type="text" id="savebox" class="hidden" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;">
	<input type="text" id="boxcentertop" class="hidden" spellcheck="false">
	<div id="quota" class="hidden"></div>
  <div id="editworld" class="hidden">
    <input type="text" id="url" spellcheck="false" placeholder="Enter thumbnail url">
  </div>
	<div id="onhover" class="hidden"></div>
	<p id="savedirections" class="hidden" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
		To save your world, copy/paste the saveString<br>
		from this box into the code on line 189.<br>
		var loadString = "Your Code Here";<br>
		Then save the program as a Spin-off.
	</p>
	<div class="world-select hidden" id="worlds"></div>
  <div class="world-select hidden" id="servers"></div>
  <div class="world-select hidden" id="marketplace"></div>
	<p id="message" class="hidden darklinks" style="position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"></p>
  <div id="messagesHolder" class="hidden">
    <input id="messageInput" class="hidden">
    <div id="messages"></div>
  </div>
  <div id="help" class="hidden">
    <div class="nav">
      <a onclick="scrollToEl('help_about')">About</a>
      <a onclick="scrollToEl('help_loadsave')">Load save menu</a>
      <a onclick="scrollToEl('help_controls')">Controls</a>
      <a onclick="scrollToEl('help_health')">Health</a>
      <a onclick="scrollToEl('help_inventory')">Inventory</a>
      <a onclick="scrollToEl('help_crafting')">Crafting</a>
    </div>
    <div class="content">
      <div id="help_about">
        <h1>About MineKhan</h1>
        MineKhan is a sandbox video game just like Minecraft.<br>
        MineKhan has things Minecraft doesn't.<br>
        MineKhan doesn't have some things Minecraft has.<br>
        If you want to suggest stuff, you should go to my website: <a href="https://www.thingmaker.repl.co/website/posts.html" target="_blank">https://www.thingmaker.repl.co</a>
        <h2>Where MineKhan came from</h2>
        One upon a time, there was a game on Khan Academy called Scuscraft.<br>
        One day, Willard spin-offed Scusraft and made MineKhan.<br>
        After many days, he ported it from a pjs program to to a webpage.<br>
        Then, when Willard made his own website (willard.fun), thingMaker copied the code and programmed it more so soon it became this.<br>
        The End.
      </div>
      <div id="help_loadsave">
        <h1>Load save menu</h1>
        The load save menu is where you load and create worlds.<br>
        <img src="https://data.thingmaker.repl.co/images/help/loadsave.png" style="border:1px solid white;"><br>
        To select a world, you click it.<br>
        The create new world button takes you to the Create world menu.<br>
        The play selected world button loads the selected world.<br>
        <span style="color:yellow; font-family:fantasy;display:none;">"Congratulations, you graduate!" - Iruka Sensei<br></span>
        The edit button takes you to the Edit world menu.<br>
        The delete button deletes the selected world.<br>
        The export button puts the save code of the selected world in the input box.<br>
        The cancel button takes you back to the main menu.
      </div>
      <div id="help_controls">
        <h1>Controls</h1>
        <b>These controls are used only when playing in a world</b><br>
<pre> * Right-click (or ctrl + left-click): place block
 * Left-click: Remove block
 * Middle-click: Pick block
 * Q: Sprint
 * Shift: Sneak
 * W: Walk forward
 * S: Walk backward
 * A: Walk left
 * D: Walk right
 * E: Open inventory
 * B: Toggle super Breaker
 * Z: Zoom
 * L: Toggle Spectator mode
 * Enter: Toggle slab/stair mode
 * Arrow Keys: look around
 * P or Esc: pause/unpause
 * 1-9 navigate hotbar
 * Spacebar: jump
 * Double jump: toggle flight
 * Shift (flying): fly down
 * Space (flying): fly up
 * T: Reload textures
 * ; (semicolon): Release the pointer without pausing (for screenshots)
 * Backspace or delete: drops the item you're holding right now
 * / to open chat
 * H for Hyper builder
 * O to toggle third person mode</pre>
      </div>
      <div id="help_health">
        <h1>Health</h1>
        Health is a feature only in survival.<br>
        A heart looks like this: <div img="heart"></div><br>
        A half heart looks like this: <div img="halfHeart"></div><br>
        When you create a new world, you start with 20 <div img="heart" amount="10"></div> health.<br>
        When you have 0 <div img="deadHeart" amount="10"></div> health, you die.
        <h2>Losing health</h2>
        There are many ways to lose health inluding fall damage, being attacked by other players, and touching cactus and lava.
        <h2>Effects</h2>
        There are effects that change how the hearts look.<br>
        When you are withered, it looks like this: <img src="assets/images/witherHealthBar.gif"><br>
        When you are freezing, it looks like this: <img src="assets/images/freezeHealthBar.gif">
      </div>
      <div id="help_inventory">
        <h1>Inventory</h1>
        When playing a world, press e to open the inventory.<br><br>
        <h2>Creative inventory</h2>
        <img src="assets/images/help/inventory.png" style="border:1px solid white;"><br>
        <h2>Survival inventory</h2>
        <img src="assets/images/help/survival_inventory.png" style="border:1px solid white;"><br>
        More info will come soon.
      </div>
      <div id="help_crafting">
        <h1>Crafting</h1>
        You can access the crafting grid from the inventory or by right clicking a crafting table.<br>
        The inventory crafting grid is 2&times;2.<br>
        The crafting table's crafting grid is 3&times;3.<br>
        Some things require a crafting table to be crafted.<br><br>
        <h2>Recipes</h2>
        Click the collapsible to see crafting recipes
        <div class="collapsible" title="Recipes" id="recipes">
          oh wait, it's kinda hard to show the recipes 'cause i don't have images
        </div>
      </div>
      
    </div>
  </div>
  <div id="onscreenControls" class="hidden">
	  <button style="visibility:hidden;">&nbsp;</button><button id="controlW">W</button>
	  <br>
	  <button id="controlA">A</button><button style="visibility:hidden;">&nbsp;</button><button id="controlD">D</button>
	  <br>
	  <button style="visibility:hidden;">&nbsp;</button><button id="controlS">S</button>
    <div id="buttonsRight">
      <button id="controlSpace">space</button>
      <br>
      <button id="controlShift">shift</button>
    </div>
    <!--<div id="buttonsTop">
      <button id="controlPause">Pause</button>
    </div>-->
  </div>
  <div id="loader">
    <div class="name"><img src="assets/images/minekhan.png"></div><br>
    <img src="assets/images/loading.gif" id="loadingImg"><br><br>
    <div id="loadBar">
      <div></div>
    </div>
    <div id="loadProgress"></div>
  </div>
  
	<script>
		// Code edits will erase the world.
		// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
		var loadString = ""
	</script>
  <!--url for parkour map: https://www.khanacademy.org/cs/i/4676725830008832-->
 	<script type="x-shader/vertex" id="blockVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		attribute float aShadow;
		attribute float aSkylight;
		attribute float aBlocklight;
		varying vec2  vTexture;
		varying float vShadow;
		varying float vFog;
    varying float waterFog;
		uniform mat4 uView;
		uniform float uDist;
		uniform vec3 uPos;
		uniform float uTime;
    uniform vec3 skyColor;

		void main() {
      float x = aTexture.x;
      float y = aTexture.y / 4.0;
			vTexture = vec2(x,y);
			// If you are going to change this final lightlevel calculation
			// you have to change line 4487 as well since it calculates lightlevel of entity based on this
			vShadow = aShadow * min(max(aSkylight * uTime, aBlocklight) * 0.9 + 0.1, 1.0);
			gl_Position = uView * vec4(aVertex, 1.0);

			float range = max(uDist / 5.0, 8.0);
			vFog = clamp((length(uPos.xz - aVertex.xz) - uDist + range) / range, 0.0, 1.0);
      
      waterFog = min(gl_Position.z / 150.0, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="blockFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uTime;
    uniform bool uTrans;
    uniform vec3 skyColor;
    uniform int inWater;
		varying float vShadow;
		varying vec2 vTexture;
		varying float vFog;
    varying float waterFog;
    vec4 blueShift(vec4 color) {
      color.rg *= 1.0 - waterFog;
      color.r = color.r * (50.0/255.0) * max(waterFog/2., 1.);
      color.g = color.g * (210.0/255.0) * max(waterFog/2., 1.);
      color.b += (0.9 - color.b) * waterFog;
      return vec4(color.r * 0.9, color.g * 0.9, min(color.b + 0.3, 1.0), color.a);
	  }
    vec4 redShift(vec4 color) {
      return vec4(mix(color.rgb, vec3(255.,0.,0.), waterFog*12.), color.a);
	  }

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
      if (color.a != 1.0) color.a = mix(color.a, 0.0, vFog);
      color = vec4(mix(color.rgb * vShadow, skyColor * uTime, vFog), color.a);
      if (inWater == 1) color = blueShift(color);
      if (inWater == 2) color = redShift(color);
			gl_FragColor = color;
			if (gl_FragColor.a == 0.0) discard;
      else if (!uTrans && gl_FragColor.a != 1.0) discard;
      else if (uTrans && gl_FragColor.a == 1.0) discard;
		}
	</script>
  <script type="x-shader/vertex" id="panoramaVertexShader">
    attribute vec3 aVertex;
    uniform float textureX;
    uniform mat4 uView;
    
    void main(){
      gl_Position = uView * vec4(aVertex, 1.0);
    }
  </script>
  <script type="x-shader/fragment" id="panoramaFragmentShader">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif
    
    uniform float textureX;
    uniform float textureW;
    uniform float textureH;
    uniform sampler2D uSampler;
    uniform vec2 u_resolution;
    
    void main(){
      float tw = textureW / u_resolution.x;
      vec2 uv = gl_FragCoord.xy / u_resolution;
      float x = mod((uv.x/tw)+textureX, 1.);
			vec4 color = texture2D(uSampler, vec2(x, 1.-uv.y));
			gl_FragColor = color;
			if (gl_FragColor.a == 0.0) discard;
		}
  </script>
  <script type="x-shader/vertex" id="skyboxVertexShader">
    attribute vec3 aVertex;
    uniform float time;
    uniform mat4 uView;
    varying vec3 position;
    mat4 no_translate (mat4 mat) {
        mat4 nmat = mat;
        nmat[3].xyz = vec3(0.);

        return nmat;
    }
    void main(void) {
       position = aVertex;
       gl_Position = no_translate(uView) * vec4(aVertex * -100., 0.0);
    }
  </script>
  <script type="x-shader/fragment" id="skyboxFragmentShader">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    uniform float time;
    varying vec3 position;
    vec2 rotate2D (vec2 p, float angle){
       return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));
    }
        float rand2D(in vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    float rand3D(in vec3 co){
        return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);
    }
        float simple_interpolate(in float a, in float b, in float x)
    {
       return a + smoothstep(0.0,1.0,x) * (b-a);
    }

    float interpolatedNoise3D(in float x, in float y, in float z)
    {
        float integer_x = x - fract(x);
        float fractional_x = x - integer_x;

        float integer_y = y - fract(y);
        float fractional_y = y - integer_y;

        float integer_z = z - fract(z);
        float fractional_z = z - integer_z;

        float v1 = rand3D(vec3(integer_x, integer_y, integer_z));
        float v2 = rand3D(vec3(integer_x+1.0, integer_y, integer_z));
        float v3 = rand3D(vec3(integer_x, integer_y+1.0, integer_z));
        float v4 = rand3D(vec3(integer_x+1.0, integer_y +1.0, integer_z));

        float v5 = rand3D(vec3(integer_x, integer_y, integer_z+1.0));
        float v6 = rand3D(vec3(integer_x+1.0, integer_y, integer_z+1.0));
        float v7 = rand3D(vec3(integer_x, integer_y+1.0, integer_z+1.0));
        float v8 = rand3D(vec3(integer_x+1.0, integer_y +1.0, integer_z+1.0));

        float i1 = simple_interpolate(v1,v5, fractional_z);
        float i2 = simple_interpolate(v2,v6, fractional_z);
        float i3 = simple_interpolate(v3,v7, fractional_z);
        float i4 = simple_interpolate(v4,v8, fractional_z);

        float ii1 = simple_interpolate(i1,i2,fractional_x);
        float ii2 = simple_interpolate(i3,i4,fractional_x);

        return simple_interpolate(ii1 , ii2 , fractional_y);
    }

    float Noise3D(in vec3 coord, in float wavelength)
    {
       return interpolatedNoise3D(coord.x/wavelength, coord.y/wavelength, coord.z/wavelength);
    }
    float noise (vec3 p, float frequency) {
    float sum = 0.0;
    for(float i = 0.0; i<5.0; i++) {
    sum += Noise3D(p * frequency * pow(2.0, i), 1.0) / pow(2.0, i);
    } return sum * 0.5; }
    vec3 SUN_POSITION (float ftime) { return normalize(vec3(sin(ftime), cos(ftime), sin(ftime))); }
    const vec3 skyColor = vec3(0., 0.6, 0.9);
    const vec3 sunColor = vec3(1.0, 1.0, 0.6);
    void main (void) {
       vec3 sun = SUN_POSITION(time);
       float sunset = 1.-abs(dot(sun, vec3(0., 1., 0.)));
       vec3 horizonColor = mix(vec3(0., 0.8, 0.8), vec3(0.8, 0.4, 0.), sunset);
       vec3 dir = normalize(position);
       float horizonal = 1.-abs(dot(dir, vec3(0., 1., 0.)));
       vec3 col = mix(skyColor, horizonColor, horizonal);
       col = mix(col, sunColor, smoothstep(0.96, 0.98, dot(dir, sun)));
       float night = smoothstep(-1.0, 0.0, -sun.y);
       gl_FragColor = vec4(col * night, 1.0);
    }
  </script>
	<script type="x-shader/vertex" id="entityVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		varying vec2  vTexture;
		uniform mat4 uView;

		void main() {
			float x = aTexture.x;
      float y = aTexture.y / 4.0;
			vTexture = vec2(x,y);
			gl_Position = uView * vec4(aVertex, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="entityFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uLightLevel;
    uniform float harmEffect;
		varying vec2 vTexture;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
      color.rgb = mix(color.rgb, vec3(255.,0.,0.), harmEffect/255.);
			gl_FragColor = vec4(color.rgb * uLightLevel, color.a);
      if (gl_FragColor.a == 0.0) discard;
		}
	</script>
  <script type="x-shader/vertex" id="particleVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		varying vec2  vTexture;
		uniform mat4 uView;

		void main() {
			float x = aTexture.x;
      float y = aTexture.y / 4.0;
			vTexture = vec2(x,y);
			gl_Position = uView * vec4(aVertex, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="particleFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uLightLevel;
		varying vec2 vTexture;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * uLightLevel, color.a);
      if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="x-shader/vertex" id="2dVertexShader">
		attribute vec2 aVertex;
		attribute vec2 aTexture;
		attribute float aShadow;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vTexture = aTexture;
			vShadow = aShadow;
			gl_Position = vec4(aVertex, 0.5, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="2dFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * vShadow, color.a);
			if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="application/javascript">
"use strict";
const urlParams = new URLSearchParams(location.search)
window.canvas = document.getElementById("overlay")
window.ctx = canvas.getContext("2d")
window.canvas2 = document.createElement("canvas")
window.ctx2 = canvas2.getContext("2d")
window.savebox = document.getElementById("savebox")
window.boxCenterTop = document.getElementById("boxcentertop")
window.saveDirections = document.getElementById("savedirections")
window.message = document.getElementById("message")
window.worlds = document.getElementById("worlds")
window.servers = document.getElementById("servers")
window.marketplace = document.getElementById("marketplace")
window.quota = document.getElementById("quota")
window.messages = document.getElementById("messages")
window.messageHolder = document.getElementById("messagesHolder")
window.messageInput = document.getElementById("messageInput")
window.url = document.querySelector("#editworld #url")
window.editworld = document.getElementById("editworld")
var hoverbox = document.getElementById("onhover")
window.help = document.getElementById("help")
window.onscreenControls={
    w:document.getElementById("controlW"),
    a:document.getElementById("controlA"),
    s:document.getElementById("controlS"),
    d:document.getElementById("controlD"),
    " ":document.getElementById("controlSpace"),
    "shift":document.getElementById("controlShift"),
}
window.onscreenControl_Element = document.getElementById("onscreenControls")
canvas.width  = window.innerWidth
canvas.height = window.innerHeight
canvas2.width  = window.innerWidth
canvas2.height = window.innerHeight
ctx.imageSmoothingEnabled = false
window.loadProg = document.getElementById("loadProgress")
window.loader = document.getElementById("loader")
window.loadBar = document.querySelector("#loadBar div")
window.themeColor = document.getElementById("themeColor")

let touchScreen = "ontouchstart" in document
if(!touchScreen) onscreenControl_Element.style.display = "none"
function MineKhan() {
	// cache Math object
	const { Math, performance, Date } = window;
	const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2 } = Math;
  const rand = function(a,b){
    if(arguments.length === 2){
      return (Math.random()*(b-a))+a
    }else if(arguments.length === 1){
      return Math.random()*a
    }else return Math.random()
  }
  Math.PI2 = Math.PI / 2
  Math.PId = Math.PI * 2

  // Shh don't tell anyone I'm override native objects
	String.prototype.hashCode = function() {
		var hash = 0, i, chr;
		if (this.length === 0) return hash;
		for (i = 0; i < this.length; i++) {
			chr   = this.charCodeAt(i);
			hash  = ((hash << 5) - hash) + chr;
			hash |= 0; // Convert to 32bit integer
		}
		return hash;
	}
  
	let setPixel, getPixels;
  
  let spawnEggOverlay, spawnEgg
  function textureUpdated(){
    spawnEggOverlay = getPixels("0g0g01800000000dea0ow0eie1a80gqm2gw0k5gbnk0l7deyo0u30g730wb8hdr0we1yps0xfchz30xibmdc0yjgikf0yma0ow0znkj5r10rojr312zwkxr15amu4g15ash6o16el7nk16eqtxc16equps17ip88w18kgnwf18mt81s19okohr1asop331aupzwg1auvm681auvmyo1bwspof1byu0hs1d2se0w1e50qv31e6wem81faus5c1gd8s1r1get6gw1hhcsn31hix69s1jpkttr1jqzke81ktouf31pa4wsf1qe8xdr44400000000000004000000000000000400000053000000000000ddjc5b000000000dmo15ucf900000000bow1312nt300000005g151312xlaa30000005ny14ysmea3000005hr1316uizeaa30000bmq17ykggaaa20000bel10v11ggaab1000005glpmeaee600000058amedae76000000033aaaa26000400000037720000040000000000000444")
    spawnEgg = getPixels("0g0gh00000000k5gbnk0pmkdtr0qqoef30rusf0f0u30g730yjgikf1ilgt8f1jpkttr1o60w731pa4wsf1qe8xdr1ricxz31smgykf1tqkz5r1uuozr31vyt0cf1110000000000000100000000000000010000006500000000000000a8600000000000000d800000000000000fb0500000006900feb8850000006begec0085000006ac00d900885000000c0ea998884000000bfd09988020000069a00080000000006780008000000000055888830000100000050030000010000000000000111")
  }
  function lerp(t, a, b) {
    return a + t * (b - a);
  }
  function mix(r,g,b,r2,g2,b2,amount){
    r = lerp(r,r2,amount)
    g = lerp(g,g2,amount)
    b = lerp(b,b2,amount)
    return [r,g,b]
  }
  const semiTransTextures = []
  window.semiTransTextures = semiTransTextures
	const textures = {
		grassTop: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const d = Math.random() * 0.25 + 0.65;

					const r = 0x54 * d;
					const g = 0xa0 * d;
					const b = 0x48 * d;

					setPixel(n, x, y, r, g, b);
				}
			}
		},
		grassSide: n => {
			const pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");

			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}

			const { random } = Math;

			for (let x = 0; x < 16; ++x) {
				const m = random() * 4 + 1;
				for (let y = 0; y < m; ++y) {
					const d = random() * 0.25 + 0.65;
					const r = 0x54 * d;
					const g = 0xa0 * d;
					const b = 0x48 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
		leaves: n => {
			const { floor, random } = Math;

			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const r = 0;
					const g = floor(random() * 30 + 100);
					const b = floor(random() * 30);
 					const a = random() < 0.35
						? 0x0
						: 0xff;

					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		/*oakPlanks: n => {
			for (let y = 0; y < 16; ++y) {

				const a = 3 === (y & 3)
					? 0.7
					: 1.0;

				for (let x = 0; x < 16; ++x) {
					// these conditions are weird; can some comments be added here?
					const mid = x === 8 && (y & 7) > 3 && a === 1
						? 0.85
						: 1;

					const rit = x === 15 && (y & 7) < 3 && a === 1
						? 0.85
						: 1;

					const r = (Math.random() * 0.1 + 0.9) * a * mid * rit;

					setPixel(n, x, y, 190 * r, 154 * r, 96 * r);
				}
			}
		},*/
    oakPlanks: "0g0g70ru00lb0yicsfz156v7cv17fehvj1bvja4f1f7pou71hfxp8f5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		hitbox: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					setPixel(n, x, y, 0, 0, 0, 0xff)
				}
			}
		},
    crack10: "0g0g300000000ixwa9r1jpktog0010001000101000002111200010100001022210112021000211002122000100112210120110011022001010012012210000111002112002110122210121000022120102120100000010120010001010102001001100212021000111221101000100122210220211021120002111002200121100122211000010220010002210",
    crack9: "0g0g300000000ixwa9r1jpktog0000001000000000000111200010100001022210112021000211002122000100012210120110011002001010010012210000111002112002000122210121000000120102120100000010100010021010102001001100212021000111221101000100122210220200021120002111000000121100122211000020220010002210",
    crack8: "0g0g300000000ixwa9r1jpktog0000000000000000000011000000000000002210110000000011002122000100002210120110011000001010012012210000111002112002000122210121000000120102120100000010120010021000002021001100200000000111221100000100122210220000021120000111000000221000122210000000200020002000",
    crack7: "0g0g300000000ixwa9r1jpktog0000000000000000000001000000000000000210110000000000002122000000000010120100011000001010010012200000111002112000000122210121000000120002120200000010100010000000002021001000000000000111200000000000122210000000000020002110000000000000022000000000000000000000",
    crack6: "0g0g300000000ixwa9r1jpktog0000000000000000000000000000000000000010110000000000002122000000000000120100011000001010010012200000111002112000000122210122000000120002120000000020000010000000000001001000000000000111200000000000122210000000000020002100000000000000020000000000000000000000",
    crack5: "0g0g300000000ixwa9r1jpktog0000000000000000000000000000000000000000100000000000000120000000000000120100010000000010010012000000111002112000000122210122000000020002120000000000000010000000000000001000000000000111200000000000022210000000000000002000000000000000000000000000000000000000",
    crack4: "0g0g300000000ixwa9r1jpktog0000000000000000000000000000000000000000000000000000000100000000000000120000000000000010010010000000011002112000000002210120000000000002120000000000000010000000000000001000000000000011200000000000002200000000000000000000000000000000000000000000000000000000",
    crack3: "0g0g300000000ixwa9r1jpktog0000000000000000000000000000000000000000000000000000000000000000000000100000000000000010000000000000001000110000000000210122000000000002120000000000000010000000000000001000000000000001200000000000000200000000000000000000000000000000000000000000000000000000",
    crack2: "0g0g300000000ixwa9r1jpktog0000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000001000000000000000210100000000000002120000000000000010000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    crack1: "0g0g300000000ixwa9r1jpktog0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000002100000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    none: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					setPixel(n, x, y, 0, 0, 0, 0)
				}
			}
		},
		dirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
		stone: "0g0g40sywflr0wb8hdr0zdjj0f13tzldr3333211210112222221212222220012121001110111222222233232233222111122111212333312223222222211010131223331331112222110010112211122233323223332222212232223332233332021211001212211122222332222233232111232112200101332112211122111321122222222233332222221123322122",
		logSide: "0g0g60fl1ssf0l5j1fj0qftm2n0wa7mdb14cs7wf16az8xr3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		logTop: "0g0g90l5j1fj0qftm2n0wa7mdb0z2esxr15quebj189da7z1cpma671f7ppfj1hzyayn1012101120110111077776768667777017334454555544811738877776777471164766666666756107576445544674601646636666466471165764655656756116576465464674610657646666566460164764434556756116576666666674610757767777787460175454444444447117776676686677711011101120110211",
		bedrock: "0g0g509gy58f0e7f7r30o8fd330rkrev31627mkf3111124324211212133434341443012110110111412224232433202422111112014111121134433112221221102211014432344323443410222122211011213234421122344344442110121213211143334134410144431102221123442334402111321134111112343420211101234433211211234421121011044312301123",
		glass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
		cobblestone: "0g0g60muaccf0r0pekf0un11q711vr5rz1a8mosf1ef1r0f2144011454313543145330554330132314342143342101321132113232134310021354131154443152453321033543234313433211243215332233213541231321542213533311021543232233121341323231101221044532211235411035532354215434213323154331432332113244323212332143111311232121135432",
		mossyCobble: "0g0gb0muaccf0mupnnj0p38xdr0r0pekf0rbmj9b0un11q70w1wkxr0y07svz11vr5rz1a8mosf1ef1r0f4199211276438a9619a8812764813858398951644251118533852182851464110531183233866642a176895308948428981498852118851988111851664158385117641484642305126244558824124185442111155214698112124761318998127651764653885847488164588511858685851588531841183352111338a984",
		stoneBricks: "0g0g70p2gyyn0rkrev30tj2nlr0xf9ou70zdjj0f12psrnj17g8flr5666666666665550645455555444445065454444445534406434554345434330632334544334324053244333345324302222222222222220110011000111111166666650566666663555544065455554544544306435354445544320634344454444343053345433332322305443344322222220222222221111110000111111",
		mossyStoneBricks: "0g0gc0mupnnj0p2gyyn0p38xdr0rbmj9b0rkrev30tj2nlr0w1wkxr0xf9ou70y07svz0zdjj0f12psrnj17g8flrab3668863b88a680b9a28683a9999332ba926363996a2931b9792a679a979721b737793993697591a72397773632297075225752332277924410441110000444886bbba1abbbb6883aaaa991ba9aaaa6a99a9971b97a7a399aa99351b797992a99997371a689a97777573371a897799755223791722757754000041110004400",
		bricks: "0g0g90vz62nz0yhavi712oqn7j13rinsv173m8lb193f4zj1b1w1rz1d7u7sv1j1u51b7742888777458777443513444435144410060033100503112256522225565222887747458777474214444315133333151341110600133105522225565522225677458887474588774435344444153444110511331106133325565222225652224777474287774745144444353444441501111106011111065222225655222566",
		lapisOre: "0g0ge04hvenz04hvkzj04ihywv05mg64f06r1a7z08z3da70izhb0f0pmkdtr0sywflr0t0n08v0wb8hdr0yjgikf12zwkxr18kgnwfcbbcbaaba8aabcccbb8778accbb877baba4543877aac13bbcbcdc2a36cbbdcaaabbaa77acb77cabbbcb8742bb851a8acab716963cb69ccbba26dddc788bdaccbc69dcb827433b77abddb8b82466382888b882aa8169ca65bbb300bbcddcbc96bbaddc0883668d16cccba694b691daddbbaab463dbddbaaabbbbbcddbbbbbbbcc",
    redstoneOre: "0g0ge0syfif30sywflr0wb8hdr0yjgikf143uygv152bwu7152hjwf1gbiqdb1idy29r1jhwfsv1vqcf0f1xx5on31y0rf271y2hgqn4444322321223333332323333331123232112100222333333332166611223222232969bc8532023334248bdb74339a24233347774232343320012122332000332ac6433446969ca236a33344437cda73132322112327772233311000333344343226a9a60339a4124434cd742234422432234743333344443333332234433233",
    emeraldOre: "0g0gc004op3305rfklb05sdfr307xmd4v0eiutxb0i0nv270mb61of0sywflr0wb8hdr0yjgikf12zwkxr1o7fjsvaaaa98898788999999669aaaa966789896b2889986b2999999209969aa20a8888999a6499aaaa8999a9aa5536887878a89745b03498996698664503146886b296b2913aa88999208920aaa99a9667aa97a899a9795547888999999a905b0399a9888669801031878aa96b298843aa88a988920a97aa99aaa9999aa889aaa9899",
    diamondOre: "0g0ga07ztywv091fqin0rusf0f0wb8hdr0wfmb5r0yjgikf12zwkxr1315q7z18kgnwf1n3h8n36556533532335666553526666553223553220652233241556665762417657633355532267535635556532942539432363369400175015555622678772267568824076532943555635775253401176885253503267762233355555666632416655362256349400163667412358107765553376665567533355555553655555566",
    goldOre: "0g0ga0pmkdtr0sywflr0wb8hdr0yjgikf12zwkxr17em5tr18kgnwf1sjgzy71y6dkvz1y70nb34444222321223333332353313331103232114105122005533443105752305752233105785144776334317889722166242334678756223333221126766322275341574656443313323278636443000143146642112055711233111443157798513255723526788662457898462357622432678433336644743334632234433233",
    ironOre: "0g0g90sywflr0walse70wb8hdr0yjgikf11v06pr12zwkxr1bvjgfz1o4aozj1qczo5b5333322320222255332003355314413232464230223463333467532000233222255520044664002335334677876324652335556775323553223002555320033355046002314612323516677535675553035578502355322233335535333145353202465214677642546235325678655335412333355553333355332233553233",
    coalOre: "0g0ga0a105j30c986pr0ehg7wf0flptz30k208hr0pmkdtr0sywflr0wb8hdr0yjgikf12zwkxr9999877876778888887878555886658787667503257812888577813241088777702777510057778889987899977556797987577787313588757503158853489997803421878777878975125779988558689755878777503688557588785577778504200995430766975305777520577887778821885888998877789789988788",
		coalBlock: "0g0g501e50xr03md24f05ul3b308mtq0v0bf3ri73322122002210012222121000210123321000122000022221001243222202210001233222100210020222221000001220132211001122222022210122343221002110123322210000012123221103200212122210002211232102112210012230002113432123322000123420023221000123210012221001222212212221000",
		ironBlock: "0g0gb1dawbnj1fj5rlr1hrdssf1m7r1mn1nlyvwf1pa4wsf1qe8xdr1s2ey9r1t6iyv31tqkz5r1ver01r32233333333222232aaaaa9998777772277777777777777105555555666444402aaaaaa999777771277777777777777105555566664444402aa9999977777771277777777777777105555555566644402aaaaaa999977771277777777777777105555556666444402aaaa9999777777127777777777777712222222112111111",
		goldBlock: "0g0g91kr8um71mphb0f1w77ain1xakkqn1ypvwu71yr43jz1yzk7pb1z0cef31z10mwv2222332223333221285577888776688125664877623324812564877462224471374777462264467137777462267762302877444667762330287444664462232037444664466222613744664466662461364667766666742032667762262776203267762332446261334462332666224132322332662264701101100011001100",
		diamondBlock: "0g0g90434min061d2in0h634zj0l2fpxb0sagdtr0vckf0f1845xbz1ndl24f1z141z33333223332222331378866777664477138445766432235713845766543335561265666543345546126666543346643203766555446643220376555445543323026555445544333412655445544443541245446644444653023446643343664302346643223554341225543223444335123233223443345601101100011001100",
		redstoneBlock: "0g0g50vx660v153407319j36671gh49a71runlz34444444444444444433433222334333443342202222232344332311001120234443211012011244443210000000042344302100000011134421100000000122442231000000111344324110210111234432110004001224443321101001110344322211111122224443124211022323443334433223333344444444444444444",
		lapisBlock: "0g0gd05lqqkf06zt0xr07js8hr07tw35r084kzr308e6ein08e99fj08yjpq708ys8ov0an2j270c0w4cf0dp94hr0fdf5kv98999989cb848484878b78736733677197b8867767623765967877377863366597687666378a63759a77776636a7736197a767676236763596763666a6233625c636636376632775c633687363332371963237873676327186672236338763619763722332677630877633332336667143766633633367708111111610220000",
		emeraldBlock: "0g0g606lfrb306mdmv307ei5fj07xmdbz0iaro5b10c5ptr0000000000000002055555454551144305000000200002430404555411114243050500000002425305050555445212130405054411421203040405451142120305040411020202130404041122120213042105410112420301212222222242030405510000441213012222222222224301011001110014532333333333333332",
		tntTop: "0g0g704qh5a70nyecxr13jyl8f14a4flr1d4tukf1otd8u71szz8jj5665566556655665622462246224622462136210012300234431403344004433566006655660566562246204121402246211120000231023443341000111403356651000000506656211020001140224621360200120112344331031140344335661560500611665621462146124612462236223622362234433443344334433",
		tntSides: "0g0ga07ipw5b0fbhzwf14a4flr1d4tukf1gwtvcv1ldqupr1otd8u71pk09vj1szz8jj1z141z38863886388638863663266326632663266326632663266326632663266326632663266326632663295775577755777799711071550711059745055115157177795717717115505479750571550550759444444444444444433223322332233226632663266326632663266326632663266326632663266323332333233323332",
		tntBottom: "0g0g413jyl8f14a4flr1d4tukf1otd8u72332233223322332300130013001300130013001300130011111111111111111233223322332233230013001300130013001300130013001111111111111111123322332233223323001300130013001300130013001300111111111111111112332233223322332300130013001300130013001300130011111111111111111",
		acaciaLogSide: "0g0g60ma181r0oi99fj0pcavi70t8nim70y9464f139ktmn3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		acaciaLogTop: "0g0gb0j7rlz30kvxmgv0ma2nen0o889hb0t8nim713rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf432332211231433449999898a889999329556676777766a2395aa999989996910869888888889782197986677668968318688588886886932879868778789784487986876868968448798688887886833869866567789782287988888888968219799899999a96811976766666666691099988988a8899933412233444322114",
		acaciaPlanks: "0g0g711t8qgv13rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466656666535455554333434332654433334444335300122100012110006556655366646566445533433555544443345432554333330110012221010000",
		birchLogSide: "0g0g80f1fcov0qqliwv1gxap6n1o60u7z1ptrf271uar6db1uum5mn1z141z36643366634663366346666777634443677744367666636777732100136777737366321101377631211336344363331001266344677766532343777777334556376336775577775777764455577766336336777766634477636777767777577634436633667553210026677763443100000133377761132116331677764336336",
		birchLogTop: "0g0ga0mk6h3316m5am719xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm71tgjy7z1z141z39818811001809889966665657556666816223343444433718627766665666360153655555555645106465334433563580535525555355368154653544545645995465354353563599546535555455358853653323445645115465555555563510646656666676350064343333333336016665565575566688901188999811009",
		birchPlanks: "0g0g717znmrj19xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm75456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		darkOakLogSide: "0g0g60besef30dcwlbz0e6y70f0hj7ev30klcs8v0oho0e73143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		darkOakLogTop: "0g0gb08ml79b0auqebj0dcmqdb0e6y70f0f117gf0g4r4730h8wirj0hj7ev30kb0idb0lz2akf0n393wf741441100140744779999898a889999419225565666655a1492aa999989995903859888888889681096985566558958408588288885885941869858668689687786985865858958778698588886885844859855256689681186988888888958109699899999a95800965655555555590399988988a8899944701144777411007",
		darkOakPlanks: "0g0g70bejy0v0dcmqdb0g4r4730h8wirj0kb0idb0lz2akf0n393wf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		jungleLogSide: "0g0g90h96cxr0htdywv0m9k4xr0ne277j0orqc5b0rkbldr0sxvim70wunksf0ys83cv4688422222666444444114414441001111137510011441866644668842422224146644411143573444422235311010006646442222444886101000466412222444688411068844441122575311222100755444666664355741100112241201661144866643341111623533422111444644111004661664444664122244442222",
		jungleLogTop: "0g0g90h96cxr0htdywv0rkbldr0ys83cv160fym7188mku71batekf1f77h1b1h5ei2n3212210011213223377776768667777217444454555544812748877776777470164766666666756107576445544674620646646666466472165764655656756336576465464674633657646666566462264764444556756106576666666674600757767777787460175454444444447117776676686677722310122333211013",
		junglePlanks: "0g0g70sxkd1b0xdxkov160fym7188mku71batekf1f77h1b1h5ei2n5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		spruceLogSide: "0g0g60csc9vj0cskpof0dmmb5r0geuxof0lf4i670nnb4sf3243304330342431325130513034233130113051323223314031323131302341423130315131324343234232514232431323411343433243130343143341314332053314314141433325331331424303333431303132430332343130533053235233414051303313532343324132333343243340323224334324234232332431",
		spruceLogTop: "0g0g80ix87pb0nnb4sf0p1n6db0qzu7zz0v5xypr0xy569r106bshr11ueyv31012101120110111066665657556666016223343444433711627766665666361153655555555645106465334433563501535525555355361154653533545645115465353353563510546535555455350153653323445645115465555555563510646656666676350164343333333336116665565575566611011101120110211",
		sprucePlanks: "0g0g80nnb4sf0p1n6db0qzu7zz0v5xypr0xe36rj0xy569r106bshr11ueyv36567777767777762665523566655663356665643333556622112210011010010673777737776553656653532355666653356555266655333001121000011121067765577777777636566665333535332765533335555336300122100012110007367766377737677556633533665655553356532665333330110012221010000",
		sand: "0g0g61m6x62n1nb9nnj1opn5dr1r80f7j1scbi0v1u0izgf4223213232132313122121130142502432011422222121122331213133132122125213232322122321223332123122121421151211022121212212212111242112322310131232124212221120212231202321232232012311223212331112121213132145321123323230232323221223235332323203223232332321223232",
		gravel: "0g0g80rufq4f0vqwlbz0zxiprz125i9rz15rvcan1627mkf1d0twqn1dackxr0341152512122521522122312102333522103133522351352232321522512322132741122210253202140133526552213104226515530122553253522311225353521223310256122311652152322132123553102521325022533562113225212132222537415525331025232422215235323311243310351274122232321212",
		blackConcrete: "0g0g40149on3028826702882yn028dp8f1330112022012232303130022112212111032203010022012122012222321221011223213030101033110011212233120230013131003200032022012002002112233122202312230200102211312102222122132011021201223320211021220121122122321331201102120210001220112022023302312210123220102110",
		blackWool: "0g0gf0149on3028826702882yn028dp8f03cc2rj03cc3jz03chptr04gg3cv04glqf305kk3y705kpr0f06oo4jj07ss54v08ww5q70a106bj46348b45ab13993299eebb7742570367bc77dc97bcbbdeb996bc768c47cc96ec9749bb115953bb31314c414641672547eebb8879bea7eeb966eebacc45bca9ccbb35ca4657528733577b117949ee7beeccbbecbacb799839349966bb445911796611cd318b9bee92badecb9717bc77cedc97c99beb559b6424c946cd76ac44bc",
		blueConcrete: "0g0g30c98pof0c98qgv0c9ecqn1000001101000201011001000101120101211111010200000001000110100100220110011001121111001100100100010200102101101000000011110001101010101011020111110000000101121111101100100100010110111010210111001101000100000111110100101111000120000010100000110001200110010002",
		blueWool: "0g0gj0c98pof0c98qgv0c9ecqn0c9edj30ddcr270ddidbz0ddie4f0ehgrnj0ehgsfz0ehmepr0ehmfi70flkt1b0flqfb30flqg3j0flw2db0flw35r0gpugov0gq02yn0gqbd3335237c44ac12992289iidc6632460256de67ge96cebbhic985ce657e46ee85ie9648cc114942cc21214e413541562436iidc7769dia6iic955iicaee34cea9eecb24ea4546427622466d116949ii7biieecciecaed699728249955cb344911695511eg217c9bii92bahiec9617be67eigf86e99cid449b5324e935eh65ae34de",
		brownConcrete: "0g0g30pl5gqn0qp3u9r0qp9hbz0211211202222221222122211211122121011102222222212211200222112101121111211111222121222122122221201212121222112122222221220222222122221201121212022122122110221211122221211011221212121010121011111212122221121221222212122112112112211010222111121211220222221122",
		brownWool: "0g0gi0qp3u9r0qp9hbz0rt7uv30rtdh4v0sxbunz0sxbvgf0u1a8zj0u1fv9b0v5e8sf0v5e9kv0v5jvun0w9i9dr0xdgmwv0xdm9z30yhkni70yhq9rz0zloo3j0zluadb35228d45bd12aa219bhhed7721570257ef77gfa7dfccghdb95df758f47ff95hfb749dd115a52dd21214f413541571526hhed887aehb7hhda55hhdbff25dfbbffdc25fb4557518722576e117b4bhh7chhffddhfdbfe7ab82924bb55dc245b116b5511fg218dachhb1cbghfda717cf77fhgg97fabdhe55ac5214fa25fg75bf24ef",
		cyanConcrete: "0g0g305objsv05obklb05oh6v31112010122111202100121222111122012212211101111202102221210222122211111211221111011021102021212212220211021022022201210110010212210211110202101010201110112020221222112102111202212110222110211221001010211001221212202222122111221102211100222112011211120220211",
		cyanWool: "0g0ge05obklb05oh6v305omt4v05omtxb05osg7305oy2gv05p3pj305p9bsv05p9clb05peyv305pkl4v05pklxb05pq87305pq8zj242269347912662167dda95521450145ab55cb659b88cd97649b546b35bb64db7536991146419921113b312431451424dda96656ad75dd9644dd97bb249b77bb9814b73445416521454a115737dd58ddbb99db97ba56762623774498234711474411bc116968dd7187cdb965158b55bdcc65b679da44684213b624bc547b23ab",
		grayConcrete: "0g0g20ehlvr30flk9a70000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000001000000010000",
		grayWool: "0g0gd0ehlvr30flk9a70flpvjz0flpwcf0flvim70gptwxr0gpzjzz0htxxj30hu3jsv0hu3klb0iy1y4f0iy7ke70iy7l6n333359337803663157cca85531350135ab55cb658b88cc87539b545b35bb53ca7535990036329930103b303330350335cc995556ac75cc8633cc87ba339b77ba8813a73435305532355a005737cc58ccab88cb87ba56753533773498333700574300ac205968cc7087cca865058b55bccc55b679ca33684313a634bc537a33ab",
		greenConcrete: "0g0g20k2mku70k2s73z0001000100111100101010100101101101101100111010010111001001011000100001100011000100101010110101111010000001011001001000100001010110101110010011010000101011110000010110101000000001010000110101011101000111110011101010011000111100001100011000000111101001101100",
		greenWool: "0g0gh0k2mku70k2s6bj0k2s73z0l6qjun0l6w64f0l71rlr0mb054v0mb5qm70mb5ren0nf9qf30nffcov0ojdq7z0ojjbpb0ojoxz30pnnbi70pnsxrz0rw0y6746447c45ab1499419aggcb8841580168ce88ee98bebbfgba96ce867e48ee96gda849cc125953cc41114e424642681546ggcc7789cga8ggb966ggbaed45ceaaedbb15da4658517843586c21894agg8bggdebbgebaec89a749449966cb445a116a6621de327c9bgga1bafgdb9828be88egee98e9acgc559b6414d946ef86ad44ce",
		lightBlueConcrete: "0g0g3090ti4f090z4e70a4xipr2120111111121222222121122112211121121211112221221111102221122212112021111111122111112111112121211222221111122121212121112021122112211121211211111121220111212121111121222001122211222221022122111011221111111021211221211211121112212111111122121111211112222111",
		lightBlueWool: "0g0gq090z4e70a4xipr0a534zj0a58r9b0b974sf0b9crun0b9ie4f0cdgrnj0cdmepr0cds0zj0dhqein0dhw0sf0dhw1kv0em01dr0em5nnj0fq9o8v0fqfain0gudou70gujb3z0hyhon30hynawv0hynbpb0j2lp8f0j2rbi70k6pptr0latpmn7b57fm89ik26ff63fippnkdd739d04benodepogdkojjppkifblodcfo8doofbpoie8fml21af95mm62428o817b81bd397cppmlffefnpidppkgbbppkioo79loiiookj4aoi8cad93fd55adcn22dh8ippejppookkpokiondfif6f68hhbcmj78ai22cicb22op51fmfjppi3jippokfd2ejoeeoppofdofilpn9agjc738og7copebio78no",
		lightGrayConcrete: "0g0g20yjgg730yjggzj1000110001001010100010000000011101100010001001011010001100101010001000000000000010100000000100010100000000001010100010001000000000100000110000100001100000011101110001001011001001001001011000000000011001001001001010000000010000000010100110000000001000001001",
		lightGrayWool: "0g0gi0yjgg730yjggzj0znkgsf0znkhkv10rohdr10roi6711vshz311vsirj11vy5tr12zwjcv12zwk5b1440jy7144670f1584kjj1584lbz16c8l4v16c8lxb17gclq745339e55bd1399329bhhfd7732570257ff78hfa7dfcchhdb95df769f57ff95hfb759ed115953ee31215f514551572537hhed9979fhb7hhda55hhdbff35dfbbgfdc25fb5657529733577f117b5bhh8chhfgddhfdbgf79b93935bb56ec355b117b6511fh319e9chhb2cbhhfd9718cf78fhhg97f9bdhf55ac6325fa36fh75bf35ff",
		limeConcrete: "0g0g30ppd5a70ppirjz0qth5331121111111100111111111110111110111010211100110111211111211101111112111111111111101110111011110211011011110111110102111110100111000110112112110211112112112111212111111111111111011111011100101111111111212111111111112010011011221111111110111120011110111101111",
		limeWool: "0g0gg0ppirjz0qth5330qtmrcv0rxl4vz0rxqr5r0t1p4ov0t1uqyn0u5t4hr0u5yqrj0v9x4an0va2qkf0we143j0xi53wf0ym3hfj0ym94hr10uh5of35237c44bb1299228affcb6632460257cd67ed96bdbbefba85bd657d46dd85fca748cb104942cc21214d403540562435ffcb7779cfb6ffb955ffbbdc34bdbaecbb24cb4546427622465c01694aff7bffcebbfdbbec69a728249955cb344a105a5501ce207c9bffa2bbefcb9607bd77dfee86d9abfc449b5324c935de75bc34cd",
		magentaConcrete: "0g0g419jw2rj1anugan1ao02kf1ao03cv2233313332221332333333233213322333223332331233333313323103121223222131233211303233130230322231223302323103002220333103232232223333313231221331233333231232212303302330122232333333332123320111033031332321233232303322232223332223231233212323332233222231230323",
		magentaWool: "0g0gs1ao02kf1ao03cv1brygvz1bs435r1bs43y71cw2hhb1cw83r31cw84jj1e06i2n1e0c4cf1e0c54v1f4ainz1f4g4xr1f4g5q71g8ej9b1g8k5j31g8k6bj1hcijun1hco64f1hco6wv1igmkfz1igs6pr1igs7i71jkw7b31jkw83j1kp08ov1lt49a71mxdwxr6945dl77ij14ff43ehrrmjba537a039cmoacqogajojjqrjhe9koa9do7booe9rnhc7elk118f74ll41317o7169719a275arrmkddcfmribrrjg99rrjion57koihonjj38ni798a72db448bam11bh7hrrcjrrnojjrojiomafhd4e47hh99lj578h11ah9911nq41dlfjrrh2jiqrnjfa1cjoccorqpebofhkrm78gj9537ng59oqc9in57mo",
		orangeConcrete: "0g0g21p59iwv1q97wfz1011110111101111111011111110000111101110100111111110011111011001001101110110111111111110111111011111101110111111110111111111111111011110111101111011101101101111010010111111110110101110010011101111111010101001101111111011111110111111111001111111101111111111",
		orangeWool: "0g0gm1q97wfz1rdbw8v1rdbx1b1rdhjb31shfwu71shfxmn1tljxfj1tljy7z1tlpkhr1upnytb1uptl331uptlvj1vtrzen1vtxlof1vtxmgv1wy1m9r1wy1n271wy79bz1wycwe71wyijgf1wyo5q71wytssf46239f55de02aa219dllhe8731570268hi79kib7eieelled96fi779i58ii96lhd859ff005a52ff20205i504650671537llgf998ahld8lleb66lledih35fiddihee25hd5757519822587h008c5dll9ellhieeliedih7ad92925cc67fe355d007d7600hk209faelld1edllhea709ei89ilkj98iadflh55be7315hb37il86dh35hi",
		pinkConcrete: "0g0g31ltks8v1mxj5rz1mxj6kf1122212121112211111211211211122112111221111111121211212111122211111112112121112111111111111112111212221121111111212211112101110212211211122111211112212111211110211211211211111111121212221211121111112212211121211111211212211111111111121112111211212122122111",
		pinkWool: "0g0gv1mxj6kf1o1hk3j1o1n6db1p5r6yn1q9v6rj1q9v7jz1rdz7cv1re4uf31si37y71si8u7z1tm78jj1tmcutb1tmcvlr1uqgven1uqmigv1uqs4qn1vuqj271vuw5bz1vuw64f1vv1se71vv7fgf1vvd1q71vvd2in1vviosf1vvipkv1vvobun1vvocn31vvtywv1vvzlz31vw588v1vw591b6a46em78jk25gg53fjuuokdc638c03adoqcesqhckqkktukjfalqcbeq7dqqfaupjd7fml219g83mm52327q716a71ac386buunleedgoujduukhaauukjqp68lqjjrpkk39pj7b9c83ed439dbo12di7juuekuuprkkuqkjrocgje5f57iiabmk679j22bjba12ps31emgkuuj3kjtupkgc1ekqdequssfdqgjluo89hkb637ph6bqtdajp67oq",
		purpleConcrete: "0g0g40qo16v30rrzke70rrzl6n0rs57gf3222322033323333333312320220233231302222232332333202332233033330333322320012333323333330233022223332223332223232323303323233332332021220323110033223333322032332312323332322322202232223033232221223233023333332022233332332233232023333233223032323332323323332",
		purpleWool: "0g0gm0rrzl6n0rs57gf0sw3kzj0sw3lrz0u01zb30u07lkv0u07mdb0v45zwf0w84dfj0w84e7z0xc8e0v0xc8etb0yg6scf0ygcem70zkasxr10o96gv10o979b10oetj311sd72711sd7un12wh8fz154uxhb47349e45ce13aa32acllfe8742570279fh79jhb7ehddkleca7eh779h48hha7lgc94aee116a52ee31214h414741771547llfe999aflc8lleb77llechg45ehcchged26gc4767519832687f118c4cll9dllgheelhechf7ac93a34cc77ed446c117c7711gj219eadllc1dcklgea719dh99hljia8hacelf56bd7424gb47hk97cg44fh",
		redConcrete: "0g0g112voa9r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		redWool: "0g0gd12voa9r13zmnsv153l1bz167jev3167p14v17bnenz18fls7319jprzz1ano5j31ano6bj1brmjun1brs64f1f3yku7241258227712662157cc9754212401459b45bb647b77bc77548b445b25bb54ca7525881036218821112b202420441224cc8855569c75cc7644cc77ba228b77ba7713a724342155113549015627cc57ccab77cb77b946752522664487223711474401ab105867cc7177bca764057b55bcbb55b678c923674212a624bb547a229b",
		whiteConcrete: "0g0g31ktui9r1ku04jj1lxyi2n1121212211221121111221111121122111211111121112111212112211111211212222111111221112211112101110211111122211211211111111212221111112212121212222111121122211111111222111111112121222121111111111211121221112221111121222121112212122111221211212111121221211221212",
		whiteWool: "0g0gn1lxyi2n1lxyiv31ly454v1n22inz1n22jgf1n285q71o66j9b1o66k1r1o6c6bj1paajun1qeekfz1ricyrj1riil1b1smgykf1smmlmn1tqkz5r1tqqm7z1uuozr31uuumtb1vyt0cf1vyynen1x2x0xr1y711j37a56dj89hi26ee63egmmliba639a04acllacmlfailiimmigeajlaadl8blleamlgc8ejj219e94jj62429l817a81aa396ammkjddcelmhbmmifaammihll69jlhgllii49lh8a9a93db549bal12bg8gmmcimmlliimlihllaegd6e68ggaaji689g22agaa12lm41djeimmg3ihmmliea1cilcclmmmeblegjml99fia638lf6almcahl68ll",
		yellowConcrete: "0g0g41to1w5b1us09of1us5vy71us5wqn2111111122222221232021021213122222211020112110121211022201012212122222312211221122213110202011133121132211112221221211211111112120231210211111201132001211212111211102220222021102211223011100222121202222222132111211111112111112021121120222221222011012122121",
		yellowWool: "0g0gj1us5vy71usbj0f1vw9wjj1vwfitb1vwfjlr1vwl5vj1vwl6nz1vwqsxr1x0p6gv1x0utj31x10fsv1x10glb1x163nj1y54h6n1y5a48v1y5a51b1y5frb31y5fs3j1y5lf5r45239e44bc0299219biiec7731470158eg78hga7cgcchicb95dg759g47gg95ifb849ed005942ee20104g404540571436iied9989eib7iica55iicbgf34dgbbgfcc15fb4557419722576e007b4bii8ciifgccigcbge79b92924bb55ec345b006b5500fh209e9ciib1cbhifc9708cg88gihh97g9bdie45ac5314fa35gh85bf34eg",
		bookshelf: "0g0gt03fxnnj04laqdb0a0ot1b0b6j6db0c8r6db0deww730df88ov0egz6rj0gpo9330ht5kov0k20av30nf40zj0pnc1dr0qoh8fz0sy416n0w8kcn30wc5n9b0yicu0v11vb08v11vskcf13z03jz16atkvz17fehvj1as1ce71czhmv31e50qv31g6nvgf1gbtpfj1ks44qnommllhlllmmmmlmoo44477444772534oo799kk999ni9637olkffqk99gpjk631lsqffqk64gnik631soqfdqf6gcngf651ookd9kf3c7igf350mlorrsssroorrroolollmmhmllmmmllhoo77227cb7427724ooqk763gck99cb97olpj063gckq4gc10hsqk063a8fqkgcpjsoqf065a87kqgc10omkfe35ccefkcb03oorrsssroorrrrooo",
		netherBricks: "0g0g706o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		redNetherBricks: "0g0g70c7i51b0efew3j0fjiwov0ive1a70nbiubj0svgd1b0v3ir5r0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		netherQuartzOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330u2845b0v4m7sv10p0npb1bug2671e4e1vj1n1fv9b1smb9xb1312426644044643344320246610442164643068a921424676466baa866314246766ba8674662643166895678a8544641466565ba95146866310289856642b9742469b814466ab862467ba624646b952364a950268665602426852108b61623214642649a9164941364667689238976124667423804646442246624630246644",
		netherrack: "0g0g70hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1312425544044543344320245210442154543012432142456545423545531424565424566455254315431566554244541452054554214565531024541154246642454221445541452456540245455112354554025655200242254210254102321454254122154541354556512234565124556423204545442245524530245544",
		netherWartBlock: "0g0g60of09vj0suze9r0xana4f1539r7j1brbain1g7rcvz0122001222532010222235202110022112111222202202320122201003202242042220021211122103224300222201201022220122252002210210211223102220000221222200222022221132210202012201104100222102201012211021042230122022012022212012022002220222202202220234022205220322022302",
		quartzBlockBottom: "0g0g31sm5mv31tq9ngf1tqfbb32222221111000222121111000002222111100000012222110000001122221110001111000110000011100000110000011111222200001111222222211111111222211000112222220110012222222211222222222210000022222211000000222222110110112222111100112222221100101122222111101222222222210000",
		quartzBlockSide: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzBlockTop: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzPillar: "0g0g41qe37y71sm5mv31tqfbb31uujcov0202031312130212020302130313031202131313120313020313130213031313131303120302121313020312031203131302131313020303120313031303130312130303131303120213131302131212131312130202120313021213120302031302120313031303130202130303131303120313031213120212131302121202",
		quartzPillarTop: "0g0g51p9z6kf1qe37y71sm5mv31tqfbb31uujcov1021223242413020222122211221122002223434434322223123443344443211113412222221431242442344443244222243242222424423423324244142441222442424324234143244242211423322224423334432442421341222222143111123444444443213222234444443222002211222122112221203142423220200",
		chiseledQuartzBlock: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov0444404333022440043331222204444003322111000444300222223004443331023011101110022103315544432202200110441100220000554444144033344544433204314444440111230011441101054044444432154104400110111004401444454005544440133321100004443002323155440333300444414444132220",
		chiseledQuartzBlockTop: "0g0g51p9z6kf1qe37y71tq9ngf1tqfbb31uujcov0334314232133420021100022000112002044203204421200204120420412021020113032020003102233304212233200000000421110000323433442223344422222222222222220000001321000001044343142143222104011204214110201302130420313020120234032023403002111003201100400222314222133420",
		chiseledStoneBricks: "0g0g70oigd8f0qqoef30sz21vj0xf6vpb0yjgikf11vskcf17g711b6666655666566562644424444224444054110000111123205206665566561530640654434442154064064322334315405205430005421630540632000643062052054300053206306215435655420630641644545432053064163232322215406421110000011530556655666655543053343234433232202000000000000000",
		smoothStone: "0g0g70wb8hdr0yjgikf12zwkxr17gcnb318kgnwf1asop331d0wq9r1011002200220121054556666553445204334454444555501666455566655442255444545666645006555555554343412556664665545550243343443434466116656545555455620555554566656661054544334454454215555666665566622444566454433452165445556555455104456665566544401022112221000121",
		soulSand: "0g0g60egz94v0ht5n270k181z30oho3jz0sxyiv30xeekfz3130033202100434433135531100234004241451321012411423432542212230032442154212211332234104322433212002314322315332220023322345513032322211233445304302332013540423202342330242132302341043213032020354044321232020431445421112202350345131123302354202432103212415",
		glowstone: "0g0g80u1fugv0v5phbz10pn01r11uj6db1kqv1tr1x1ncov1y6jzlr1y711j35420045440276423654011240346654024032201131054033034542017510033014766405664136502566552454236751004554020132450531024010352320465230213276501576442654346640335420454220452013000320356304012311354016754036520357660354215764034654201003242013154216521100013",
		andesite: "0g0g60sywflr0wb8hdr0yjgikf11vsl4v17gcnb31asolxb2114332104423221245323445330122411334410122443224410133445433231235442223333211433323243210013432324542104543333423310154332333433114143343224533143342221154333332321101544332201331254422332333443443233212331543333334533112233301244323223541321322323234432",
		diorite: "0g0g60xfchz311vskcf19of1fj1gd8su71ktouf31smgykf1222352233524355201322135345543151355101325543235255312553213225351243153532255245355541332335235332455214554102243123234555521232203255443244250155213551234541244310134335513055510144221512352542543554223223212343125454353242115521455321245235554124421255",
		granite: "0g0ga0l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n1qczoxr7434244344046445431548244224422341444335249241464143446145532344234232113754334244255342143347242445524442555322424474302155243346344255522344245535242552464245557314243844212555415442024425030323244424324439435524312355344448553215435547245544733324244425",
		polishedAndesite: "0g0g90oilzi70sz23gf0v7a3270yjgjcv10ru60v11vyakf11w3ugv19okmwv1e4v30f7878888888788785843334442443134084444443376644307416763343446440844442456433334083344333424433318444634666554320833433332123444184562444466776608434433443344540844667633366444081444444664466208466654333134760844433334465334083333664444334406100000000110000",
		polishedDiorite: "0g0g80qqu0ov0xfi5tr11vy6m71asubcv1f94t1b1jpkttr1o60w731ri7bpb7776677777666774764556657643564166764466577434506565333565454441675334576435457176544567733456607566767655346450744765756564534063556655467534516566544565544761664334655465666075673555775644517557654375466340745654576435744072445566545654512101110001100110",
		polishedGranite: "0g0g90l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n8888786866866565843344345444334374744554442446418444243334553342844444453344443262343344443734428345543644444431844444423445544263422344554433636444433443344442734444444464334284473344244442318455444445543341633443264434455264443444334447412111001110111100",
    portal: "0g0gu0dbgv7j0dbgvzz0dbgwsf0dbgxkv0dbgydb0dbgz5r0dbgzy70dbh0qn0dbh1j30eff7y70eff8qn0efffun0effgn30fjdu670fjduyn0fjdvr30gnc9a70gnca2n0hranlr0hraoe70iv92pr0jz7h1b0l35vcv0m748vz0m749of0nb2n7j0of11j30pizfun0qn3fnj0qn3gfzjpked8bed36jh512kjjk5a8ci77h53656dj318mfpheof3ab1b418pl4662eqe014418mk311821dme1h8cpj4a67ef13crglbil3a5hkfoe12hkb1bb5677tjhrg248e47b54348bml724im8hm41322bdjh8dob46pn4a686cpj44bb616mo76bdqk3abfhq725pmccqm51bqjcor6a6lhgl43ctlbcbqm4187769bsj686ljgd8hhe88mh426",
		obsidian: "0g0g50000073013yfb304gainz0a0p1q70fksanz1000012104311343101202104211342100443013322023010432231212001210032220000001110122200211114311002212344310301001102422020000043000432223310032223200213321021211211011121100210302112012144322221442022234212421332111022211103103112131122010012102012320111111",
    redstoneDust: "0g0g4000006w11qgs8o13ydjaw1jpkttk2220000220000222220000022000002220000022222000020003332222233300000333222223330000032222222233000002222222222300222000200200222222202020220222220020002002002200000222202102230000032222222223000003322222223300200332222333330222000022200000222220000220000222",
    redstoneDustOn: "0g0g5000006w1f1xam01jpkttk1nxkauw1wt7b3s0000000440000000000000044000000000000044444000000002224334422200000222444442220000024444144222000004433313444200444441131134444444443314114144440044341114144400000433433434420000024434144442000002244444442200000224444222220000000044400000000000000440000000",
    bufferMiddle:"0g0g502881dk0v31t6g11qs2d41cubto81x2x0xk4444444004444444444444400444444444444440044444444444444004444444444444400444444444444440044444444400000000000044444011233210044444400112210044444444001121044444444440121004444444444002204444444444440000444444444444400444444444444440044444444444444004444444",
    bufferTop:"0g0g802881dk0zivbaw13yotfc18eibjs1cubto81ha5bso1nxvkzc1x2x0xk7777777007777777777777700777777777777770077777777777770000777777777770011007777777770011210077777770011322100077000013363321100077001146631110007770013531100077777701331100777777770011100777777777700100777777777777000777777777777770077777777777777007777777",
    soup:"0g0ga0mewxrs0t3w8ag1jkvsag1jkw9o81job7y01smg9a01ullu601uunpx41x2kgzc1x2x0xk6666666626366666655666666666666666666666663663666666666366666666656666966666366666566666666666666565666766666666666166666666364665666666666636666661606666766666666666666666666666667667636666666561768673666666656660666966666666666666666636666666666666666666",
    soup2:"0g0gy08x7gmo090n2ls0b3ve9c0b96fhs0mav8xc0mewoa80mexbzk0qotmuo0qsjto00qskfsg0quq7zk0quqvow0qur5680v6iink0v7qghc0v8dxww0zotckw1apuuwg1atwxyo1cxrp4g1cxsb8w1cznca81d1ueb41f8631s1jkvsag1jkw9o81jne7lc1job7y01siecj41wt7b3s1wt7qq01wtiji01x0f4l41x2kws0tt54pm4p67460g0pt44tamaaa704gg0pkc67bbtma7a4gtr0m771bmbm9ta4qpt0a7acc45mo7qaq333m7bcaabm7h4i38r0aamccc477c4hh8r0mbaa7cdc774th8r07777jbdma7ibshs0dkk7j7am6babi8rpkk4jb7ccb7abtpu0ccf4775c7mm4mtts88lc1777mmmm6p0x82fmm87338v4tpss8m7q6gin934wts0xep4g62i0i322ss0x",
    soup3:"0g0gs00000000b3k0t40b46jhk0b6cwds0b6d8vk0b6d8zk0b7awx40b7m74g0b7x33k0m904m00mfk40o0mfk76g0ofo0mg0ofo0mw0ofo0qo0om805c1czc0ew1f2v0681f78bs01f78btc1f78rh41f78rm81f799001f79dqo1f79ic81lqabs81lu0ve81q7ozdkp0e440ece08ejj0000ee4l008f3ee99940404empfjf52509elm04pdfddee5pc0peee4c09bbgf8ph934edo4e35d0m86p633mel4e8n6h6bmp0b33lce46a45m0m003dj49e485a006j77m3pefee5dmb73cgjp3226p9447749007bpbf65ai4868620210q552fi48b33j4g13536ah2442f8ffm45455qm748437gfk0fff954762bjir0p",
    soup4:"0g0ga000006o0deayuo0v8z9ww0v9lr0011qgs8g1jkl90w1jnou0g1o6ay281ulak1c1urujg02222222222222222223222553322333222325233522222122232222222221222222003252332112222277322243331212277732224213322227772228482212222777232888222222277773288822322223777722322332226222332299232222222222299993222336362229999223226223322299222332262232222222222",
    randomSoup:function(n) {
			let r = 0, g = 0, b = 0
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					r = Math.random()*255
					g = Math.random()*255
					b = Math.random()*255
					setPixel(n, x, y, r, g, b)
				}
			}
		},
    redStain:"0g0gg1wt7ax41wt7axs1wt7ay01wt7ay81wt7ayo1wt7az41wt7azc1wt7azs1wt7b081wt7b0g1wt7b0w1wt7b141wt7b1c1wt7b1s1wt7b2o1wt7b3kfedb863102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acd",
    invis:"0g0g20000000009ppts0000000000000000000000000000000000110000000000000011111000000000010000111000000010000000100000001000000110111100100111110011110010111111110111111111110101100000111110001000000011110111111000001111111110000000111111101001011111001111111000010000011000000000",
    "poision potion":"0g0g40000000000006o18ikd0w1ulbvg00000000000000000000000000000000000000002200000000000001221000000000000100100000000000013310000000000001331000000000001330310000000001333303100000000133330310000000013333331000000000133331000000000001111000000000000000000000000000000000000000000000000000000",
    darkLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 10 + 100);
					b = Math.floor(Math.random() * 10);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		redBerryLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.10) {
						r = 255;
						g = 50;
						b = 0;
					} else {
						r = 0;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		blueBerryLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.10) {
						r = 0;
						g = 0;
						b = 255;
					} else {
						b = Math.floor(Math.random() * 30);
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		autumnLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 250;
					g = Math.floor(Math.random() * 80 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.30) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		pinkLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 255;
					g = 205;
					b = 226;
					if (Math.random() < 0.30) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.30) {
						r = 255;
						g = 185;
						b = 196;
					} else {
						r = 255;
						g = 225;
						b = 236;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
    flowerOftheValley: "0g0g800000000ekeqdb0mcq0hr0qtshkv0ym3u2n1o60w731smgykf1y711j30000000000000000000000000000000000000000000000000000000000000000000443000000000000760020000000000075020200000000000076020002000000657541002300000065000210330000000000011243000000000001143100000000000123200000000000013210000000000001110000000000000100000000",
		poppy: "0g0gd000000004jkcu704k17nj04k6txb05oxatb0fjd9mn0iv8e7z0qmx1q712uf5rz13ydk3j1f22ygv1lpt7nj1vpem7z0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa000000000000a78ab0000000000bb56990000000000ccb99000000000000b310000000000000004000000000000000400000000000000040000000000003404044000000000030230000000000000313000000",
		dandelion: "0g0g70000000017p88v03h660v143zt331e5azun1ktyynz1uuywvz0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000560646000000000005563000000000006643350000000000002200000000000000212100000000001221100000000000012100000000000000210000000",
    blueOrchid: "0g0gj000000004l4jjz05oxatb05p2x3306s98u706svocf06tdo8v06tdp1b07w7mdb07w7n5r07xc2kf0a6ccn30baaq670baaqyn0bax81r0djgfen0gsmpz30gssbgf0gssc8v0000000000000000000000000000007000000000000009f00000ec0ce000hac00000760cc00gc00000000ii900g7fd000007c4009020c000000eb00008ec00000000000003760000000000000i000000000000000190000000000000005000000000000000g00000000000000020000000000000099000000000000000000000",
    pinkTulip: "0g0gc00000000dfzitb0ek94vz0hwfl6n0j0p81r0l92txb0mcq1a70nhavwf0nhgi671p83v9b1skr5kv1utlnun00000000000000000000000000000000000000b0b0000000000000aba00000000000009a9000000000000009000000000004800104000000000073080840000000003708082000000000250626200000000024248200000000000684620000000000023820000000000000262000000000000002000000000000000000000000",
    orangeTulip: "0g0gg00000000cc14hr0ekeqdb0hwl6nz0j0p81r0l8rmyn0l92txb0mdchkv0nhm4fz1kpag3j1lt385b1mxo3jz1p61r0f1q9uj271qa5rlr1rdstfj00000000000000000000000000000000000000f0e0000000000000bcb00000000000009d900000000000000a000000000000800104000000000048050540000000002702082000000000264225200000000023248420000000000534520000000000083820000000000008352000000000000002000000000000000000000000",
    redTulip: "0g0gd00000000gssem70k4yuwv0md19tr0ol9b0f0olkhz30ppojcv0qty5fj1hb8m4f1ifclxb1lrj0n31mv641r1mvn18f00000000000000000000000000000000000000b0c00000000000009a900000000000008c8000000000000009000000000000030407000000000034010730000000001714061000000000171415100000000003731200000000000143240000000000001727000000000000142700000000000001000000000000000000000000",
    whiteTulip: "0g0gd00000000b7x3wf0cc6pz30fod69r0hwl6nz0k4nmdb0k4ysjj0l98gzj0mdcgsf1lxsv0f1pa4wsf1smgykf1uuozr300000000000000000000000000000000000000c0c0000000000000bcb0000000000000aba000000000000009000000000000040100080000000048050074000000002802073200000000252506200000000024842320000000000254350000000000002838000000000000253000000000000002000000000000000000000000",
    azureBluet: "0g0g700000000gruprz0j0e0an0ngu1331o66ku71riimm71uuoj5r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000006564000000000000432056000000006504553400000000530146200000000001320305600000000056230340000000005433300000000000003200000000000000300000000",
    cornFlower: "0g0gb00000000b6jldr0cbkf7j0gs0hkv0ht0npb0izbr3z0ngiyv30ol3u9r0qry3gf0v88hz312ynx1b000000000000000000000000000000000000000000000000000000000000000000000909580000000000599585500000000008114510000000000002a000000000000006600000000000000020000000000060006000000000000600700000000000036070000000000000367000000000000002700000000000000020000000",
    purpleFlower: "0g0g80000000003qupr0199eyn0l3bf9b0ohifpb17aa1of1e0teyn1mz9kvz0000000000000000000000000000000000000000000000000000000000000000000000000000000000000005500000000000005376700000000007775300000000000056337000000000007210000000000000040000000000000042000000000000000120000000000000002400000000000004100000000000000010000000",
    oxeyeDaisy: "0g0gb00000000dfzitb0ek94vz0j0p81r0mcq1a70nhgi671lxgm4f1pa4wsf1smb0fz1tqkz5r1vyt0cf000000000000000000000000000000000000000a0000000000000a7a7a00000000000986870000000000aa666aa00000000007868900000000000a7a7a0000000000000a400000000000000510000000000000040000000000000143000000000000001301000000000000051000000000000004100000000000000200000000",
    allium: "0g0gg00000000ppdce70rxldkv0t1pbsv0u5terj0ym3u2n11ya8sf1e1fw1r1f5v4e71ga4qgv1gafz0f1iiz75r1jn8t8f1n079q71p8qhvj1qd03y700000000000000000000000000000000000000a8a000000000000c89e80000000000aeae87b00000000077de8b70000000000fa8ea00000000000072ae00000000000006000000000000000400000000000000020000000000000004000000000000000500000000000000060000000000000003000000000000000100000000",
    lilacTop: "0g0gj000000002cqxof03gpb7j0j0uubj0k4nlkv0k4t7un0md191b0mdtblr0mdtce70nhrpxb17e0d8f17e0e0v18hyrjz1e21ywv1f60d8f1luohkv1mymvwf1p7bvun1qba9dr0000000000000000000000000000000000gh0000000dg00000dgd00000hgd000000hda000dgd00000000ae000bd0000000000690c300000000000042300000000000006900bdhf000fhg0009051id00000gdb00620c00000000b1c0g3000fg000000c37id00ghd000000000da0c1b0000000f000b02c0000000fh00086000000",
    lilacBottom: "0g0gl000000002cqxof03gpb7j04knoqn0j0p81r0j0uubj0k4nlkv0k4t7un0md191b0mdtce70nhrpxb17e0d8f17e0e0v18hyrjz1e21ywv1f60d8f1luohkv1mymvwf1p7bvun1qba9dr1qbaa67000ehe02800ehh00000f1d0a60chi0000000d298271c0000000000hk50d00000000000ebf00000000000000bc00ehig00000hj00502ceh000000f1f0a2db00000hhe0d5480000000hgic200a4000000000eed26a000000000000bd0800ehg000000000085dbeig000000000722d0000000000000300000000000000030000000",
    peonyTop: "0g0gq000000003dqnzz04hp1j304hp2bj04huolb05m9xq706q8b9b06q8c1r06qdybj07v4ef307vfmyn08z2sqn08ze0hr08ze1a71p769kv1qb4n3z1qba9dr1qbaa671qbr4zj1rgbytb1rgbzlr1skad4v1sl2i2n1tp0vlr1tp6hvj1vy6ku700000000000000000000000000000000000000000000000000000000000000000000000000j00000000nnn000jnj000000jijmn09hnpin0000njipf6c5hnjj0000jnnkh6cb1gg000000eh16cb480ab0000009b4b74bd70000bcd38264b440000007ba1ok147da9000000kkinl6c9nk000000jnnph282nn0000000jeg18480000",
    peonyBottom: "0g0gv000000003dqnzz04hp1j304hunsv04huolb05m9xq706q8b9b06q8c1r06qdybj07v4dmn07v4ef307vfm6707vfmyn08z2ry708z2sqn08ze0hr08ze1a708zjnjz1p769kv1qb4n3z1qba9dr1qbaa671qbr4zj1rgbytb1rgbzlr1skad4v1skadxb1tp0vlr1tp6hvj1vy6ku71x24ydb0000ag4e743k000000e0r547f83k000000gaoq64e200000000a7aag45prn000000l947e2prmn000000kl6446ltrrce0004acd84e1ljo60000044h48482ac0000000822e484gal0000egbru17e47ga000006omrla46c44800000rnlb71ur60000000002e2smi000000000084e5po0000000000048460000000000004440000000",
    roseBushTop: "0g0go000000006q8c1r06qdybj08z2ry708z2sqn0900j5r0a3taf30a3ywov0c9ujun0de9szj0j0uubj0k4t7un0v3tuyn0w7s8hr167835r17b6gov1g6z6db1g6z75r1haxjwf1haxkov1hb36yn1tiwl4v1tj27en1xznwu700000000000000000000000gk0000000000000jmem000000000000dnmg00000000kg002dd00gk0000memg07000dmem000gmn00a1300nmg0000cf00ij001fc00000070gmej0710000003b00nl500b00000000730d1007100000000100b3007100000000137000017000mhg001100070000meemd9b006b000000hmn04b80700000",
    roseBushBottom: "0g0gx000000005m9yin05mfksf06q8c1r06qdybj07v4ef308yx5of08z2ry708z2sqn0a3taf30a3ywov0de9s730j0p81r0j0uubj0k4t7un0mdtce70nhrpxb0v3o8ov0v3tuyn0w7mm7z0w7s8hr167835r17b6gov1g6z6db1g6z75r1haxjwf1haxkov1hb36yn1tiwkcf1tiwl4v1tj26m71tj27en1xznwu7000k400a703500000000030aba2qov0000003a03e3qvlov000e3a073a3jwvvl0000e30e3a3djil000n0d73ga3ge30000ovvlg3dppd3adpn0llstf9quwm2dpwvlqvwhdflvnvmfpvimiqs29gjlvmde1mr00k003edjk47a3800000739gea3ea300000003ae63ea3a000000ea3ae373aec000000ea373e379000000a9a3e3e3aaa00",
    witherRose: "0g0ga00000000000073015ikfz015o6pr015zf9b029s6in029xssf04ibenz08vn0fz0l5c2kf0000000000000000000000000000000000000000000000000000000000000000000000000000000000000009910000000000009191800000000000118110000000000001110000000000000010000000000000005720000000000027527700000000077240070000000007005000000000000000300000000000000436000000",
    TallGrass: "0g0ga000000006qdtkv07uhtdr08yrfgf08yx2in08z2osf0a312bj0a36olb0b7lwxr0dggef30000070000000000000009000006000000900300906000010031033030103091903303103013003381030310313390309103031013109030881313331310301008131330333337300810113310113130081010141013313001801014101331000118131718131300058813175813132002218215151111202821211212221210",
    
    warpedDoorTop: "0g0gc04i0ge707u6vwf07uz2f3092ophb0a5jpj30a60p330b7xmv30cb3t330fodrlr0fouosf0k1jhmn0pmetxb3353533535353338588828883662488653362665666264539775445768827227b867476768628882a886566288629992988328829962999683362997998298839667299698827537576629968862577636882998633276643888288654636646389929936772356298992993772227727899288576139912b898286466098607",
    warpedDoorBottom: "0g0gb04i0ge707uz2f3092ophb0a5jpj30a60p330b7xmv30cb3t330fodrlr0fouosf0k1jhmn0pmetxb9724153655100061825533667751157125551676885158812577177688515886278815568851577647881776775122754775188677625547854418865521611642752576564155757566255566315775a65512256311624695551114316125648777166165514655487717757534657148881775735157715115151115616111",
    spruceDoorTop: "0g0gc0ehg7wf0gpo9330l50ohr0nd8pof0ohnzlr0rtudj30sxyewv0sywflr0u30g730xe36db0zm5jpb16anym7bab4bb4bb4bb4bb4aaa39a3a939a4962ba94aa3a649a4962ba94a6356469469201741741741741728564563564563562b6a36a4aa36a4952b6a36946a36a3a52b6a3994563963a62b993964564953962a963994653a53992ba54a93653a64692ba64a64a54a945a2ba94a63a64a945929aa4653aa4aa35620173173174173172",
    spruceDoorBottom: "0g0gh0ehg7wf0gpo9330l50ohr0nd8pof0ohnzlr0rtudj30sxyewv0sywflr0u30g730xe36db0xfchz30zm5jpb10rojr312zwkxr16anym717gcnb318kgnwf85645645645gd562b6b3b635b3g53db2e6949635b4fb3ab2e6b46936b45ca5b2e6b4b94994653b62e6b4b93b64963b62b9639b4b639b4662b9636b4b53b93652eb635b49536539529b6356465455395201731741731731728564563563564562e9b4bb45649b4bb2e9b4bb35b49b4b92b994bb36b4993b622553553554553552",
    oakDoorTop: "0g0gb00000000m9fzzz0ru00lb0sz251b0u30g730yicsfz0znvvnj156v7cv19n5mnz1e3g0e71f7pou7a88aaaa8aaaa8aa78777777777777772a712222712222772a720000820000871672000092000097547200008200008728758998858998872a712222712222771a7200008200008758720000920000972a720000820000872a758998858998871a788875588875575a71222271222277287277778277663726525555825531551",
    oakDoorBottom: "0g0g90m9fzzz0ru00lb0sz251b0yicsfz0znvvnj156v7cv19n5mnz1e3g0e71f7pou72515533715500753653677763677765165665533555335518501111501111650851555561555565385155537155537518515533715533751853677763677763065666533566533338501111531111651451555561555565125155537155537506515533715533753653677763677763183356653356653311000000000000000",
    jungleDoorTop: "0g0ge00000000ddc7b30ehg7wf0k20av30sxhjb30sywflr0u30g730xdxk3j156edbz18ikr9b1buwttr1f738jj1hfgvzz1lw2kn3ccddddccdddddcc4c8abb8bbbb8bba94d9bb97877879bba7dbba87700448abb72bb8708008078bb76b8700d00d007bb7dab700d00d007bb7d8a700b00c007a84c777cdbcdbcd7444dccc99777799ccc8c9bba800008abaa4c9bb87b00c8ab9b4cabb97accb8abab7db9b97aaaa8abba7db7ba78aab7531a72b8ba8bbbb718aa4",
    jungleDoorBottom: "0g0ga0ehg7wf0sxhjb30u30g730xdxk3j156edbz18ikr9b1buwttr1f738jj1hfgvzz1lw2kn32777647777147741967664777714775186665466661577618666634444367763856763888847777384776167654665738477516775366463947751777635656394774175763477610467436476147751255554637715555193113455764431318477434776467743875761477515757395455155543554539333111333311133",
    ironDoorTop: "0g0gc00000000hts9of0l64bgf0znkj5r18kgnwf19okohr1d0wq9r1gd8s1r1ktj7cv1lxsv0f1o60w731ricxz3a99aaaa9aaaa9aa89888888888888884a846666846666884a8600009600009842860000b60000b8438600009600009849879bb9979bb9984a846666846666884a8600009600009849860000b60000b84a860000960000984a879bb9979bb9984a899987799987784a84666684666688498688889688133842767777967714775",
    ironDoorBottom: "0g0ga0c986pr0hts9of18kgnwf19okohr1d0wq9r1gd8s1r1ktj7cv1lxsv0f1o60w731ricxz30646655946644962765799975799976276776655666556628624444624444762864666674666676286466659466659628646655946655962865799975799975276777655677655538624444654444762164666674666676306466659466659627646655946655962765799975799975385567765567765234233333333333333",
    darkOakDoorTop: "0g0gf0b4hji70dcpj3z0egnxfj0ehg7wf0govx1b0hsuakf0k12ayn0m94p330ohiewv0qpf4e70u30g730v5jv2719mocu71krh2bj1y61y4f88888888888888828776667777776664875000077500006486044496704449643604549670454964a7045596704559748705559670555964870565b660565b74870666b560666b74870666b560666b64860667b760667b64860677b760677b64861777b761777b64861777b661777b7486199b967199b97436676677776edc74",
    darkOakDoorBottom: "0g0gc0b4hji70dcpj3z0ehg7wf0govx1b0hsuakf0k12ayn0m94p330ohiewv0qpf4e70u30g730v5jv271krh2bj95666666665b556375400005640000637503338560333863750343856034386375034485603448537604448550444853760454a550454a53750555a550555a53750555a650555a63750556a650556a63250566a660566a53951666a661666a53751666a561666a5376188a855188a85375555555665655536111111111111113",
    crimsonDoorTop: "0g0ga0iwhlvj0k0lmgv0m9g6bj0pkufb30swv7r30sy9wxr0ygss1r10ov667140vym71bsvx1b6998899988989984844434444443444396473646464364739676367776737764533333333333333128887888888888848677667777677773967766777747777396663467764664449444334433333333611111111111111183331333333133319443144434314431964414644443444176663666461886135766366666086403",
    crimsonDoorBottom: "0g0ga0iwhlvj0k0lmgv0m9g6bj0pkufb30swv7r30sy9wxr0ygss1r10ov667140vym71bsvx1b2777367667400033878737867761666387883887876166838888388888718881033333333333333198887888888888869777667777677774877766777747777477663467764664443444334433333333511111111111111124441434443134439644364466434463976637687763677377873788787387836343134443313131",
    birchDoorTop: "0g0ge0iwyb5r0ohcphb17fk83j19nxurj1f8hwxr1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v1y6vain677777777777777675566665556665537542222233333453752bbbabbabbb853052bbbabbabbb8531529999aa9999863762bc9cccc9cb763762cc9cbbc9cc763763999baab999863763ccabaabacc863763cdacaacadc86376399a9999a99863753bb9cbbc9bb863753bb9cbbc9bb752763ab9cbbc9ba702063ab9cbbc9ba712",
    birchDoorBottom: "0g0ge0iwyb5r0ohcphb17fk83j19nxurj1f8hwxr1josanz1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v173bbaddddabb852873aaaaaaaaaa972873dccdaadccd972873dbbcaacbbd972874999998899995286567557577575628557555756755673856756576675667385775767756576738677677775667773077667677557777317765757675776728775575657567662867566555755756285667656565565525222222222222223",
    acaciaDoorTop: "0g0ge00000000ehg7wf0ma8c1r0u0yyv30u30g730v74gsf0zlddz3155rt3317du7zz1btnojj1cxgglb1f5itxb1ii651b1jma5mndcccddddddccccc6ca999bb99bb99998da33673367336798da300c300c300c961a600c600c300c964a600c700c600cb6ba700c700c700cb6ba700d600d700db6da600d600d600db6da700d600d600d93db700d700d700d93cb700d700d700db3db600d700d700db6db600d700d600db3c9700d700d700db619acddacddac1256",
    acaciaDoorBottom: "0g0gc00000000ehg7wf0neccn30u0yyv30u30g730zlddz3155rt331btnojj1cxgglb1f5itxb1ii651b1jma5mn473356335633562599300a300a30076599300a300a300975a9500a500a500a75b9600a600a600a93b7500b500b600b93b7600b500b600b93b9600b500b600b93b9600b600b600b95a9600b600b500b9517600b600b500b7647500b500b500b7697600b600b600b75998abb8abb8abb75a9997779997777755633335555556665",
    
    crimsonDoor: "0g0g700000000iwhlvj0m9g6bj0pkufb30sy9wxr10ov6671bsvx1b0000000000000000000000000000000000015535553550000001553555355000000466666666600000025555555550000001333333333000000155355535500000045535556650000002553555115000000155355535500000015535553550000004666666666000000255555555500000013333333330000001111111111000",
    warpedDoor: "0g0g9000000004i0ge7092ophb0a60p330b7xmv30cb3t330fouosf0k1jhmn0pmetxb0000000000000000000000000000000000056643646640000005622664664000000826266463300000076626626630000005624624234000000336463466400000086646343340000007664364114000000522436466400000036626642340000008664662663000000733462466400000036632646330000005555555555000",
    acaciaDoor: "0g0g500000000c8fxtr0zldfjz1asop331cxxczj0000000000000000000000000000000000024444444440000002440404044000000144040404400000024404040440000002440404044000000244040404400000024444443340000002440404044000000244040404400000024404040440000001440404044000000244040404400000024404040440000002222222222000",
    jungleDoor: "0g0g400000000qpkttr18iqfwf1cz0uf30000000000000000000000000000000000023333333330000002333202333000000133020203300000023302020330000002333333333000000233300033300000023333333330000002333333113000000233333333300000023333333330000001333333333000000233333333300000023333333330000002222222222000",
    birchDoor: "0g0g8000000011v5mnz16bx3wf1bvdn271n1fmkf1n1foxr1o60w731x2r9xb0000000000000000000000000000000000024544444440000002477667744000000146666664400000024767767440000002476776744000000246666664400000024767767340000002476776734000000246666664400000024776677440000001444444444000000244444444400000024444444440000002222222222000",
    darkOakDoor: "0g0g500000000a0j56n0iwyb5r0m94p331y5lkov0000000000000000000000000000000000013333333330000001322232223000000432223222300000013222322230000001322232223000000132223222300000013333334430000001322232223000000132223222300000013222322230000004322232223000000132223222300000013333333330000001111111111000",
    ironDoor: "0g0g500000000l64bgf1584m4f1hhcsn31ktouf30000000000000000000000000000000000024444444440000002400040004000000140004000400000024444444440000002400040004000000240004000400000024444444440000002433343334000000243334333400000024444444440000001433343334000000243334333400000024444444440000002222222222000",
    spruceDoor: "0g0g600000000ddc7b30ma8c1r0qpkrgf0xe36db12zwkxr0000000000000000000000000000000000034444444440000003444444444000000122222222200000034444444440000003444444444000000344444444400000032222222520000003444444454000000344444444400000034444444440000001222222222000000344444444400000034444444440000003333333333000",
    oakDoor: "0g0g5000000008wkrnj0sy416n17fehvj1czsw730000000000000000000000000000000000023333333330000002300030003000000130003000300000023333333330000002300030003000000230003000300000023333331130000002344434443000000234443444300000023333333330000001344434443000000234443444300000023333333330000002222222222000",
    
    torch: "0g0gd00000000egz6rj0fl37cv0gp77y70htb8jj0ndpnnj0u22fi7156v85b17f3a4f1y2mc5b1y5l3b31y70gzj1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a900000000000000bc000000000000008600000000000000750000000000000084000000000000008500000000000000750000000000000063000000000000008200000000000000610000000",
    soulTorch: "0g0gd0000000006fbb30dkjoxr0egz6rj0fl37cv0gp77y70htb8jj0ndpnnj0u22fi70xkd0qn156v85b17f3a4f1y711j3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021000000000000009c00000000000000b800000000000000a700000000000000b600000000000000b700000000000000a7000000000000008500000000000000b400000000000000830000000",
    
    lantern: "0g0gc000000008x7i7z0gptzb30hu3nr30iy7p4v0zkwgsf12xjrwf1ihjf9b1uqx79b1x10sfz1y70fen1y70tmn0244200000000000065560000004220024444200000201005788750000020100689986000001210069ba96000000000069ab960000020100589985000001210024444200000000002233220000000000234432000004220034444300000201003444430000000000234432000000000022332200000000000000000000000000",
    soulLantern: "0g0gb0000000005sq9r07z7enz08x7i7z0a7fgn30gptzb30hu3nr30iy7p4v0u80yyn1inns3j1vyyo730577500000000000075570000007550057777500000503005144150000050300728827000003530078a9870000000000789a870000050300528825000003530057777500000000005566550000000000567765000007550067777600000503006777760000000000567765000000000055665500000000000000000000000000",
    
    beaconGlass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
    beaconObsidian: "0g0g50000073013yfb304gainz0a0p1q70fksanz1000012104311343101202104211342100443013322023010432231212001210032220000001110122200211114311002212344310301001102422020000043000432223310032223200213321021211211011121100210302112012144322221442022234212421332111022211103103112131122010012102012320111111",
    beacon: "0g0ga0bar6rj0bbdr0f0k7hofz0u7k07317jn2tb1inns3j1kuxzpb1n3ha7z1tr7jen1y711j39999999999999999900000111111000690011112211110069011222322221106911222333322211691122345543221169012345775432116902235788753321691233578875322069112345775432116911223455432211691122233332221069011222232221106901111122111110690000011110000066666666666666666",
    
    cactusTop: "0g0g900000000fmt0cf0hv6n0f0hv6nsv0mbxwcf0okh5a70rwt69r17gnmdb1f9a6m70000000000000000013331337313311003444344444444100345735565355430034564586546543001345665658444100375655666555430034664466666643003466846656654300345666668547430014456656654441003456455664554300345547555357430014443144424441001133133331331100000000000000000",
    cactusSide: "0g0g900000000fmt0cf0hv6nsv0k3k9of0mbxwcf0okh5a70rwt69r17gnmdb1f9a6m70156534665156410024548456516658087454144653665100155514565756420015662466414541001665146641455808166414864146510016651465415651001564245441664200146524644166420024657565416547802455156541644108745515665265410014641566426541001465145658554100156614455146410",
    cactusBottom: "0g0g7000000002aeqrj03fm41r131ary718ljny71jppypr1lxsdmn0000000000000000012222111222211002555566555566100265334444335520026455666655352001535566665536200253555435554610025456466365461001646646646645100164665345664520026456666555452002535565555545200255434444336520015555666666661001122212222221100000000000000000",
    
    glassPaneSide: "0g0g400000001d2bim71hje60v1y711j30000000320000000000000031000000000000003200000000000000220000000000000023000000000000003100000000000000210000000000000021000000000000003100000000000000210000000000000032000000000000003100000000000000320000000000000032000000000000003100000000000000310000000",
    glassPaneTop: "0g0g400000001d2bim71hje60v1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000333333232232233311221211111322120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    
    ladder: "0g0g700000000fl385b0m9fzzz0ru00lb0yicsfz156v7cv1e3g0e70052000000005200046456566665646003432333333243300021000000002100005200000000520006645666565564600343233333324330002100000000210000520000000052000664566666656440034323333332433000210000000021000052000000005200066456566665646003432333333243300021000000002100",
		vine: "0g0g500000000ok5z3z0qse0an0u4q22n0zpa51b0002143113023440033213000202134044312000004311004321000004432100002100000112320003221002210032111332331230032100200234403032440000001340000234000000210000321330000031000021000000132130044100001332133004321021043110300302111303211000001220020021232021013300",
    
    Water: function(n){
      var pix = getPixels("0g0g819okofo1bwspmc1hhcsl01ktoud01lxsuyc1n1wvjo1x2x0vo1y711h02111000111112435000011111100000011000000112221001000122111221111001110000100011100101121112110002111111111114472434111211111112277424742121221140000000000000100100001000112111100000000000000010000000000010000100001111122101000000001127732101211466211211111")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]/255
				setPixel(n, i >> 2 & 15, i >> 6, bright*10, bright*30, bright*255, pix[i + 3]);
			}
    },
    Lava: "0g0gp1jjxhbz1jjxi4f1jk33lr1knvuv31ko1hxb1lsrytb1lsrzlr1mwqd4v1o1mhvj1o1minz1p5kven1p5kw731p67ev31p6io731qa5se71qabfgf1qaxxbz1qaxy4f1rewbnj1sjmuwv1sjmvpb1to7sov1ut3zsv1ut9m2n1y687b3965ckke60666999cf996f8c66cd69fjddd96606669f67hold967629c96669lll966666dhc9969jfh97666chh69df699c96999kk969kd69f99696dlnf069536669ha66fh960066456hhk97690017ll66chgl96000009ml5696969hg63066862666666kl7066c60068li69990669d6609knldh66046699hb6hefckh960656fhd69",
    
    craftingTableTop: "0g0g903c6e4f06oif3z0hsj18f0k0r37j0nd8r9b0v4xd6n17dojcv1bu4kxr1gbtpfj1001255555521011088267777776288008277777777772801274344433334721267467477377476257747736746747755774434434434775577477477477477557747747747747755773334334434775577367376377477526746737736747621274434444444721082777777777728018826777777628811101255555521001",
    craftingTableSide: "0g0gh04gaepr06oif3z0a0ufb30b4n4zj0fkmbr30hsj18f0k0r37j0ru00lb0v4xd6n0yicsfz156v7cv17fehvj1bvja4f1e50qv31f7pou71hfxp8f1o60w731ceff486684fffe11eccab4664cceeb11eeecec22bbccee1199aa971197977911fbffff66ffeccb11ee5b5b44cceeee11bc3c3c44eeccbb11799g97117999a911ffgcgf66fffffe11cededc44bcbcbb11eccbbb44cccbbe1179aa97009a997711beffee66ffbfef11ceebbc44eececc11bbcecb44ecbbbb1199779a119797771",
    craftingTableFront: "0g0gh04gaepr06oif3z0b4n4zj0fkmbr30hsj18f0k0r37j0ru00lb0v4xd6n0yicsfz156v7cv17fehvj1bvja4f1e50qv31f7pou71hfxp8f1o60w731y711j31bdee375573eeed11dbb9a3553bbdda11dddbdb33aabbdd118899861186444811eaeeee55ee2b2a11dd4aba33bb222d11ab2bbb33ddccca116829861168gff811ee2bbe55eegffd11bfffdb33abaffa11dcfgaa33bbbgfd11689986008988f611adeedd55eeaege11bddaab33ddbdbb11aabdba33dbaaaa11886689118686661",
    
    crimsonNyliumTop: "0g0gb0rs4iyn0rsa60v0v4gkqn0v4m7sv0xana4f0yelnnj10p0npb152yh331br00e71g7lptr1hbk3cv665022781508847275526677572777880356a2357825787420153555726274776351871536a625293557027508476266575376488726530535326787982a205776357474843262155557532671535783753a62635150735530762355175784375788774726357820557536726663777553017357a62743152625305526787057",
    crimsonNyliumSide: "0g0gl0gnskcf0l3m2gv0l3xclb0m7kfzz0nbzqpr0nc5drz0of09vj0rs4iyn0rsa60v0sutrzz0v4gkqn0v4m7sv0w8ey9r0w8klbz0xana4f0yelnnj10p0npb152yh331br00e71g7lptr1hbk3cvhihiheijhhhihijifhijehijjihjjih99fehfhhe99ekef96f6f9f9ff69hf696636966696639f66333336346653666344348f0d474563547ac49627cb99b76fb7727a7229f6aa797b67aga7067a7ac1964c7aa706bgac2002726b72302a71024237b96b73223d7a734c7aaga32247aga327aag724207a7a77227aa27c4027aa77",
    warpedNyliumTop: "0g0gf01a28e702e0lxb02eybjz02eyccf03fmgov03gq1a703gq22n03gvocf03iwp330gqauwv0hvcjjz0hvi5tr0izax330izgjcv0ng7r3zee49aa519491146c744aee6646c655119d4e3cc460c45154a994c4447cea7465ec490794ce3ea4c2c4479c749046eaee474c6e4115ce4b94c4cae61580c3c9476ec4746414caea9444464cae694c460c74c2eaea49497c44c96eac44974714c747106647aea450c94474ce7ceeec65744c997c462ea64c94aea4c944ce616946",
    warpedNyliumSide: "0g0gn02e0lxb02eybjz03fmgov03fmhhb03gq1a703gq22n03gvocf03iwp330b5qosf0c9p2bj0gnskcf0gqauwv0gqavpb0l3m2gv0l3rpj30l3xclb0m7kfzz0nbzqpr0rs4iyn0v4gkqn0w8ey9r0w8klbz10p0npb40406b0744404070b507b607704770522bb6b66b22b1bb29c9b2b2bc936b9399g93999398g3c99ggggg8gh98hg998ghhghicalhihh8ghhijkh38fikk33ki8ckiifikife3c8kji3ik8ijmjia9ikijkg38hkijjia8kmjkfaafie8kifgafjidafhfgik38kigffglijighkikjmjgffhijmjgfijjmifhfaijijiiffijjfikhafijjii",
    warpedStemTop: "0g0gk01a28e703fmgov03gvocf06r0ovz0900vsv0b75erj0dhkflr0dhq1vj0ekl0cf0ekl14v0ekwb9b0el1xj30hs7z0f0hsp3b30hsupkv0iwng1r0iwngu70iwt33z0k0fzen0k0g073cce1ii2f0hcic2ecebbbb9b8689bbabe2b33554544445562cb366aaaa8aab5bcj95a88888888a49jcb4a85544558b59ch9588398895885bd084a85944848a480f94a85945958b59f284a859998488582i95a85535448a49ii94a88888888a59i1b4ba8baaaa6b591eb454555555555becbbb99b98799babccce1ii2f0gcjc2ec",
    warpedStemSide: "0g0gp018yq6702bzev302c514v02cx3pb02dp9fj02duvpb03fmgov03fmhhb03gk7wf03gk8ov03hnmyn04lar5r0gp1ybj0gp7klb0hs7y7z0hs7z0f0hsdm2n0hsunzz0hsuosf0hsupkv0iwng1r0iwngu70k0fzen0k0g0730ncmewvffjann6j3jfnf2jfffj3fn6j3jnnj6jfj26jjnj22fofjj2jafn6jffj2jon6j33jnoj6jnj6jnoj23jfooj6jonj6jnfj2jj6ooj6nooj6jj2jn2nomj6fmooj66jmm2ffjfj6jfnnj6fooj0f2nmj66jf66jonk50jeoofj6l6knne0jnfjnoof66j1ffj2nm6jenok6jf0kekjmi2j6fn2ifnj4i2fj1jf7lfj0kmnk0jff9cnf6gdb8hf2jf",
    crimsonStemTop: "0g0gh0hs7z0f0l3rn5r0m7q0ov0ogqepr0ogqfi70pkot1b0swplhb0yelnnj0ygn5rz0zkljb310ov66711stjpb140qccf152yh33154opvj154uc5b1br00e7002700d1g2000d202bbbb9a8c89bbab2da004464666644ed0b0feaaaa8aab4b0094a88888888a6900b6a85466448a49029488098894884b2g86a85866868a68g196a84864948a491d86a84999868848d094a84505668a690096a88888888a4907a6ba8aaaaaeb4872b636444444444b20bba99a98f99bab0002700d1g2000d20",
    crimsonStemSide: "0g0gj0hs7y7z0hs7z0f0k0fzen0k0g0730l3rn5r0m7q0ov0m7q1hb0nboe7z0ncmewv0xana4f0yelnnj11qmfb313yughr13yuha7152su0v166r7jz1ancwzj1cv9o1r1dz81kv115h33a5e5131b51115e13a5e5335a515ba5535bb18155b5h13a5115b583a5ee5385a535a5385be51885a5835a5315b55a885a3885a55b53b3835a13885aa522b11515a51335a1885e1b325aa51aa5834if518815a4a4331e53153881aa5b115b33951384a51f414535b5a13b5135h5b15b51a415e4334f511c731a07gd61b51",
    warpedWartBlock: "0g0g702e0lxb03gq1a703gq22n03gvocf03iwp3304jkwlb04k1s731111656111151116116604151665511666116111151351015611156550153141541115536166611650114055111156356511115611142551165365366110651115555116111155111511116601165351561156654625613651156563666626541105613512561531161561511651115111151151115104511154165011511051",
    shroomlight: "0g0gh1dzj3sv1mwkohr1o0j20v1o0ooan1rdsr271rdydbz1y2bd331y2bdvj1y2h05b1y3vvnj1y3vwfz1y41ipr1y4tp8f1y4zbi71y5rl6n1y5x7gf1y6perj303518843009ee7105444199852de9d838899dc991879dc92489eeed94996998519eg9d819cc96a4249f99719cgge9841811dda19cgg998484ff14481de994a88aec7eed84dd819984d96eg9d4811b984847dd99d8a99444884d44dd944eefa184fc9a48129eg9451dc9a4ddb1a97843489844d9834444304414424200352300",
    polishedBlackstoneBricks: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj3554554554554430343435443223334034544423224424404343433443432120443333433332112023441233212212302243232221132330110011000011111154554440124555453343434034344544234544402355444343343420443443344343232045432323323221104432121221121210332211110011100000101100",
    gildedBlackstone: "0g0ga05k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70iw63un0l5yqrj0yh98n31o36n0f1y6dkvz2332220233343553308750023334435308122103389432107233332334791121133444244662812544643213222271253443222533225211122225732133211311233034318752233331013215133225222378112364433713344192114664383344438211113472446622272222255244631125011103313221112022235322",
    chiseledPolishedBlackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj5554555555554452534344333334334053111212222215315315555555452541541544444434244144253433333425315413555555431541542451555153254154235154414315315323444444432431542533222234154154244443443315314312222121111531335554555545453123334344333333322212100000102121",
    blackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj2332220233343113300110023334431301122103344432100233332334451121133444244552112144543213222211213443222133221211122220032133211311233034310112233331013210133220222320112354433013344102114554313344431211113412445522212222210244531120011103313221112022232322",
    blackstoneTop: "0g0g505k8ttr07sb8qn0a0uhof0dd6ltr0gpioe72344331234322300044332111232103404342234311134231232033442144342220002442003433122242013000033211244343012100211134343314422013322342024333302342201122443320011400234324421012343233444200134244034402321024442124432121102343213342323432023223211332344400430",
    netheriteBlock: "0g0ga0a0oven0c92jnj0dd0x6n0flk8hr0gp7bwf0hts9of0k1uolb0l5ne9r0l5yp6n0oiaqyn4244444444424420269999999998998049366888567766804956778868875380496578788886546049565768988854624955568889666360496538888865638049688886685653624988985556556362288878555533448049878763353341802836665335341180283433341111148228666888688888602000022000220000",
    basaltSide: "0g0g506p53b30ddc9of0flkbnj0l5yp6n0pmkdtr3023343444343313101134344434332201133444443432330033444434341233203434323322330221144322343231021114242344323123113122334341313213343243444102331333434444441244113343443443034411344344234403413334433213432321133123231332342213234244313224333033434443432343",
    basaltTop: "0g0g706p53b30ehga9r0gpoc8v0l5yp6n0pmkdtr0wb8hdr11vskcf4455351155441441456511331442211325311344412652343145234531556413056542441155542004544221451442440044001444512332511033244551032544133442550001542223454220155144344044144154451344550145545444014555224533144100054145233100144001144450155145541443445056434544",
    polishedBasaltSide: "0g0g606p53b30ddc9of0flkbnj0l5yp6n0pmkdtr0wb8hdr1235443544334421023545354543342202354545454534221335555545554422123455454555433222344545455543321234355543544321113335555354432101353545545353210135354555545320014545455554431012444545555543101345453555453321234545355545433123454535454543312345443545444432",
    polishedBasaltTop: "0g0g70ddc9of0ehga9r0gpoc8v0l5yp6n0pmkdtr0wb8hdr11vskcf0255331155431320054464436445343225656554655654443453434433333553244366665555333226546434434535442433636565354664566363634545354444435364353636532563545555364665345354343346354444535555566635523554333434333653246653645644555225565455564545420245443555434520",
    chain: "0g0g400000000a1bitb0gpzlkv0k2boxr0001010000000000322112000000000020100000000000001123220000000000000201000000000000010100000000003221120000000000201000000000000010100000000000001122220000000000000201000000000000010100000000003221120000000000201000000000000011232200000000000002010000000000",
    warpedTrapdoor: "0g0g7000000007uz2f30b7xmv30cb3t330elit4v0fodrlr0fouosf3111131113113111165456464444656315335333345332513630540036200351166024600600045315200240045024631422006002405661344200600040365116400450004033511620462000402543352062000550044115305500052002411630252005050363163325422442334336446544444444533111133131113331",
    warpedPlanks: "0g0g704i0ge707u6vwf07uz2f30b7xmv30cb3t330fodrlr0fouosf5356666656666652553324355533554435553534444335522112210011010010564666646665334535534342433555534435333255533444001121000011121056653366666666545355553444343442653344443333445400122100012110006456655466646566335544344553533334435342553444440110012221010000",
    warpedFungus: "0g0gc000000004lrqpr05nj7r305omscf05qtg5b0gqavpb0iwhlvj0k0lmgv0ncs16n1sfq5fj1y125fj1y3kmbj00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a4444ab41000000314444aa13000000233a913332000000222995522200000000006600000000000000760000000000000087000000000000007800000000000000870000000",
    magma: "0g1ca0hs27zz0m81d6n0rsft330v4m7sv1jkpkov1rdbzen1vu37y71vueiv31wzat4v1wzrrwf042101272002542133100025210374129953225412381257531745425784212451245421223520124002731001127321201382310003845742328755212742447445432452542125215220124742102712721001252002820387210025210272413252102712315274125122585784242455788733215312154223731012472005210125200247313310003521025512599323771225125553174883455731244124473122383013400253100113723120127121000255745221755731245387777542388345213521532013755210271242100135200272025421002421025371225210341231425812712385457524387445783221831214522243101348300521012720027421231000282102841259932274122812555318457257742125712644212225201280025310011252212013723100037445522154452138835754554225427831272152201245531025128310012420025203853100252103735122731037123283751251235887583524544458333173121572225210124520",
    crimsonFungus: "0g0gg00000000jz6rr30k181z30m81blr0m81d6n0oho3jz0v2w6wv0v4m7sv0xeekfz10p0npb1539r7j19jk7b31hbe96n1iftrsv1y125fj1y3kmbj0000000000000000000000000000000000000000000000000000000000000000000000ddbf00000000000fedbba0000000000eedefa00000000006aaee6000000003bddb633c60000001366633661000000013311331000000000004200000000000000570000000000000098000000000000008900000000000000970000000",
    warpedRoots: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000044100000000000004410000000000000132044100004410002004430000443040300332000033201410102000000201310010140000410303303001000003020030300110000303001030410000430310142010000010003001003000003003203300300000320200322020000002020220202000",
    twistingVines: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000003300000000000003130000000000000143140000000000044421300000000004412000000000001441200000000000141120000000004134130000000003134432000000000002113200000000000213300000000000034320000000000044432000000000004412200000000000241220000000",
    twistingVinesPlant: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000211320000000000002112014000000000231413130000000002144300000000000211410000000000023111300000000000231130000000000021132000000000004132200000000003443200000000410443320000000313444320000000000014322000000000031132000000000001132200000000000233220000000",
    netherSprouts: "0g0g4000000004lrqpr05omscf05qtg5b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000010300301003000001031030101300002101201020230100220120202021020",
    crimsonRoots: "0g0g500000000m79czj0rr17un13yjfun1bqosn30000000000000000000000000000000000000000000000000000000000000000000002002000000000004020202000000001443020020000002043403020200000203241303003000003244320232400320414203241042020040310404000403003003040300130030310223023131000303121021341000010310101013000",
    weepingVines: "0g0g400000000of09vj0suze9r0xana4f0000233002210000000013300221000000001210002300000000011000330000000001000231000000000000012000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    weepingVinesPlant: "0g0g800000000of09vj0suze9r0xana4f1539r7j19jk7b31iftrsv1y125fj0000232000320000000033100032670006513300001455606751310000111000001130000022200000233000002230000023156600033560000315756002210000001110000032000000033000012300000003320763220000000222001220000000665103220000000665440335600000000110033476000000223002310000",
    spruceTrapdoor: "0g0g90ehg7wf0gpo9330nd8pof0ohnzlr0rtudj30sxyewv0sywflr0xe36db0zm5jpb4873882853783754487385245357357445827734527528540163163163163160445345245345245445825735825828444582773452752854477275345374275447527735428427744843872542853574485385384387348448835428838824540162162163162160485385384387348448738828537837544873852453573574",
    oakTrapdoor: "0g0g700000000k1j85b0qq1m9r0v6c0sf11uughr17exm9r1czhmv31111111111111111245445554544545213122235512223412520006542000642242000654200064224200065420006521236565543666421254555454555555225554445545454422412223541222352252000655200065214100055420005412420006542000652253566554356664224555545455555421111111111111111",
    jungleTrapdoor: "0g0gb00000000ddc7b30k20av30sxhjb30sywflr0v5v6rj156edbz17emdq71cz0uf31f739bz1hfgvzz5533555355553555579989988999897339888768768768933789807007089873579800800a008975579000a0080009755780007007000875599a9a9aa9a9a995568767687686a8655787007007009875578800a008008875578870800807887537988878878889733798aa9888aa997557787122421787755535553533555335",
    ironTrapdoor: "0g0g800000731d0wq9r1f94rgf1hhcsn31lxn7y71n1wvlr1pa4wsf1ricxz31222333333322221244444455444444224233354423335422430005443000542343000544300054334300064430006433445567554567743354444555544445335444455554444533423335552333543343000544300054324300054430005432430006443000642244567744455674224444445544444421222233333322221",
    darkOakTrapdoor: "0g0g80b4hji70dcpj3z0govx1b0hsuakf0k12ayn0m94p330qpf4e70v5jv274455554554444444430000155300001440222275402222744024447440244475414445754144457541455575514555754166776551667764455455555455545444555545444555444300001543000015402222745022227540244475502444754144457551444575414555755145557441667764516677644445554455554444",
    crimsonTrapdoor: "0g0g700000000k0lmgv0pkufb30swv7r30ygss1r10ov667140vym72111121112112111154645656666545214223222233223412520000000000241151223211112214214556666556654521612211112322151262000000000024115200000000002411511121233221162244566664645546114122232112111611520000000000252152232233323226225665466666666422111122121112221",
    birchTrapdoor: "0g0ge0iwyb5r0ohcphb0sxn37j17fk83j19nxurj1f8hwxr1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v344433344434444336777766777766644733333333333374478bccbccaccb374478ccdaddbdcc374469abbaaabaaa374369cdcacdacdc374378cddbddaddc364379cdcbdcacdc363479bbaaabbaab374479cdcbddbcdc373479ccdaddadcc373379bc788999cb363378998666658836436776601206677733344433334444334",
    acaciaTrapdoor: "0g0ga00000000ehg7wf0ma8c1r0v74gsf11t4irj12xe4u7169evpb1btnnr31f5zoqn1jm4gzj4444444444444444466778888888877445558745587455844600974009740084460097400974008446009740097400844600974009740084460097400974008446009750097500844600975009750084460097500975008446009750097500844600975009750084477898778987789446898233332898644444412222144444",
    
    bedplanks: "0g0g70ru00lb0yicsfz156v7cv17fehvj1bvja4f1f7pou71hfxp8f5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    bedbottom: "0g0g418fls731brmj271dzuk8v1g82lfj1212222200123330121110011223333012221222333333321123333333222321012222222222222101222222221112210012222222221123101222222220112321012222222101233111122222221133321211122222123333012222222113322320122221110221133333332210011101222111121122100001222211221000",
    bedtop: "0g0gd0svgc8v10ng93313zmnsv18fls731aszz7j1brmj271dzuk8v1g82lfj1hhcsn31ilxqf31o66j9b1tqkz5r1y711j3aabbaa9999aabbaaab988888888889babb89abbbbbba98bbbb8abccccccba8bbba8bccccccccb8abaa8bccccccccb8aaa989abbbbbba989a444444444444444400000000000000002222222111112332333322222223773367777633333332226777777763222222112222111111111155333355533335555555666555335676",
		bedlegs: "0g0g70sy416n0yicu0v16atkvz17fehvj1czhmv31gbtpfj1y711j36660003226666666666000402666666666600032266666660244202233226666125520123321666602442000000066666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666",
    bedbottomsides: "0g0gb0svgc8v0sy416n0yicu0v10ng93313zmnsv16atkvz17fehvj18fls731czhmv31gbtpfj1y711j3434444777777744333333334444444333444333333333333000000000000000055858985588999851111111111111256344777777774433333344333333333343333344444444444000000000000000058999885589858556521111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    bedtopsides: "0g0gh0svgc8v0sy416n0w7h4ov0yicu0v10ng93313zmnsv16atkvz17fehvj18fls731aszz7j1czhmv31dzuk8v1gbtpfj1ilxqf31o66j9b1tqkz5r1y711j3eeffffe90588b288defffed905888285ddddddd90455824499999999000000006acccaa66aca6a667631111111111111882585409effffee852584409defffed552555509ddddddd000000009999999966a6aca66aaccca61111111111111367gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg",
    bedfrontback: "0g0gf0svgc8v0sy416n0tzeprz0yicu0v10ng93313zmnsv16atkvz18fls731aszz7j1czhmv31gbtpfj1ilxqf31o66j9b1tqkz5r1y711j344455557777775444444555555554444444444444444444400020000000000009669996696999669a63311111111336accddddddddddddccbcccddddddddcccbbbbccccccccccbbb88888888888888889669996696999669a63311111111336aeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    bedIcon: "0g0g6000000000000730htb8jj0sy416n0v2qj270v74gsf1111111111115011111400011140000114000000100000004000000040000000400000002000002030000111120011111101111111011111110111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    
    respawnAnchorTop1: "0g0gl000007307sgwlb08wkzjz09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k7b30b3kf7j0c7imf30c92oe70dbh0qn0dbh1j30efff270gnc7pb0l35s730ndeuwv0qn3ke70ziwirjicaiiiaiiiiiaicic222ccc222cck22ci21111111111112aaj100000000001cii2100000000001cii2100006700001ciic10005dfb0001kaic100677he90012ii210054589g0012iac1000433900012ii2100006800001ciic100000000001ciic100000000001jaa21111111111112ic22k2cc22c2cc22cicijiiiiiaiiiaci",
    respawnAnchorTop2: "0g0gr000007307sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c92oe70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjogcooocooooocogog222ggg222ggq22go21111111111112ccp100000000001goo2100053390001goo21006a78ef001goog105a6hjfie01qcog106788nibm012oo21066569blk012ocg1063544bdi012oo21006a797b001goog100087bd0001goog100000000001pcc21111111111112og22q2gg22g2gg22gogopooooocooocgo",
    respawnAnchorTop3: "0g0gv000007307sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c92oe70dbgzy70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0hral8f0hram0v0iv90cf0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjsgcssscssssscsgsg222ggg222ggu22gs21111111111112cct1000l6770001gss210mk5339e301gss210j6a78efo01gssg1b5a6ikfje31ucsg1b6788rjbqh12ss21m66569bml812scg1o63544bdji12ss210n6a797bo01gssg10mo87bdpk01gssg1000mbbp0001tcc21111111111112sg22u2gg22g2gg22gsgstssssscssscgs",
    respawnAnchorTop: "0g0gv07sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c7ipkv0c92oe70dbgzy70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0hral8f0hram0v0iv90cf0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjsgbsssbsssssbsgsg111ggg111ggu11gs10000000000001bbt028ol5663dp0gss108mk4228d2c0gss10oj5967deo40gssg0a495ikejd20ubsg0a5677rjaqh01ss10m55458aml701sbg0o52433acji01ss106n59686aoj0gssg03mo76acpk40gssg065omaapf520tbb10000000000001sg11u1gg11g1gg11gsgstsssssbsssbgs",
    respawnAnchorTopOff: "0g0g8013yfb307sgwlb08wkzjz0b3kf7j0c92oe70ndeuwv0qn3ke70ziwirj5435553555553545422244422244722452111111111111233610000000000145521000000000014552100000000001455410000000000173541000000000012552100000000001253410000000000125521000000000014554100000000001455410000000000163321111111111112542272442242442245456555553555345",
    respawnAnchorSide3: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd44749997144311ed34417911113391d933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide1: "0g0gf0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1x1ncov1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743d13479949994744de114474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorBottom: "0g0g80000073013yfb304gainz0a0p1q70b3kf7j0fksanz0qn3ke70ziwirj1000412105311353101204405216352100553013322723014532236212701640034244667701116122760211165311406712355410306004102522764006053000534723346032224260276321621264244671141100260302142612155322441552042235612421332161022264403103162131162040012106012324111411",
    respawnAnchorSide4: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd447499971443dfed3441791111339dd933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide2: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd4474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide0: "0g0gd0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirja9a6aaa99b9a9b9a7469a733337a69474499933333399944949974311347994999474411114474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    
    flintAndSteel: "0g0gc000000001440sf05kk35r0b5464f0ddc7b30ixwa9r0neccn30v74gsf0yjgikf17gcnb31asop331f94rgf000000000000000000005500000000000005bb5000000000005b947400000000005b4044000000000059500000000000005950000000000000575054000200000047959400262000000479400234100000004400246831000000000234a321000000000268322310000000026423461000000000132111000000000001100000",
    oakSapling: "0g0g9000000004ixywv07vl8fz0hwqwvz0l50ohr0nhrtvj0ohcphb0v5v56n0yict8f0000000000000000000000000003000000000005002200000000103500187100000077231187660000535270177625000005378607705350000000774700055000000217530120000006762535276400003227678476423003330657746403300000053273500030000003547530000000000006745000000000000664000000",
    cryingObsidian: "0g0g80000073013yfb304gainz0a0p1q70b3kf7j0fksanz0qn3ke70ziwirj1000412105311353101204405216352100553013322723014532236212701640034244667701116122760211165311406712355410306004102522764006053000534723346032224260276321621264244671141100260302142612155322441552042235612421332161022264403103162131162040012106012324111411",
    netherGoldOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1cwijun1ihp1j31wzx4ov1y6dkvz1y70nb3131242554404454334432024521044215454771243914245654ab93545a814245659a45664552543154385665548445414520545542ba56553102454985894664245422744554145245ab40245455112354594025655270247254218254179321454254ba21545413545565a9834565124556423274545442245524530245544",
    
    potDirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
    flowerPot: "0g0g600000000rt2ayn0w91g5b0xd5gqn0zldh4v11tfugv0000000000000000000000000000000000000000000000000000000000000000000000000000000000000455321000000000050000200000000005000020000000000500002000000000050000300000000005443430000000000534423000000000054323100000000005443210000000000543421000000000053222100000",
		acaciaSapling: "0g0g700000000rvpou70sxskqn0wc5pmn0yi6z270ykjcan12yn0n30000000030000000000010035300000000015503405100000015355441561000000166364546510000001643526600000000543514431000000335512455110000003166446100000000064462100000000004354233000000033123121000000000314122400000000000464220000000000046420000000000002422000000",
    birchSapling: "0g0g700000000mbmpdr0ojuprz0u4vl6n1bxerr31jq1hj31qe337j0000000020000000000000033000000000000002422000000000032051330000000003325433200000003341651200000000302564412000000000231423200000000233543343000000233141241300000021346651020000033456663300000000303365030000000000233210000000000004210000000000000443000000",
    blueOrchidPot: "0g0g8000000005om32707xc2kf0a66pkv0bax81r0cfi2nz0k4nn5r0nhm4fz0000000000000000000000000000000000000000000000000000000000000000000000540000000000000343200003000000032630003440000000270000620000000000600700000003200020700000003436023430000000020070450000000000006720000000000000016000000000000000610000000000000010000000",
    crimsonRootsPot: "0g0g700000000m79czj0rr17un0yerif613yjfnm13yjfun1bqosn30000000000000000000000000000000000300000000000000003000000000000000042002052000000006020206000000000665020060000000005605020000000005261505000000000266520250000000016205261000000000510606000000000005060500000000000225020000000005121021500000000510101010000",
    darkOakSapling: "0g0g9000000004ixywv07vl8fz0hwqwvz0l50ohr0nhrtvj0ohcphb0v5v56n0yict8f0000000000000000000000000000000000000000000320000001233000130100000035213521320000132442521651000001412321431000000002111226640000003116221442000001106661441530000001326641000000003527674000000000147877600000000000787640000000000068674700000000066764660000",
    jungleSapling: "0g0g9000000006otm2n08x1lof0b6cyrj0c9dlvj0cbpz3z0ddhlof0ekev3z0flpm2n0000000000000000000007503000000000000573453000000000043647750000000057444347000000000378340300000000006853000000000534857430000000007737375000000000505863440000000000068457000000000035830300000000004387000000000005784530000000000058630000000000034214300000",
    spruceSapling: "0g0g7000000004g4qv308xo8an0c8liin0cabim70fmt6nz0m94p330000000000000000000000020000000000000021200000000000004150000000000005432400000000002426122000000000063245300000000003442552000000005442245000000000424522200000000003556254000000003546354500000002422635505000000004422244000000000023202000000000000110000000",
    warpedRootsPot: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000044100000000000004410000000000000132044100004410002004430000443040300332000033201410002000000200310013100000012303303000000000020030300000000003001030000000000310142000000000003001000000000003203300000000000200322000000000020220200000",
    
    smoothBasalt: "0g0g606p53b30ddc9of0flkbnj0l5yp6n0pmkdtr0sywflr3244223333332244234332234421123332132134434213344321234444502344332322445510244321321234410123331131233321024322022344232113444123344332323444303344444111244322243344321212343232344543112344432145521123244443233210012433443343210012443444344423211343343244",
    crackedNetherBricks: "0g0g80282ebj06o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf1111111111111111667626773666274643451541544516144513244144432441111222111112221126776053265656651654144417444333254404332543333322111111121111125520751203270125441144105515141534250425442044251222122212221222527525775434220542441544344310744423144333341544",
    polishedBlackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj5545554554555443543445343343433043544333234544315534433443343421554323234343232353554443234544334434433443343423453544325442322155453422443232404434354432233341545444232144244253434334324321325433334342321331534412334334144143432322211334323222221222222212",
    chiseledNetherBricks: "0g0g706o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf6666366565563664656526433335255062342533333526305430000000000630301055455345110053306654555615405330353533531630643053555666143031105115511500006430665355361630533034111143063053306533566604303111011100000110564414666666164053330433344303404111011111110110",
    
    oakLogSW: "0g0g60fkxl330l5hmgv0pls0730wa4su7142r7jz16az8qn2222333333333332333444444001233343331112233333441111333344453311441021322110011333333444443333330012223322232211333355433335543332222134430001014553332222334344000101233322233333333444333344313222233355443344452331100133311111001333133113333334442233335544",
    acaciaLogSW: "0g0g60m9x0cf0oi51j30oiaolb0syl3wf0xf169r12zl7nj2222333333333332333444444001233343331112233333441111333344453311441021322110011333333444443333330012223322232211333355433335543332222134430001014553332222334344000101233322233333333444333344313222233355443344452331100133311111001333133113333334442233335544",
    birchLogSW: "0g0g80ehg5j30qqiprz1gd8ovz1o60ttr1p9o0e71tqqkn31uujbwf1y711j36677202376630016637310367376101334673155537720233437636576473136646773647645531363677373773754134666367377677464376313775767637667710467556766776760144775763777663013477577373736412637647767363642336734776631467363633667361364776124673642036377311377334006",
    darkOakLogSW: "0g0g60b4ssu70dcv6670dcv6yn0gp77y70k1dl330oho0e72222333333333332333444444001233343331112233333441111333344453311441021322110011333333444443333330012223322232211333355433335543332222134430001014553332222334344000101233322233333333444333344313222233355443344452331100133311111001333133113333334442233335544",
    jungleLogSW: "0g0g90gp75kv0htb5dr0m9fwu70ne0s8v0ohnx8f0qqct8f0sxsphb0walkhr0yi730f4164406440761642418230824056144240127082415114426042514242301462614230428242416464144141826131142412112461643164240413260162426421081526136262422418432415616402245642404741630241764240854083118134626082404514841464416251431664164460415112464416146141741644",
    spruceLogSW: "0g0g60c8a9z30c8liin0dcjw1r0fkrx8f0l50ohr0nd8pof1111333333333331333444444002133343332221133333442222333344453322442012311220022333333444443333330021113311131122333355433335543331111234430002024553331111334344000202133311133333333444333344323111133355443344451332200233322222002333233223333334441133335544",
    crimsonStemSW: "0g0g80iwhlvj0k0lmgv0m81blr0ncs16n0xana4f11qxpfj153445b1cvfb3z0026221131022520225665213310026254225252021027250224202444256210110131242442011201331242102420262202242312444267665542330420252222522131240331004420131042331024111022442131044010224422010222017624223125204522224133330061125600501341067211200027202552265200",
    warpedStemSW: "0g0g804k1s7304kturj05nj7r305pkd8f0iwhlvj0iwypdr0k0lmgv0ncs16n4451556676455054550110567764451502550505456453504552545222501564664676525225466546776525645254515545525765222513110025774254505555055676524776442254676425776452666455225676422464552255464555463152557650542055552677774416650144046726413566544453545005510544",
    basaltSideSW: "0g0g506p53b30ddc9of0flkbnj0l5yp6n0pmkdtr3233223234411233123300233444223433223111223334433331333301002322444422211434322333332334444443344444344344433313444333444432113444442233344423443344322344443244444443422333332333343422344442443133444143344133211331133333332300100111331133303100221111113113",
    polishedBasaltSideSW: "0g0g606p53b30ddc9of0flkbnj0l5yp6n0pmkdtr0wb8hdr1222221110001112222233222211233344443333333333344334444455443444335555443445555434455555555544444555553345555555444444455555554455555555555555553345445544443333455555555555555444455433334444445555444355545555333333333344444422232221111233331001121100011222",
    
    crimsonPlanks: "0g0g70gof7r30iwhlvj0k0lmgv0pkufb30swv7r30ygss1r10ov6675456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    deadBush: "0g0g500000000m9fzzz0ru00lb1568lj31cypdz30000000000010000000030000021000000003000202000000000230031100000000002302101000000000243100000000011102323000110000122034202310000000123413200000000001233100000000000013300000000001200321000000000012222000000000000212202200000000001212100000000000111000000",
    
    chainIcon: "0g0g400000000a1bitb0gpzlkv0k2boxr0000000000000000000000101000000000000013100000000000000200000000000000312000000000000020100000000000001010000000000000131000000000000002000000000000000100000000000000212000000000000020100000000000001010000000000000132000000000000002000000000000000000000000",
    lanternIcon: "0g0ga00000000gpzlkv0k2boxr0zl23un11tlf5r1hdl2in1uqx81r1x10sfz1y70em71y70tmn0000000000000000000000001000000000000001200000000000000210000000000000010000000000000012210000000000004334000000000001222210000000000356653000000000046776400000000004798740000000000478974000000000036776300000000001222210000000000000000000000000000000000000",
    soulLanternIcon: "0g0g80000000005sq9r0bbdtdr0gpzlkv0k2boxr0wg3d331kvkj5r1y711j30000000000000000000000003000000000000003400000000000000430000000000000030000000000000034430000000000004334000000000003444430000000000312213000000000042552400000000004576540000000000456754000000000032552300000000003444430000000000000000000000000000000000000",
    
    coal: "0g0ga000000004gg3cv07sgwlb07ss4cf0a0owzj0a105j30c986pr0ddc7b30ehg7wf0flpx4v0000000000000000000000000000000000000333300000000000367763000000000358975530000000038576765300000003445898753000003565458865710000369756665451000035666555644410003555456452521000324544444242100001224524422100000012222111100000000111100000000000000000000000",
    stick: "0g0g800000000b4n4zj0ehg7pc0ixwa2o0k17x8f0sxsoov11udg5b1584lxc0000000000000000000000000000033000000000000034100000000000034610000000000034610000000000034510000000000034610000000000034510000000000034610000000000034510000000000004610000000000004517200000000004617720000000004610220000000000110000000000000000000000000000",
    emerald: "0g0gb0000000001pt6n0034dmn004op33005s45b006k8an05sdfr30i0nv270zs3pq71bzx9fj1o7fjsv000000000000000000000000000000000000002222000000000002a77620000000002a97756100000002a997755610000002966995451000000296698535100000029669853510000002966885361000000296687346100000002543348100000000025436100000000000111100000000000000000000000000000000000000",
    lapisLazuli: "0g0g80000000015dh4v04ic5j306q3b3z07utxj30ej169r0ok1atb0wci2gv0000000000000000000000000000000000000003333100000000003466541000000003567542410000003565642451000000376454256100000036674255610000035465255610000035764256441000003265245541000000152256541000000014564111000000000111100000000000000000000000000000000000000000",
    diamond: "0g0gb000000004k7hmn05ndjwf06ub56n07xbqpr093bbb30cg9ywv0k8fgfz18nwo3j1n3h8n31y711j3000000000000000000000000000000000000001111000000000001aaa910000000001a77895200000001a788987520000001a7a9a9772000001a7a7788353200001a797888453200001aa58887433200001977333355420000027355553520000002635555382000000024778852000000000222222000000000000000000000",
    goldIngot: "0g0g900000000w893b31cxx3i71p7anlr1sk94vz1x1hhq71y6oxdr1y70vzz1y711j30000000000000000000000000000000000000000002200000000000222552000000022266666620002225666666665102766666666667761257666666777635125676677764333512565876433334551246564333345511002456433441110000024544111000000000221100000000000000000000000000000000000000000",
    ironIngot: "0g0g900000000ehg7wf0oigd8f0pmkdtr0v74gsf0znkj5r1asop331o60w731y711j30000000000000000000000000000000000000000003300000000000333664000000033367777640003336777777776403877777777778874368777777888746136687788875445613666887544446661356675444466511003567544551110000035652111000000000331100000000000000000000000000000000000000000",
    copperIngot: "0g0g900000000u0tddr11sywhr17cwef317d7ojj1hd9xxb1rea2gv1x0pzpb1y33w8v0000000000000000000000000000000000000000003300000000000333552000000033365445620003335665445665203856665445668862368665556888544136586688865542413645785445542251364485445542411003548445541110000034645111000000000331100000000000000000000000000000000000000000",
    rawIron: "0g0g900000000flej270ne0ykf11v06pr1bvjgfz1o4aozj1sl7pbz1y5rt331y6pptr0000000000000000002222200000000002577652220000000278787675222000268887878776520026568877676565201644654433454520153454443223442015335443222223101433322227864410144332226667543101433311466532210011110014443221000000000144221000000000001111000000000000000000",
    rawGold: "0g0g800000000u1fsvz1cxx3i71qb3chr1vwwidb1x29fjz1y6pa0v1y711j30000000000000000000000000000000000000022222220000000223446533200000234545544332000267545544544100277767766543310027766665434321002565454433322100135454433345641013354432456743100143332244333210013432213443221000133210132221000001110001111000000000000000000",
    rawCopper: "0g0gh00000000a1sc1r0b6u4n30fnwqgv0l8mghr0lacfsv0qqczjz0u0tddr10va4n311st9fj156jy0v19kyqyn1jlcb9b1jrgg731si2sxr1y33w8v1y4od8f000000000000000000000000000000000002220002999900002433222aeffc9002554534aefgfe70028d855aaccec97093a5433ab99bc7009fe4a3ab99bbb7009ffecacb99b977707efcecb99bfcebb707eccb9b9fgecb61016b9b997effb631014369777ccb93310011170007c9911000000000001110000000000000000000",
    copperOre: "0g0ge0fnfu2n0fnwqgv0lacfsv0oksv7j0pmkdtr0sywflr0wb8hdr0yjgikf0znkb9b12zwkxr18kgnwf1hdqvwf1q9usjj1uqaxa79999799765667767776766777775567776115445556cb966779641145979a767666418cb897766777958bcda9664456967779aa9654884676564456770323b579951845799038cb6732238797691aa976913a9745779a776779a755b457797667666518cdb6565579918a9181a97512679aa979aa97799797776767977777997",
    
    netherWart: "0g0g700000000jz6rr30m81blr0v2w6wv0zjnjen19jk7b31iftrsv0000000000000000000000000000000000221100000000000246541000000000255556410003320025655441003465201455543103455642013543200265554100154200024565310014420331255410021441345414421023243125431441002324311432143100021331013101310001132101310121000112210121012100",
		wheat: "0g0g700000000oj2fb30wb835r11vmhhb19nxqtb1kskvlr1p8pon30000006000000000056000560000000006400065000600000450002420650000042400455456006000454004450446500053300500032562304340650304044056435354030304504550432405640050334042040445005033403005033500403050203503042045206010345002403410545021450520301042102101041010",
    
    lodestoneSide: "0g0g80flk9a70k20cfz0sywflr0wb8hdr0yjgikf12zwkxr18kmcjj1at00sf7677656555565667764001112122146664423434332424466112430000432106613335034045430541545044340445154250035004300515413034000054041442414510115513154241136116411524424661566516651442254615526345254244551222552225477255666654266555522422222426544556665655566655",
    lodestoneTop: "0g0g50sywflr0yjgikf12zwkxr18kmcjj1at00sf4344433444433444411100101100011441444434443444134143323232323403304321232123331441322111121224034042121111112314404221111111331431421111111224043133211112113404403222121122240331432321123233144043322223233404414444334434441441100001001011144443333334434444",
    anvilTop: "0g0g600000000flk8hr0gpo9330hts9of0k20av30ma8c1r0000000000000000000000000000000000000000000000003343222333222211345434553444433244534454445454325453545345545433555455545545553245555455553555434545545554354543454553455434354334434234554334333321122212222331000000000000000000000000000000000000000000000000",
    anvil: "0g0g60flk8hr0gpo9330hts9of0k20av30ma8c1r0oigd8f1122335555443211123445554444432111333444445534311223444455544322133233444444344101233234433321101233211233322200122333223333431011223322234444310123333212443211011222112333211101221122332111100001101221111000012221001112221100122211112210000001122211100000",
    
    slime: "0g0g50olklv80qty9bo0va8r040xigqlw0ximegk2213321122213342244444223222220434321221112321231421013222222121241002221200212223211122340122222321222233222122231210222222213223120022222220322212223222011232122122222111232112322222221003213224322021101342300112111222334240123333444444422432221122222122",
    soulSoil: "0g0g50egz94v0gp1n9b0k181z30oho3jz0sxyiv33221122101123344221023101013233421003310012224231111320012223332100230222233232101133223332332211133233344322210232233234322111221133443222112221133443221113321343443221123211144432121133200133432211133210124432210023310023443120012321012434221012221012334",
    blueIce: "0g0g50t0y9kv0u52a670wda9rz131n01r1aty3un0112221002343211001121100043211100111112102321011010123320131001110024322012101221013343200102222002333230003322101333221100243210233222112103431122312211220121012121221021002100012121000110110110110100122210111122100122222011123320022222321123322023223321",
    packedIce: "0g0g60yl1czj10t9ddr145ldkv18lq48v1ge6ubj1jqd7gf0012233221023330012243112213310012243012311100002231003310110011222100210022122221222110022223321122111222223311001113321223321001123220113431001222221002531000322321002420010123321002321001123321001121001222331101111221122231111112232122341111222233122353",
    ice: "0g0g610t9e4e131brge145ldj218lq4721ge6u9q1jqd7em0002243222113332002233222112321001222222112321002212221112121101211221210001112211222110001222330122112011223322001112221223432101122220113432201222220003532200222320002322200123321002322221023322000122221122532100122221122232100022322112352000224322111343",
    calcite: "0g0g61d0wq9r1jpkt1b1o60ven1tqkxkv1uuumtb1y711j34323123211454233322210221553322332210012354333233210011234444322211012334443421212012322243331005532221233232012343321123222112332255431245223442233453112425543123334212333432223332323433342213332245553223211123213543221001225541344221001225433234321211124",
    
    loomTop: "0g0gd0dcv7r30m9lm9r0sy416n0zmb5z310qqnsv1576pdr19n5lvj1arwg731czhmv31e4e51b1gbifb31jo5rzz1lx68e7b39393937393939b80709090907070788171719191919178819171917171719881919191919191988090c09090c190c8829292c2c2c2c29886c6c6c6c6c6c6c881c1c17171c1c1c88191c1c19191919881717171717171788040404040404048abbaabbabbbbbbba81417151715171488010101010101018bb8ba8aaabbb8bab",
    loomSide: "0g0g90ncxji70u1ac5b0zmb5z310phiin12xpiwv19n5lvj1gbifb31ik1ptr1jo5rzz8888868866666888611111111111111861033333333330166343333344333416633333333111100660113133333333166333333333333316655555555555552667888686888678866111111111111116633344444333341661111131333311166103333333333016614444443344431668887688868886762222222222222222",
    loomFront: "0g0gf0dcv7r30m9lm9r0ncxji70sy416n0u1ac5b0zmb5z310qqnsv16bapz319n5lvj1arwg731czhmv31e4e51b1gbifb31ik1ptr1jo5rzzebebebebe9e9ebee89898989898b89888b8989898989898889a9a9a9a9a9a9a887a7a7a7a7a7a7a887a7a7a7a7a7a7a8871717171717171886363636363636388eeddeeeededdde88d244444444442c88aacaccccccacaa88000000000000008801111111111110880355555555553088aeeddeedeeecda85555555555555555",
    loomBottom: "0g0g40dcv7r30m9lm9r0sy416n0zmb5z31111111111111111100000000000002110111111111111211011111111111121100000000000001110111111111111211011111111111121100000000000001110111111111111211011111111111121100000000000001110111111111111211011111111111121100000000000001113333333333333311111111111111111",
    jukeboxTop: "0g0g706oigov0b544jj0eh4wzj0oh1hq70ohcrun0xdrym7155xhq71122112222212111134554444455443114566654456665422465554114555642246555410455565214655540045556521465554004555652256555400455564225655540045556422565554004555642246555400455565124655540145556512465554114555652245666544566654213455444555444311112222222212111",
    jukeboxSide: "0g0g60b544jj0hsuc5b0oh1hq70ohcrun0xdrym7155xhq70000000000000000034554455554543004515151515141400515212521252150055152515251425004212521252124500552515241524140041521252125213003415241524142500421252125212440054241524152414004142124212421300431424142414140031114111411143003333333333333300000000000000000",
    noteBlock: "0g0g60b544jj0hsuc5b0oh1hq70ohcrun0xdrym7155xhq70000000000000000034554455554543004515151515141400515212521252150055152515251425004212521252124500552515241524140041521252125213003415241524142500421252125212440054241524152414004142124212421300431424142414140031114111411143003333333333333300000000000000000",
    furnaceFront: "0g0gd04gg2kf08ww4xr0gpim0v0ma2ozj0pmeqrj0sywflr0wb8hdr10rojr31440lj317gcnb31asop331d0wq9r1ilgt8f3333233322232233355665656656564324686756787865633577211111127653367200000000264226500011110008423650022222200843268aabbbbbbaa86226765465456565533cbccccccccccca33aaaba7777abab9239a8410000148a933883000000003693368000111100098328601111111106922522233333322252",
    furnaceSide: "0g0gc0gpim0v0ma2ozj0pmeqrj0sywflr0wb8hdr0yjgikf10rojr31440lj317gcnb31asop331d0wq9r1ilgt8f1111011100010011123343643334332112477232664366411366672347663661124664243676243002233267634631101377436676334421046673664276664003443224276664311babbbbbbbbbbb911899a9aaaaaa8a8008899999999999710788889899999871157878888987875113344344444433311111011100001111",
    furnaceTop: "0g0g70gpim0v0ma2ozj0pmeqrj0sywflr0wb8hdr10rojr31440lj31111011100010011122235542334532112466442565355411365662466653441145654234666243003233254334522101256356665225531046653666356664006666445356664511666653353455511146664566653223002454366666536410522324566645551146224234443554112434541233234311111011100001111",
    blastFurnaceFront: "0g0gg04gg2kf0gpo9vj0k20av30l64bgf0oigd8f0rumry70sywflr0v7fojj0wb8hdr0yjgikf11vmy2n12zwkxr17gcnb31asubcv1e50qv31ilgt8ffdbb68686886fdbbd12632112221d126b24722333443b247877a12221133877a61134544432211168122244312233338823aaaaa88886338633afffffddd62266118cd0d0d0c6116befc6d0d0d0c4eeb6b6c6d0c0c0c4cc66b847cfcfcf74ac66ba2777777772ba64aa2222444444a9449a98888888899944444444444444444",
    blastFurnaceSide: "0g0gf0gpo9vj0k20av30l64bgf0oigd8f0rumry70sywflr0v7fojj0wb8hdr0yjgikf11vmy2n12zwkxr17gcnb31asubcv1e50qv31ilgt8fecaa57757775ecaac01521001110c015a13611222332a136766901110022766950023433321100055011133211122335712332121233332772332122011222175011000000111005adddddddddddddda59babbabaa999aa559a9ba9aa9a9a8a55989a9a989998985389889899898787337887877887877733333333333333333",
    blastFurnaceTop: "0g0g60gpo9vj0k20av30l64bgf0oigd8f0sywflr0wb8hdr4554433333344555541211000112214441123321000121155021100011222225412331012333210432100000001100043232101233333203311011233221111330001101000010133122022122333223311233222112221342221100010110035001111101332105511232123321011554122101121001454545443333335353",
    smokerBottom: "0g0g80fl385b0gpim0v0ma2ozj0pmeqrj0ru00lb0sywflr0wb8hdr10rojr34422122211121144402357763556720422677663777577222577773677775662267776356777365115355376556733212377577777337752167775777577776117777667577776722777775575677722267776777775335113676577777757621733536777767772227336356665772244256762355352040422122211112244",
    smokerFront: "0g0gj06oo3r308wku0v0a105j30egz9xb0fl385b0gpim0v0k20av30m9fzzz0ma2ozj0oigd8f0ru00lb0sywflr0wb8hdr0yicsfz0yjgikf11vmy2n156v7cv1asubcv1ilgt8fga555555555555ggd74aadda7dd7a47aga47aa7477aa74a7gg9bbbbbbbbbc9daad6ii2000002bbgg7a9ii0000000fcadda9ih0000002fc7adg6ie2222222cfa777ffcfhfhhhhff77a7113731137111gddg1da3d33da3a1daad4477474477447aga4da4da4da4a4ddgd3a73a73a7377adad133133133131a77488888888888874",
    smokerSide: "0g0gc0fl385b0gpim0v0m9fzzz0ma2ozj0pmeqrj0ru00lb0sywflr0wb8hdr0yicsfz10rojr31440lj3156v7cvb5111111111111bb8205588528825025b502552022552052bb4666466666648558699479999676bb257974679994775885664976679447258b76999994499452227767776777772252002202002200b88b085085085050855805205205202225b53aa4a4aaa6a388b8399a467a9963585839974769a943522033333333333320",
    smokerTop: "0g0ga06oo3r30a105j30fl385b0gpim0v0ma2ozj0pmeqrj0ru00lb0sywflr0wb8hdr10rojr36644344433343366624579985778942644877887777799444777995899997884487943111134587337573111111355434579110000119774387911000011978339791100001197944979110000119744487931111113557335894311113477843955758999989794449558578887774466478984577574262644344433334466",
    
    chiseledSandstone: "0g0g71ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa71tqf5rz6666656655565555433332233333333221211111111010006666665555555550634330033003323053333103310332204344344004433320534333000033322044334404403432202111111111100000555555555555454053303300333000404302112112144020414143414313313043443333223323201111111110100000",
    cutSandstone: "0g0g71ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa71tqf5rz6666656555555554433222223323332222111111100000006666652555555540644343332442323164323333333332405333433322333340433224433243432052333343333333305223333333223320532342334323322024334433234333405434433333333330433333333322234144214344332134410100001100000000",
    sandstoneTop: "0g0g51n1a1vj1o5jqbj1p9td6n1qdxfcv1ricpa70322342222123321232223333131233133133234222102234233222323233212333321033333312222333013134311222132332132332212102232332131232121022343112232113202333321333321331134313233323332323310232332323123310133214311331333223332233222431233233322332023133222343332",
    sandstone: "0g0g71ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa71tqf5rz6666656555555554433222223323332200001100011000005014555515551015313232514433313335114410434340533331100013321003333504551214551013014333414343501002335300323334344253315514433133301015325104011315530323333024415441533324135231442015410001333311145114512211",
    sandstoneBottom: "0g0g61ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa70244131433351344243310003331044213314441010030213014332315551105313232514433313335114410434340533331100013321003333504551214551013014333414343501002335300323334344253315514433133301015325104011315530323333024415441533324135231442015410001333311145114512210",
    
    tallGrassTop: function(n){
      var pix = getPixels("0g0g600000000ruy1a70v7a3270znkj5r157yzun1bwn3en0300000000000000003030000050000000304000005003000040340000403000000504000430400000050400040040000004050005005000000405020500500000050502050450200005050025051100000505404505400004054540540520000025435054052000000540505404000000025050402400300300505040250300")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]/255
				setPixel(n, i >> 2 & 15, i >> 6, bright*40, bright*160, bright*0, pix[i + 3]);
			}
    },
    tallGrassBottom: function(n){
      var pix = getPixels("0g0g600000000ruy1a70v7a3270znkj5r157yzun1bwn3en0030404050254300004030405005040000404050400405000400505030420540030350403040052043034041404004204403203150300420250200315133042005120131512305100414022141240511131503214215152132151421331514214114131423141341412312141313314131321213121231312121121212121221")
      for (let i = 0; i < pix.length; i += 4) {
        let bright = pix[i]/255
				setPixel(n, i >> 2 & 15, i >> 6, bright*40, bright*160, bright*0, pix[i + 3]);
			}
    },
    apple: "0g0gb00000000nbd79b0ncgidb0w893b30ygmrjz17av8xr1dyljpb1p2ayv31xy98fz1y0rhfj1y2yfi70000000000000000000000000300000000000000420000000000000030000000000005532330000000056a6257633000005689aaa9863300005688888878630000567878777871000036677667687100003666667668610000036676667610000003566677651000000015655651000000000133311000000000000000000000",
    
    diamondPickaxe: "0g0ga0000073029bi0v03e7p4v0a6hfy70b4n4zj0bb80sf0dkjhtr0k17x8f0sxsoov11udg5b0000000000000000000000000000000000000022222000000000026533527800000000211133940000000000007531000000000007843510000000007940131000000007840013100000007940001510000007840000161000007940000001000007840000000000007940000000000000440000000000000000000000000000",
    goldenPickaxe: "0g0ga00000730b4n4zj0gp1iin0k17x8f0sxsoov0zm5ddr11udg5b1sk94vz1smlrlr1y70anz0000000000000000000000000000000000000055555000000000059877853400000000522277610000000000003872000000000003417820000000003610272000000003410027200000003610002820000003410000292000003610000002000003410000000000003610000000000000110000000000000000000000000000",
    ironPickaxe: "0g0ga000000006oo3r30b4n4zj0ixwa9r0k17x8f0sxsoov11udg5b1hhcsn31o60w731y711j30000000000000000000000000000000000000033333000000000039877834500000000311177620000000000004871000000000004527810000000004620171000000004520017100000004620001810000004520000191000004620000001000004520000000000004620000000000000220000000000000000000000000000",
    stonePickaxe: "0g0ga000000006oo3r30b4n4zj0k17x8f0k20av30sxsoov0yjgikf11udg5b11vskcf16c8mpr0000000000000000000000000000000000000044444000000000049866843500000000411166720000000000003861000000000003526810000000003720161000000003520016100000003720001810000003520000191000003720000001000003520000000000003720000000000000220000000000000000000000000000",
    woodenPickaxe: "0g0g8000007308wkrnj0b4n4zj0egz5z30k17x8f0sxyayn0wa4ovz11udg5b0000000000000000000000000000000000000033333000000000037655634500000000311155720000000000004651000000000004525610000000004720151000000004520015100000004720001610000004520000171000004720000001000004520000000000004720000000000000220000000000000000000000000000",
    
    flint: "0g0g8000000003cc1z308ww4xr0c986pr0gpo9330neccn30yjgikf1asop330000000000000000000000000000000000000000222000000000000243210000000000244451000000000234556510000000234557541000000244457442310000243356443231000023336443222510002334343222461000124333223461000001333334451000000012234441000000000111111000000000000000000000",
    mossBlock: "0g0g60huk9330k2s73z0mb5ukf0rv8zjz0u3s7pb0v8d1j31401142113211225403423510231413301430113212421050220543322124431102513513114533223203331143013134211231033153021041201431354351512121234333133531145231315421213245311433133015322103331513113213224315413124313242513431143154313204322325434333111533225332134",
    
    caveVinesPlantLit: "0g0ge00000000fl8ydb0huk5xb0huk9330k2xtdr0l50ohr0mbh3wf0ohi9dr0u3s7pb0v5v20v0v8d1j319m222n1sip3pb1vy05bz000064665aa074240000666564aa704400070009664aa000043bb0790886a00042bdcaa70088800044bcaa4670005000000aa46650043500000a686001424bb0000888066744bdcb000050644997bccb0000564667aa7bb000000666064aa7000000050bb664aa00000437bdcb686a0000424066cb08880000447644b0007340",
    caveVinesPlant: "0g0gb00000000fl8ydb0huk5xb0huk9330k2xtdr0l50ohr0mbh3wf0ohi9dr0u3s7pb0v5v20v0v8d1j3000064665aa074240000666564aa704400070009664aa000043900790886a00042470aa7008880004405aa4670005000000aa46650043500000a686001424900000888066744090000005064499709000000564667aa790000000666064aa700000005005664aa000004370090686a0000424066900888000044764470007340",
    caveVinesLit: "0g0gd00000000huk5xb0huk9330k2xtdr0l50ohr0mbh3wf0ohi9dr0u3s7pb0v5v20v0v8d1j319m222n1sip3pb1vy05bz00005355499023000006555453993130009acba655399330095abba6077590000970aa380077730000099808230433000099370831340000099377060aa5900009597452acb7590009976052abba7900000060759aa1300000072509206313000009270225273300000979032729000000009000397900000000000000900000",
    caveVines: "0g0ga00000000huk5xb0huk9330k2xtdr0l50ohr0mbh3wf0ohi9dr0u3s7pb0v5v20v0v8d1j30000535549902300000655545399313000924236553993300957632607759000097080380077730000099808230433000099370831340000099377060335900009597452700759000997605290067900000060759081300000072509206313000009270225273300000979032729000000009000397900000000000000900000",
    sporeBlossomBase: "0g0g500000000mb5ukf0u3s7pb0v8d1j310t2pz30000000000000000002300320000233000244024423044300004231433243420044334423212430004323423213312200244213211132440004332111242334000232422133433000024144232442200000443233122323000432132114343300242303341044000043420244000230004420022000033000000000000000000",
    sporeBlossom: "0g0ga00000000ygn85b15502db1e0ygov1g90tts1myxb7j1p4z7jz1toottr1vtc1rz1y2c7wf0000000000000000000000000000000000000000000000000000000660000000000000688600000000000689986000000000699999960000000439988993400000486988889684000299868888689920019898866889891001698863368896100123863333683210001133211233110000011215512110000000215775120000",
    hangingRoots: "0g0g700000000xdxkvz141nvnj156k0e71buww731f737r31f7pxj31010105310103501012500320013040200060223010504200246620632064060020060066026006000024002640400400044044206024004004004006600420000000206400402000000000400020000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    rootedDirt: "0g0g90ohcrun0u30g730xdxkvz10rojr3141nvnj156k0e71buww731f737r31f7pxj37552076528022727268225602786446072667685722820465178604855282752525685245021650220558504022022278222622762772568247785225655625652462820255622022542240252546725258772456220566252265748645205202052558626226277262222582040285558072026772526855265523265225580",
    floweringAzaleaPlant: "0g0gb00000000huk9330ix3vun0k2s73z0l5bx1b0mb5ukf0ohny0v0rv8zjz0sxycjj0u3s7pb0v8d1j33995a953a753355a95a797937333937753a9a5a59735a39a555a59a79a57a7a35a57575a7a793a353a5a7a5959a9535735a35a7a79559593193571a97a5195a735a5951a9a13a7a705a9a235a5253a37095a52077227100000310224220000000000004640440000000000086440000000000008800000000000000680000000",
    floweringAzaleaTop: "0g0g90k2s73z0mb5ukf0ne6dq70rv8zjz0u3s7pb0v8d1j317dds731f5p9fj1ludc731551345353535311153443454541544434378653585143345548273457434441311676154145534354345444133345343145433131357865555454531344827338545311345567655745551313345413435445343435434535337865354541341453827434548455433467654443731444451415453443301135353535431103",
    floweringAzaleaSide: "0g0gb00000000huk9330k2s73z0mb5ukf0ne6dq70rv8zjz0u3s7pb0v8d1j317dds731f5p9fj1ludc73266376327539a837639a8562a22a495532a493739528986733898675673575723735353757562723273a5739a87632352379375a49336a62162351789831697503736317671075750376700373000720003730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    azaleaPlant: "0g0gb00000000huk9330ix3vun0k2s73z0l5bx1b0mb5ukf0ohny0v0rv8zjz0sxycjj0u3s7pb0v8d1j33995a953a753355a95a797937333937753a9a5a59735a39a555a59a79a57a7a35a57575a7a793a353a5a7a5959a9535735a35a7a79559593193571a97a5195a735a5951a9a13a7a705a9a235a5253a37095a52077227100000310224220000000000004640440000000000086440000000000008800000000000000680000000",
    azaleaTop: "0g0g50k2s73z0mb5ukf0rv8zjz0u3s7pb0v8d1j31441234242424211142332343431433323221143434132234421443242323331211432313134423243214421122234232134322121442344444343421123423223434211234424444434231212224312324324232324323424221434243431231342314232414344322312143212321333341314342332201124242424321102",
    azaleaSide: "0g0g700000000huk9330k2s73z0mb5ukf0rv8zjz0u3s7pb0v8d1j32553653264322336536454524222524432656363542362563336356456346462363434364645262326364635356532342362364645335352152341654631536403635316561064640365600363000620003630000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    pottedFloweringAzaleaBushPlant: "0g0ge00000000huk9330k2s73z0l5bx1b0mb5ukf0ne6dq70ohny0v0rv8zjz0sxycjj0u3s7pb0v8d1j317dds731f5p9fj1ludc73000000000000000000000000000000000000000000000000000000000000000000000000000000000007474a7a792000000a7a4949a9400000024a7cdb449000000471ad5c4190000004941bcb12a0000009a024a4342000000a4007733710000000033880000000000000368000000000000003600000000000000330000000",
    pottedFloweringAzaleaBushSide: "0g0gb00000000huk9330k2s73z0mb5ukf0ne6dq70rv8zjz0u3s7pb0v8d1j317dds731f5p9fj1ludc73000000000000000000000000000000000000000000000000000000000000000000000000000000000000367567350000000039a85756000000005a493676000000003898569300000000517657810000000063176712000000007023730300000000300550050000000000000000000000000000000000000000000000000000",
    pottedFloweringAzaleaBushTop: "0g0g900000000mb5ukf0ne6dq70rv8zjz0u3s7pb0v8d1j317dds731f5p9fj1ludc730000000000000000000000000000000000000000000000000000000000000000000055435343000000004341786500000000553182730000000043316765000000005453113400000000538134550000000034731333000000003534343500000000000000000000000000000000000000000000000000000000000000000000",
    pottedAzaleaBushPlant: "0g0ga00000000huk9330k2s73z0l5bx1b0mb5ukf0ohny0v0rv8zjz0sxycjj0u3s7pb0v8d1j30000000000000000000000000000000000000000000000000000000000000000000000000000000000064649696820000009694848984000000249696844800000046198694180000004841989129000000890249434200000094006633610000000033770000000000000357000000000000003500000000000000330000000",
    pottedAzaleaBushSide: "0g0g700000000huk9330k2s73z0mb5ukf0rv8zjz0u3s7pb0v8d1j30000000000000000000000000000000000000000000000000000000000000000000000000000000000003564563400000000343646450000000046353565000000003646453300000000416546310000000053165612000000006023630300000000300440040000000000000000000000000000000000000000000000000000",
    pottedAzaleaBushTop: "0g0g500000000mb5ukf0rv8zjz0u3s7pb0v8d1j30000000000000000000000000000000000000000000000000000000000000000000044324232000000003231313400000000442112220000000032212144000000004342112300000000421123440000000023121222000000002423232400000000000000000000000000000000000000000000000000000000000000000000",
    
    //spacer0: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
    sunflowerFront: "0g0g700000001g9xxj31luhzpb1urdvr31vwfl6n1y5fs3j1y6dlof0000000000000000000000000000000000000000000000000000000000000000000000466400000000000656556000000000454334540000000066321366000000006531235600000000454334540000000006565550000000000045540000000000000000000000000000000000000000000000000000000000000000000000",
    sunflowerBack: "0g0g6000000005om3270a3cflr0k4nn5r0md19tr0nhm4fz0000000000000000000000000000000000000000000000000000000000000000000000222200000000000214312000000000213553120000000024554432000000002354343200000000213453120000000002133120000000000022220000000000000000000000000000000000000000000000000000000000000000000000",
    sunflowerBottom: "0g0g6000000005om3270a3cflr0k4nn5r0md19tr0nhm4fz0000000543000000000000344000000000000004300000000000000430330000000000044123000000000003421100000000000531000000000000345000000000000004430000000000330310000000000032113000000000001123300000000000011312000000000000011100000000000001200000000000000220000000",
    sunflowerTop: "0g0g6000000005om3270a3cflr0k4nn5r0md19tr0nhm4fz0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000220000000000000012000000000000003100000000000000430000000000000043210000000003303110000000000321130000000000001233000000000000013100000000000000150000000",
    
    waterBucket: "0g0ge000000008ymvwf0cayw3j0ehg7wf0ej1b0f0izhddr0ok1dz30v74gsf0xfchz31584m4f16c8mpr1asop331o60w731y711j3000000000000000000000333333000000003388aaaa33000003812544221830000315665464513000033314554133300003cb33333379300003ccccbb9779300003ccdcbb977b300003bcdcbb977b3000037cdcbb97793000003cccbb97930000003bccb9979300000003bcb9793000000000333333000000000000000000000",
    lavaBucket: "0g0gd00000000ehg7wf0v74gsf0ygy6f31584m4f17f3i0v1asop331e3g8an1kocwsf1o60w731qay1a71rhk3r31y711j30000000000000000000001111110000000011a577881100000158bbaaba871000018ababbaba8100001638ab8bb841000019633338a24100001999966482610000199c966422610000169c966482610000129c966422410000019996642410000001699644241000000016964241000000000111111000000000000000000000",
    bucket: "0g0g900000000ehg7wf0neccn30pmkdtr0v74gsf1584m4f1asop331o60w731y711j30000000000000000000001111110000000011455566110000014433344454100001322234444310000111223344111000017611111145100001777766544510000177876654461000016787665446100001478766544510000017776654510000001677655451000000016765451000000000111111000000000000000000000",
    
    cowSpawnEgg: function(n){
      var pix = spawnEgg
      var pix2 = spawnEggOverlay
      for (let i = 0; i < pix.length; i += 4) {
        var r = 58, g = 47, b = 34
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 200, g = 200, b = 200
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
    
    sugarCaneIcon: "0g0g700000000b6il1b0fn48vz0j08cfz0qt5zpb0ymkhrz15bv0u70000000000000000000000000000000000000000065100000000005156100000000005436350560000000435641565100000005642564100000004642431100000004442551245000033432454341100001331454111000000031343100000000001133100000000000003100000000000000100000000000000000000000000",
    sugarCane: "0g0g800000000szzke70we6tj30zp4hz3147latb159u5mn1auju2n1rio45b0750063006300630031006300630075006340630063203100632063406300630063007520630063006300310075006300630063003100634063006300630063247500630063006302310063006300750063027504630031006300310263006300630063006300630063006300750263006300630031006300630063006300630",
    
    diamondSword: "0g0gc0000073029bi0v03e7p4v05nj6yn07x0b270b4n4zj0bb80sf0dkjhtr0k17x8f0sxsoov11udg5b19s0phb00000000000002220000000000002bb1000000000002b6b100000000002b6b100000000002b67100000000002b671000002200027671000000232027671000000002417471000000000244371000000000002321000000000008912210000000008a501121000000229500001100000023100000000000001110000000000000",
    goldenSword: "0g0gc00000000b4n4zj0gp1iin0k17x8f0sxsoov0zm5ddr11udg5b1p7anlr1sk94vz1smlrlr1y70anz1y711j300000000000005550000000000005bb2000000000005b9b200000000005b9b200000000005b9a200000000005b9a200000550005a9a200000057505a9a200000000582a8a20000000005887a20000000000057520000000000034255200000000036102252000000554100002200000057200000000000002220000000000000",
    ironSword: "0g0gc000000006oo3r30b4n4zj0ixwa9r0k17x8f0sxsoov0sywflr11udg5b1584m4f1gd8s1r1o60w731y711j300000000000003330000000000003bb1000000000003b9b100000000003b9b100000000003b9a100000000003b9a100000330003a9a100000036303a9a100000000381a8a10000000003886a10000000000036310000000000045133100000000047201131000000335200001100000036100000000000001110000000000000",
    stoneSword: "0g0gb000000008ww4xr0b4n4zj0k17x8f0k20av30oigd8f0sxsoov0xf6uwv11udg5b157yy9r1d0wphb000000000000044400000000000049a10000000000049a91000000000049a91000000000049a91000000000049a91000004400047a91000000454047a710000000047179710000000004775710000000000045410000000000036144100000000038201141000000446200001100000045100000000000001110000000000000",
    woodenSword: "0g0gb000000008wkrnj0b4n4zj0egz5z30ix9jpb0k17x8f0ohiayn0sxsoov0wa4ovz10qf2m711udg5b000000000000033300000000000038910000000000038981000000000038981000000000038981000000000038981000003300036981000000343036961000000003616861000000000366461000000000003431000000000005713310000000005a201131000000337200001100000034100000000000001110000000000000",
    
    floweringAzaleaLeaves: "0g0g800000000fmc7wf0mb5ukf0u3s7pb0v8d1j317dds731f5p9fj1ludc732012234220111023300114422033400310222200433676014324321044271701440441101226750000022101110044334210003444210233467500244431122417163232244211222565424324334033322420443004403330011232056522030122122026163211033433102565321123434311002213302224400100011332",
    azaleaLeaves: "0g0g500000000fmc7wf0mb5ukf0u3s7pb0v8d1j32012234220110023300114422033400310222211433441014324321044222101440440000220340000022000110044334210113444210233422001244431122410043232244211222214424324334033322420443004403330011232000322030122122023443210033433102444321123434311002213302224400100011332",
    
    pigSpawnEgg: function(n){
      var pix = spawnEgg
      var pix2 = spawnEggOverlay
      for (let i = 0; i < pix.length; i += 4) {
        var r = 255, g = 170, b = 170
        pix[i] *= r / 255
        pix[i+1] *= g / 255
        pix[i+2] *= b / 255
        setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}
      for (i = 0; i < pix2.length; i += 4) {
        if(pix2[i+3]){
          var r = 255, g = 100, b = 100
          pix2[i] *= r / 255
          pix2[i+1] *= g / 255
          pix2[i+2] *= b / 255
          setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
        }
      }
    },
    
    crackedDeepslateBricks: "0g0g806oo3r30a105j30c986pr0flelfj0hts9of0k25xxb0oigd8f0u30g736775777777764321766366665666642176663556333634417456533365534541736414545544134165314341141141213331332331233131221021000022101277637350537775676654643137666544452635417666566662556331562454665244562132462566313444316436525431233331333333332112221111222222",
    crackedDeepslateTiles: "0g0g60a105j30c986pr0flelfj0hts9of0k25xxb0oigd8f1000110001000110132055455530243121105444331332212010444341333321110012332022222000000110001010005545432102210221443432201211012134432210122210100110111101110000122104554535433202100433331332210111033332202211000011101100110023133321201203323132221101221322",
    deepslateRedstoneOre: "0g0gg0c988an0fl3bb30gpo9vj0l56h330ma8c1r0rusf0f0xfchz310pyi2n152bwu7152hjwf1idy29r1jhwfsv1vqcf0f1xx5on31y0rf271y2hgqn6544442255544244420022224544224255655331000220222453399915665554024b9bdea85655426645adfd7545bc75655447774422772453312256553302443ce9124659b9bec429c74445442efc72577424422002776655413316424224655419cbc9542bc4552227ef554202002266557720265445566654544046554455",
    deepslateEmeraldOre: "0g0gc004op3305rfklb05sdfr307xmd4v0c988an0eiutxb0gpo9vj0i0nv270ma8c1r0rusf0f0xfchz31o7fjsva988886699988688864466668944668694b2988444b264666820a6668920a99846aa945899aa9986aa86477399898889a9957b03586644689645703159864b286b2613aa9898620a620aaa8984466aa99aa86886477569aa99869aaa07b038a998664499010318996664b299853aa466aa9920a46aa8899aaa98aa848a998899",
    deepslateDiamondOre: "0g0gc05p9bsv07ztywv0c988an0ddyrjz0gpo9vj0ma8c1r0qrm7zz0rusf0f0rw77cv0wfmb5r0xfchz31n3h8n3a755554477755455542234445755445477a71553322490844575844908aa887524554448877a7754aa575b9577b96557a78b911065108245753886863386245559164433b9754445466255591006422475751554688335aa77547aaa533905a775433a779b9110674469087750188644aa7884424685577aaa7575525a775577",
    deepslateCopperOre: "0g0gd0c988an0fnfu2n0fnwqgv0gpo9vj0lacfsv0ma8c1r0oksv7j0rusf0f0xfchz30znkb9b1hdqvwf1q9usjj1uqaxa78755553377755355530033335750035370228300330ba8333578522357888775035529ba977877538859abc87730035787758883530990357530037871646a555302935875169ba8364469875532888375268853300855787788788a535335877533529bca333577332905292803024388775338877558888875755058775577",
    deepslateLapisOre: "0g0gd04hvenz04hvkzj04ihywv05mg64f06r1a7z08z3da70c988an0gpo9vj0izhb0f0ma8c1r0rusf0f0t0n08v0xfchz3ca999977aaa99799976766779a996797aa454396766713c779caa2c38caccca967997c7ccaaaaa97cc97742aaa51999aca718b83998bca79a28accccaacca79998b97792a433a6797ccc99a24883a267aca9299c18bc985caa300cca9ccaab8aa97cc0aa3889a18c77768b4a8b1c9cc7ccaa483c9cc99aaccca9acc97caa99aa",
    deepslateIronOre: "0g0ga0c988an0gpo9vj0ma8c1r0rusf0f0walse70xfchz311v06pr1bvjgfz1o4aozj1qczo5b5322221133322122210011112346642133676100015675111678522123355332015511166776332155236788987526735332557885510012321111555321012221267125346741121147788322785001323589511055225533215555212462533211675346788763167055332789755155642110135553353355322023332233",
    deepslateGoldOre: "0g0g90c988an0gpo9vj0ma8c1r0rusf0f0xfchz317e5b0f1sjgzy71y6dkvz1y70nb34322221233322122210054212322100133434205000105511232205653445652012215675334664144236778632344234332467652110012321114644321265421562154323214431167424322001301324433211055624433001441256687533055643534677443156787342156431144367410144422644434422024332243",
    deepslateCoalOre: "0g0g902881dr07ss4cf0b5464f0c988an0gpo9vj0k208hr0ma8c1r0rusf0f0xfchz38766664477766466643344333766446477877602233412444676612251087776302647710088776488776637886336678776333466212346764402137762586664602521767886464437128866464334767688644334302877433377643347877605200776520677447208876420834488788421478867788876766368776677",
    deepslateBricks: "0g0g70a105j30c986pr0flelfj0hts9of0k25xxb0oigd8f0u30g735666666666665530655555554555532065555445555543306345433554453430625323434433423054223233432332102222222222122120110011000111000166556650566666665545532065555455544554306555355554445520654543554233452054355455222333205325434322222220222222221111110000111111",
    deepslateTiles: "0g0g60a105j30c986pr0flelfj0hts9of0k25xxb0oigd8f1100110011000110332055455554343122105444333332212110544343333321111043332222222000001110011010005545444302212221443433221211112143433322122211100110111101110000122104554555433202110433333332210111033332222211000011101100110023333331222103323332222122110322",
    deepslateTop: "0g0g50gpo9vj0k20cfz0oigd8f0rusf0f0wb8hdr3211223333411013300111243440340212234011110344000012300223333402403101210012313340333222112123341000211221001122344301113334403223440321223340233442121112210112334112340132334412003334001324340122100011222110102343402343401212333440223440332221000122122211",
    polishedDeepslate: "0g0g70a105j30c986pr0flelfj0hts9of0k25xxb0oigd8f0u30g736666656665665651655543245555444165543314455555416344433322121120645544555554553162113334553113105332344334444431554345555535553164334445542554416211233321123310634555553245544063355554334554416123212122333111555554334555554164555411445555505110110001001000",
    chiseledDeepslate: "0g0g60a105j30c986pr0flelfj0hts9of0k25xxb0oigd8f0000000000000000234444434444433022344333444333201111123333211111100002333320000110000122221000014555420000245554122221000012222102344200001443201344311111244231014442111123413000443345544433100223443344432440223344432332143001121112212212100000000000000000",
    cobbledDeepslate: "0g0g60ehg8ov0gpoanz0k20bnj0oigd8f0sywflr0xfchz32204121455232433210321054212143200011004210103111254332320100101554322011000355243422102354255314321100452314221210010143220322055412323212011104331223312100033422012122135422332100001115220223121104551322021101231534220011010255143232013223015300211033554",
    deepslate: "0g0g50c988an0gpo9vj0ma8c1r0rusf0f0xfchz34322221133322122210011112322112133433220000110111232211123443332012211123334332144232202332322234332201122110012321111343321012221211124323211121100222322121001323212211001224433213444212112433211243332111233111002332101001144332110143223344432322024332233",
    tuff: "0g0g50l69w5b0pmkbgf0sz22nz10riv3z18kglj31222210321112311322211332002212323322231001112333433211102221211233321112332012022301123332103222102332332103310321333221121211321102221333321231101321134431211231233234420010143223133200011233332100122221233132102334321233210112344310122110112331000021332",
    
    amethystCluster: "0g0g800000000rtjrwf0xe3vnj12yid4v1cziigv1krz8jj1y4zv9b1y70tmn0000000000000000000000050000000000000056400000000000055635000000000055563350000000005677435000000000244523200000000023452310000066500235221005665665022422105665537551234205573553362122413353350532521231252350005222213132230000032121531230000002111351112000",
    largeAmethystBud: "0g0g800000000rtjrwf0xe3vnj12yid4v1cziigv1krz8jj1y4zv9b1y70tmn0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000066500000000000066745000000000005352100000007500335210570000575023413575000052631231362500003224313142230000032131531230000002111351112000",
    mediumAmethystBud: "0g0g600000000rtjrwf0xe3vnj12yid4v1krz8jj1y4zv9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000045400000000054004540450000004541242454000000423213232400000031131222130000002111231112000",
    smallAmethystBud: "0g0g500000000rtjrwf0xe3vnj12yid4v1cziigv0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000342000000000044213244000000034211212420000001311231131000",
    buddingAmethyst: "0g0g90iwt9fj0oh7qwv0pl658f0rtjrwf0xe3vnj12yid4v19mvain1jnedxb1y4zv9b3445434788653452455634545622451335313764362513433453187334560344457410337510012456853106810187337886641010147335456336705387435334634461307435634447310020156575447810087601765345630157453514433674187436783164344577332447147543456343474643462334544478542472",
    amethystShard: "0g0g800000000nd9b0f0u1rtvj12yid4v1cziigv1krz8jj1y4zv9b1y70tmn0000000000000000000000000000000000000000022222000000000026666100000000024667510000000026447531000000025645233100000024565323100000024457232100000023336423100000001234342100000000111234100000000011213100000000000113200000000000002200000000000000000000000000",
    amethystBlock: "0g0g70pl658f0rtjrwf0xe3vnj12yid4v19mvain1jnedxb1y4zv9b1232212566431230234312323400233113211342140142211231002112145322235201112312310234632122453220115664422123121113234112423223213112413453211213412223423100232453223453201234323123445431234543211456644211240142123350110222125321234121252125640112322256320250",
    
    snow: "0g0g31uv5wxr1vz4agv1y711j31222211212222111222222100222121222221000022022222210000222001222220001122001222211001212210122121221102212122201221200122122200022210221012210022100121000120012120022200120211121222210010012212222110011112222222110011121220012200011122220011112111122220011",
    powderSnow: "0g0g31tr1wcf1vz4agv1y711j31222211212222111222222102222121222221020022022222210200222001222220201122021222211201212210122121221102212122201221200122122200022210221012212022102121000120012120022202120211121222210010212212222110012112222222112011121220012200011122220211112112122220011",
    snowGrass: n => {
			const pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");

			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}

			const { random } = Math;

			for (let x = 0; x < 16; ++x) {
				const m = random() * 4 + 1;
				for (let y = 0; y < m; ++y) {
					const d = random() * 0.1 + 0.9;
					const r = 0xff * d;
					const g = 0xff * d;
					const b = 0xff * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
    snowball: "0g0g700000000xh2jnj1bxw73z1hian0f1lz1zi71sn3itb1y711j30000000000000000000000000000000000000022220000000000224554210000000245646542100000025656656410000025466656452100002466666654310000245656545341000023356565342100000243354333100000012333334210000000112432110000000000111100000000000000000000000000000000000000",
    powderSnowBucket: "0g0gb00000000ehg7wf0v74gsf0va9d6n1584m4f1asop331gfa3un1o60w731pb2r5r1uv5wxr1y711j30000003333000000000003aa8630000000013aa968631000001369868a83610000163a9a8636310000111388686111000017511116124100001777755628410000177a755422510000157a755622510000127a755422410000017775542410000001577544241000000015754241000000000111111000000000000000000000",
    
    bread: "0g0g800000000gp1iin0l5bw8v0ndjwn30rtonb312ybs3j18ivsov1gb6whr0000000000000000000000000444400000000004456654000000004577776510000004765577751000004777765765100004777777675410004565577775521000477765775541000457777675541000046777775541000004667775541000000356655541000000034555541000000000244421000000000002111000000000",

    dirtPathSide: n => {
			const pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");

			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}

			const { random } = Math;

			for (let x = 0; x < 16; ++x) {
				const m = random() * 3 + 2;
				for (let y = 0; y < m; ++y) {
					const d = random() * 0.25 + 0.65;
					const r = 223 * d;
					const g = 195 * d;
					const b = 117 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},//"0g0g01500000000ohcrun0u30g730wa4vzz0xdxkvz10rojr3156k0e71576fwf18j77jz19n5lvj19nb7cv19nmgov1arf7y71bv7xmn1bvdm9r1bvj8jj1bvuinz1czhm2n1czygvz1e3fzlr1e3llvj1e3lmnz1f737r31f7k0731f7pmgv1f7po1r1f7vabj1f80v0f1f80wlb1f86iv31gbnzzz1gbz8jj1hfs1dr1hg8wzj1ik78xr1ikcxkv1jo00zj1kryein1ksf9bz1lwozcv1p910cf000000000000000011n10h9bken9nuo812ehh8fv1rknylg14pijy2cax1t1t7s134zw4646md644q1s24614416646111441444mm444544mm4mm464644mm6644616644666446464146644414461441144444mm46464mm4m61mm1665464466m4626641641416466m4444444mm4644346641m14m66641m4141mm46446664m6645466446641",
    dirtPathTop: "0g0g410qksu7142wttr16bafpb1arku7z2211221111013201211131122201133011332111021311101001113210131121121122031021201112233213111022011111121103201103211210011311013221021212322112311203221100221111222321111112133112121221321112111321112213321112131113001120022112113221120112121112311211112111",
    farmlandMoist: "0g0g60egcmin0gokmwv0ncrrpb0neccn30u14jjz0u30g732210112222101244422021242221022424201222442102424410112442211144421301124421012422010122241011444412021252102124422102242120124144201222411012442420112442101244421101424211022422312144442101244210124442210322442012242420112224210242442012422411012242101442",
    farmland: "0g0g60neccn30ohcrun0u30g730xdxkvz156k0e71f737r34431334444313455544143454443144545413444554314545531334554433355543013345543134544131344453133555443143424314345544314454341345355413444533134554541334554313455543313545433144544034355554313455431345554431044554134454541334445431454554134544533134454313554",
    boneBlockSide: "0g0g41p9z5rz1qe36db1ri77r31smb8cf0023233333232110002323333333210001233333333321000123333333332100012233333333211001223333333321100122333333322110112333333332211011232333333221100123233333232110012323333323221001222333333322000122333333322200012233333332220000232333332222100023233333222110",
    boneBlockTop: "0g0g61hh701r1jpf0fz1ktj1tr1p9z4zj1qe8sn31smb7jz1234455555544310234443222334443134432011002234434432100111022344442000000111024453010001001112355311100000001035521100100000012552111000000101255301000100000025532111000000003544221111001012444432201000012344344322201102344313444322233444320134455555544321",
    boneBlockSW: "0g0g41p9z5rz1qe36db1ri77r31smb8cf0000000110000000001111111111110022222222222222223322233332223333223322223333332233333333333333333333333333333333333333333333333333333333333333333333333333333333223332233333333222223332223333332222222222222222122222111111111111000111111100010000000000000000",
    
    glowBerries: "0g0gg00000000b6twqn0cbetq70fnqupr0l50ohr0mbs9a70ohi9dr0rwhwxr0v5v20v14116nz1g9s8vz1hhhlof1mxzdof1ur2tj31vwr4sf1vy05bz0000000000000000000000007550000000000007412b0000000000046115b000000000686111b0000000068080117b00000aaaa080012b0000adeeda08022b000adffccd980237000adfdcae960037000addaaae9aa030000adcaadf9ed90000009ddcf9add900000009999addc9000000000000999000000000000000000000",
    
    hayBlockSide: "0g0g910ojlrz11uua67140vlz3157bv2719kysjj19la0an1arq9dr1gcfx1b1jorwfz1737183737673768373738373637671613671736131616664525552220255525363616363636161337673718163636166768373867683637676868376867686868686868686868686838686867686837183736366337176722554245422555251331111313361313161136161633131636163717373616181637183718683838",
    hayBlockTop: "0g0g511uu70f15766f31bviv3z1gca4fz1kskfsv3122102111222112032312220212113222242322243230200213041312024201101131202012132103021204320214022223413121432121231022112412201214233431212143322121100324321322120202121412222003022412032324122430212020113031020222411213231111212132234222313211021202121103",
    hayBlockSW: "0g0g910ojlrz11uua67140vlz3157bv2719kysjj19la0an1arq9dr1gcfx1b1jorwfz1311216666334131666328887776537731135336666326337611578888765777133143666331513187612688877657883111436633132333776356887886267713114666661321338763237887660367633323666633213686365788786656773111516663315163863357888666567731112636631126168863577887635668",
    wheatIcon: "0g0g700000000ne6ku70yio07312yyfi719nxqtb1kskvlr1p8pon30000000000300000000000001240300000000010243200030000001235342430000000235343430000000043635353310000004564353310000002464535442100000456645321100000216643211000000212142113200001254111100111000254511000000000034221000000000003112100000000000100100000000000",
    
    diamondShovel: "0g0ga0000073029bi0v03e7p4v0a6hfy70b4n4zj0bb80sf0dkjhtr0k17x8f0sxsoov11udg5b0000000000000000000000000000000000000000000221000000000000266310000000000265361000000000265356100000000007356100000000007946100000000007940100000000007840000000000007940000000000007840000000000077940000000000007940000000000000044000000000000000000000000000",
    goldenShovel: "0g0ga00000000b4n4zj0gp1iin0k17x8f0sxsoov0zm5ddr11udg5b1sk94vz1smlrlr1y70anz0000000000000000000000000000000000000000000552000000000000599720000000000598792000000000598789200000000003789200000000003619200000000003610200000000003410000000000003610000000000003410000000000033610000000000003610000000000000011000000000000000000000000000",
    woodenShovel: "0g0ga000000008wkrnj0b4n4zj0egz5z30k17x8f0sxsoov0sxyayn0wa4ovz10qf2m711udg5b0000000000000000000000000000000000000000000331000000000000388610000000000387681000000000387678100000000004678100000000004928100000000004920100000000004520000000000004920000000000004520000000000044920000000000004920000000000000022000000000000000000000000000",
    ironShovel: "0g0ga000000006oo3r30b4n4zj0ixwa9r0k17x8f0sxsoov11udg5b1hhcsn31o60w731y711j30000000000000000000000000000000000000000000331000000000000399710000000000398791000000000398789100000000004789100000000004629100000000004620100000000004520000000000004620000000000004520000000000044620000000000004620000000000000022000000000000000000000000000",
    stoneShovel: "0g0ga000000006oo3r30b4n4zj0k17x8f0k20av30sxsoov0yjgikf11udg5b11vskcf16c8mpr0000000000000000000000000000000000000000000441000000000000499610000000000498691000000000498689100000000003689100000000003729100000000003720100000000003520000000000003720000000000003520000000000033720000000000003720000000000000022000000000000000000000000000",
    
    diamondAxe: "0g0gb0000073029bi0v03e7p4v07x0b270a6hfy70b4n4zj0bb80sf0dkjhtr0k17x8f0sxsoov11udg5b0000000000000000000000000220000000000000277200000000000274620000000000274448900000000017643450000000000118434100000000008954410000000008a50110000000008950000000000008950000000000008a50000000000008950000000000008a50000000000000550000000000000000000000000000",
    goldenAxe: "0g0gb00000000b4n4zj0gp1iin0k17x8f0sxsoov0zm5ddr11udg5b1p7anlr1sk94vz1smlrlr1y70anz00000000000000000000000005500000000000005aa5000000000005a89500000000005a888340000000002a987810000000000223878200000000003418820000000003610220000000003410000000000003410000000000003610000000000003410000000000003610000000000000110000000000000000000000000000",
    ironAxe: "0g0gb000000006oo3r30b4n4zj0ixwa9r0k17x8f0sxsoov11udg5b1584m4f1hhcsn31o60w731y711j300000000000000000000000003300000000000003aa3000000000003a89300000000003a888450000000001a987820000000000114878100000000004528810000000004620110000000004520000000000004520000000000004620000000000004520000000000004620000000000000220000000000000000000000000000",
    stoneAxe: "0g0gb000000006oo3r30b4n4zj0k17x8f0k20av30sxsoov0u30g730yjgikf11udg5b11vskcf16c8mpr00000000000000000000000004400000000000004aa4000000000004a79400000000004a777350000000001a976720000000000113767100000000003527710000000003820110000000003520000000000003520000000000003820000000000003520000000000003820000000000000220000000000000000000000000000",
    woodenAxe: "0g0gb000000008wkrnj0b4n4zj0egz5z30k17x8f0ohiayn0sxsoov0sxyayn0wa4ovz10qf2m711udg5b0000000000000000000000000330000000000000399300000000000397830000000000397774600000000019875720000000000114757100000000004627710000000004a20110000000004620000000000004620000000000004a20000000000004620000000000004a20000000000000220000000000000000000000000000",
    
    strippedDarkOakLogSW: "0g0g70l5nabj0ohto8v0qpqfb30qpw1kv0ru01dr0sxyfpb0u22fi70000000000000000113331111113310331111314466363114466634311331116331146611144466644611144342253314633345666655116366633335666333611366632232343333663433444222666311366611113333411533333336643336665113344466646311116644611133311331113311333330000001110000000",
    strippedSpruceLogSW: "0g0g90qq1n270ru5nnj0u280zj0v66fb30xe36db0yi76670yi76yn0zmb6rj10q9kan1011100000111000313333333114774143134333441144335541114778854875841144775544748748778433311333448774444311435555114777744778874744744688876643331114771111441143144400066445411441111144877755548755845554111488487411144214774113333022332211111000100111010001",
    strippedJungleLogSW: "0g0g71576gov16baha717fehvj1bv2fb31e34tfj1f7eh331gbihof3002445600150030440525660245103046055535264513344604543526442344355453342551245406535254551233543453406454423503043350544625250302352552653425020254250462345202220443525224224020545342552524200250544042453412022035201145413433443205204141343420350600103030",
    strippedAcaciaLogSW: "0g0gq155rt33169q6m717dok5b17dokxr18hmxof18hmygv18hskqn19llb7j19llbzz19lqz271apjpj31apjqbj1appbsv1btnpbz1btnq4f1bttce71cxgglb1cxm2v31cxm3nj1e1kh6n1e1q3gf1f5iupr1f5ogzj1g9muin1hdl8u71ihjmdb3523008301a32220c05c88888iii88chjeddccii588eemeigggppmnkekkmppigggppmnkkkkbffffgllliilgggoonnaaakffkkkkgppnmkkkkaa5ikkkkggga88gga5llggggllggkkkapppnnggggglgalllppmmcppnngkkklllkkkigggnggggcgkkieaiimmiiie6663dm8aammiiiae66iim082099848889aaaa002222000d007220",
    strippedBirchLogSW: "0g0gn1czyku71e42lfj1e488hr1f86m0v1f8hwxr1gcamm71hgen7j1hgk9hb1ikin0f1ikinsv1ikoa2n1ikoav31iktxxb1jomnlr1jomoe71josanz1ksqozj1kswb9b1kt1ybj1lx0bun1lx5y4f1lx5ywv1lxbl6n0410024441124200444335faa62248884i8433403ii8333fi844mcc8888443iia9hmlljjjj488dffe99illlihiiha888hg9eddffff8mliifhkkhffii89mmlihiiif88ahhhh8mmliihf88hhhhiihhhh8ffhhhhff8ahhdddffffh833mii8ffiiif8fh4bmllchhfffff188843mif44i448811140447337378802112011214113443",
    strippedOakLogSW: "0g0gm142wttr142wum716az7y716b4tfj16b4u7z17f8u0v18j78cf19ngv7j1bvdn271bvj9bz1bvja4f1czhnnj1czn9xb1cznapr1e3lngf1e3lo8v1f7po1r1gbton31gbzawv1gbzbpb1hfxp8f1hg3can10044014111644116269f69622622666kb66ddd89gg9999gkfddd77bb99666ggggggccijkki99ikkgggggggikllkbb99kgikggddddddjkkkkkgikkllihggggikgggg99ggkkihgggkkkl99gdlkllkkkigk99ejjkkiggdddkkggg99ii99glklllkg66agfddddkkigggka66agkk77ak66bbaa22a667aaaaaabg226653363600b66b",
    strippedDarkOakLogTop: "0g0g90dcjwu70dd0u0v0egz8cf0fkrx8f0fl385b0govx1b0k0woov0l50pa70m9abcv2212221112212222277776768667777117003353555533822708877776777371263766666666756217576335533673622636606666366371265763655656756426576365363673642657636666566362263763303556756246576666666673624757767777787361175353333333337117776676686677724212221222221112",
    strippedSpruceLogTop: "0g0g90htb7r30ixf7jz0ixf8cf0ohnzlr0qpqein0v5v56n0xe36db0zmb6rj11udk3j2202220002202211177776768667777207334454555544822738877776777470264766666666756207576445544674620646636666466470065764644656756226576464464674622657646666566462264764434556756206576666666674620757767777787460075454444444447027776676686677722202220222220001",
    strippedJungleLogTop: "0g0g9156edbz1576gov17emdq717f8vlr17fehvj18jcw731aqst8f1f739bz1gbcw731135451111111553177776768667777337000020222200811708877776777075360766666666726437276002200670635606606666066075362760622626726316276062060670613627606666266063360760000226726316276666666670615727767777787063372020000000007337776676686677753353113533333111",
    strippedAcaciaLogTop: "0g0g812xe4u7141nta7169evpb169vtof18hham71btnnr31f5ofen1he22v33313331113313333366665657556666316002242444422733607766665666261352655555555645316465224422562531525505555255261154652544545645335465254252562533546525555455253352652202445645315465555555562531646656666676251164242222222226136665565575566633313331333331113",
    strippedBirchLogTop: "0g0g819nmj2719nxurj1bw5xj31czyku71f8hwxr1josanz1n14cfz1n1fmkf0333303003333330366665657556666306112242444422703617766665666263352655555555645336465224422562530525515555255263054652544545645305465254252562533546525555455253052652212445645035465555555562530646656666676253064242222222226306665565575566603330333333300333",
    strippedOakLogTop: "0g0g90yicsfz0yiifi710qqgov11uughr156v7cv17fehvj1bvja4f1f7pou71hfxp8f1331211122233312177776768667777117004454555544831708877776777471164766666666756127576445544674631646606666466473165764655656756316576465464674611657646666566462364764404556756216576666666674621757767777787461175454444444447117776676686677731131111111111111",
    strippedDarkOakLog: "0g0g70l5nabj0ohto8v0qpqfb30qpw1kv0ru01dr0sxyfpb0u22fi70316616636436330001163133633433001316313363363300361455342346130033342563236613001634266221641100161146634134610014113652413443101431463241334310114645333633611013361436363161003164133646311100316113663335130031616363615613001143466161161100134344313316310",
    strippedSpruceLog: "0g0g90qq1n270ru5nnj0u280zj0v66fb30xe36db0yi76670yi76yn0zmb6rj10q9kan0135745733448111043784543415841007484357311547101744735841451710141543386457142111184147644711200148511771474231034753148168543103377334816454210334734781045120033144476701410013414847470181311331174744415430131417747141573001354871414178301345848141148411",
    strippedJungleLog: "0g0g71576gov16baha717fehvj1bv2fb31e34tfj1f7eh331gbihof0044443322002440333455000042133300334355522441100112233225223443555412254445551014445142332244410266554652252100002225546655412066554444242200565633356550544200455432005533452542555545224553332554433354440040000055533505524204665644222022343444303000220033",
    strippedAcaciaLog: "0g0gq155rt33169q6m717dok5b17dokxr18hmxof18hmygv18hskqn19llb7j19llbzz19lqz271apjpj31apjqbj1appbsv1btnpbz1btnq4f1bttce71cxgglb1cxm2v31cxm3nj1e1kh6n1e1q3gf1f5iupr1f5ogzj1g9muin1hdl8u71ihjmdb0higgakgallkdma02ceifakgkllk3ia228mpfak8kllg6ia228epfnk8kakc66a73iemfnmaggkg6690ai8kbongglkgee801i8kkopglgggia8d085ekgpglgngii8038ikkggkggnnii4088inkgkkggpgmi8008cmnlkkggpgmm9208cpmikkgncgim923cdppikilnmiia0225dgplf5lpmkaa2250egglfa5ppke8803cjgglkaappkim00",
    strippedBirchLog: "0g0gn1czyku71e42lfj1e488hr1f86m0v1f8hwxr1gcamm71hgen7j1hgk9hb1ikin0f1ikinsv1ikoa2n1ikoav31iktxxb1jomnlr1jomoe71josanz1ksqozj1kswb9b1kt1ybj1lx0bun1lx5y4f1lx5ywv1lxbl6n08fif8fiiffff803083if8ihi8fif8842833d8iilhdif48444348allmhdif47322848hmmmhdffi3112i84i8m8hhfh47116i8jif9hih8h4344a38jhf8hiaicf314a08jifihh8ili724f4cjlfihhfmlm41253clldfahf3m341033mlldf8hh3b4000344mieh88h848421484h99kf8hhh81144i899gkifhff811044iaehhihff8112",
    strippedOakLog: "0g0gm142wttr142wum716az7y716b4tfj16b4u7z17f8u0v18j78cf19ngv7j1bvdn271bvj9bz1bvja4f1czhnnj1czn9xb1cznapr1e3lngf1e3lo8v1f7po1r1gbton31gbzawv1gbzbpb1hfxp8f1hg3can16ggk9kkkgkkgbgb169gk9kigiklgbb64696ibkggkdlg6a642969bjggkdli6ab62969kdghkdkkka016g9ildgilglkaa012g9kldhklggd7a6129bkkdikki9d7a3468bjidlglk9dk7619d7igdlgdkidk6306d7cggk9gjifg634fddcggk99j9gaa5496dggkig9e9a626066dggiggl9g662602bfgggkgk9g6aa216kkggkkgkkggka2",
    
    mushroomStem: "0g0g41hh72f31ilb3sv1ktdipr1lxn6db3333123333333333232123333333233232112233333333232221111232233221221001112212221110000000110110000033200110001221233332211012233233333333223333332211223332233332122222232222023300122112210001220001001100000001011100001111110022111210011111111333332101123332",
    mushroomBlockInside: "0g0g51arqm0v1gbze2n1ikd1j31ksffnj1n0ngu72213332213322232223302242322230343222333233313340432313332323223322133430322423123303244323032332223223332332313344223122322232303233443203233223323032234432032233223442223333233444333331032312213223123013243323222344333222340330322202332224222323344433134",
    brownMushroomBlock: "0g0g412yhon3156k1z3156po8v17expfj1201221212121222101121122202223212222012211021221122212222112222122232222221122010122222221312211122222212222022212223210212210221222220121222122222212022112122122210212121022212132111110121220222112212002212012111222220221221101222321021122210223122222211",
    redMushroomBlock: "0g0g61g74sn31hbefi71jjb7cv1knf75r1y340zj1y4isjj1000122110012221001101222110221101133222222221101135431222222210113453110022112222133110121000122201122221013311102222221013543012222211011345310221122222213311220111222222212211222113311122222221113543100122211001345312210011001013312222110011110011111221",
    brownMushroom: "0g0g800000000l5hou70ru5se70sxsu7z0v60ven142lp8f1e3rhmn1krncan0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000077750000000000077775400000000057755554000000003543344300000000000210000000000000062000000000000007600000000000000760000000",
    redMushroom: "0g0gb00000001592ghr16e9zb31amqebj1asd33z1ievy7z1ktd62n1n1r1fj1q63m671tqf5rz1xyq39b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002aaa000000000008aaa8800000000088aa881800000000158855330000000000064000000000000009600000000000000970000000",
    
    myceliumSide: "0g0gg0b4n6kf0fkxlvj0k17zlr0ohcrun0ohiewv0oigbnj0syfj7j0syqtbz0v6hwjj0wa4vzz0xdxkvz0xevlkv0zmmosf11uupz3156k0e71f737r3bb65778c565cc6878667bb8868788800576bd7768c718c467556766682178688b724c21670db7601166252065c60111440678b644174a21e4147b2c12372a12ee1ae8e13162aaa0aee3a633a1aaaff1eeeaf4afe3ffaee6aeaaeefae5eea3ea3a3eaeefaaaaaaaffaeaa9aeea3f3afeeea3fa3a3aaa3aaeeeafeea6eeeaaeea3",
    myceliumTop: "0g0g70oigbnj0syfj7j0syqtbz0v6hwjj0xevlkv0zmmosf11uupz34410223501055132311244331323335502146221352135312001211132423133421053012464212621130231051342441312341553241201212243536526201334213131512242011113122430121352312642421010321120342211031351231355331324213520113124324442333112003213642312012421201124353013",
    
    //the wheat texture is up there
    wheatSeeds: "0g0g70000000008qqkf0ca03r30izlwxr0t1pb0f0u35o8v1bwxp1b0000000000000000000000000000000000000000000000000000000000000000000001000001000000000400000010000000020000004400000010004300220000001060220000000004302000000000000220001006500000000004300220000000000220000000000000000000000000000000000000000000000000000000",
    wheatStage6: "0g0g700000730oj2fb30yio07312yyfi717g67sv1kskvlr1p8pon30000000000000000000000640000000000400045000000000440002122000000044000044202000000244005102500000012000400065400004015640005404010101455010503405541201405542432254120040242024011402105022103302140210602040030201420254504103320511024110420131040101101011010",
    wheatStage5: "0g0ga0000073006pqm70180hkv02d7ta704kclq705rqoe70k3pssf0oj2fb312yyfi717g67sv0000000000000000000000060000000000000066000000000000006600000000006000063300000006100008600000000051300900000000001300080001000000100999000511001130269907013000436070890113066076807709073306627790770807440230729070799206202020962079820820202080202802082022",
    wheatStage4: "0g0ga0000073006pqm70180hkv02d7ta704kclq705rqoe70k3pssf0oj2fb312yyfi717g67sv0000000000000000000000000000000000000000000000000000000000000000000000060000000000000061000000000000000513000000001000013000000000511001000000000013011300003000113024360005100003302068031310202440200902130220206022090234022077807709672420707080707807047070",
    wheatStage3: "0g0g80000073006pqm70180hkv02d7ta704kclq705rqoe70k3pssf0oj2fb30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000005110000000003000130000000005101130000000031312033000300000130204400013020034020060233002020402207023202202240222702022220",
    wheatStage2: "0g0g60000073006pqm70180hkv02d7ta704kclq705rqoe70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000051000000000300313100000000013001300000000033000340030000003202004000130202020220402020220",
    wheatStage1: "0g0g40000073006pqm70180hkv02d7ta70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000130000000030000330000000000130032000200000020200200020020",
    wheatStage0: "0g0g50000073006pqm70180hkv02d7ta704kclq70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000001300200000040000200040000",
    
    lightGrayGlazedTerracotta: "0g0gj05pey2n05pq87305pvv9b05q1ibj05qcsfz0iy7l6n0l6flkv0madzwf0nf4kqn0oj2z270oj8lbz0pnclxb0qrazgf0wbv1mn1440lj316c8mpr1hhighr1ktuhhb1n22inzfh8h8hc223cf7fh2hhchcghh4cff5fhhccdiddfgihff6fffhhiihhgffghf6755ccdeeghigfhhffffhhhiffegihchhffchhhhdhgdhhhdhhc3a9cddhhhchhgdh42a4323dgigehhfgh4c32222chihehgfhc8ccb021chgfghfghhhhfb020ddefhffdfffhfb22dghfiihhhhffha22chididc8fhhfh833chichchhffhfh8ccchh8h8hf",
    lightBlueGlazedTerracotta: "0g0ge090i6f3090tgjj090z4e70b5aakf0c98pof0di7awv0ehmdxb0fq9o8v0lact8f0nif6kf1jr5a0v1o7a0ov1rjarjz1x32nzz166788986497d282206678873478d078221469874388b022222138544687bddd12223546adda20177122344bdda27222871246adda22872289706cdda02297726787addb122788874477ddb2227888884367da12278988772436a12279878877ddba6587addda977202b44587addda97772d436787addda9272d2434777addda",
    magentaGlazedTerracotta: "0g0ga17bza4f1ao02kf1cvwvzz1igs7i71jkw83j1jl7gn31mxdw5b1p5ly4f1urpybj1vwavb33757479889553737373759822895373737578921129837373758810351299537359811353521983658812334443219858802335444331098810012244210110988998824328999993757581451953737373739134196373737373914309657373737391332953757373739112286375737373899998537373737474747463737",
    yellowGlazedTerracotta: "0g0ge16aid4v19morun1buws8v1cz0su71tnw8an1us083j1us5vy71usbldr1y5lf5r1y5r7r31y6e1hb1y6e3un1y6jshr1y6jvnj86aacca6a88a42116aa647aa6aaa4401aa6aaa6aa6668650a7aa8aa6adcc6855c6a889d6b46ac698a6aa9dd7d666aa69aa6add7dba767a786aa677db6aa74c66a6acaaa626aa4d218a6a67ac626add108a6c766ac6101011aa6aa764ac0027764586aa764c13663135686aabdd14422610668667210433461106988611161463",
    purpleGlazedTerracotta: "0g0ga0c987i70ddhv5r0og4dfj0pk2rr30qo16v30rrzl6n11sd7un12wh8fz154e1vj18hi9dr6790009906650006667909690656506697669690560066650987979061016854009969056116824409769691568824449799096910034576990050979904575700566509690428366661160999022756650016100006265656016634358565560566635422565565006854267765438406854562555477856853456678775445",
    orangeGlazedTerracotta: "0g0gg05obklb05pvv9b05q1ibj05qcsfz05qifi706uxq7z07zd0xr1o15j3z1q97wfz1up70u71wy79bz1wzlyin1wzrmdb1wzxa7z1x32nzz1y62z9baa1abdbb1ee6665aaa2aaccb37999855122bbdb228988785aab1122389aaa986bab188a98aa1a866bbd279a89aaaa861cbb2aae888aa8511cc2389fea888a6111128788feabba561e989aa88eeca0056e88aaaa8cfba0006688a1aa8baa61006697aaa8aa116610569898815641166bb6698410056411bb1a661100005666b11",
    whiteGlazedTerracotta: "0g0gd090z4e70fq9o8v0izsh6n0k6efpb0meb6rj1lxyi2n1uuoxdr1vyszjz1x2lofz1x32nzz1y5lf5r1y5r6671y5r7r3aaa99aaaa901079aabc99999992079c9ac99cab799059cc999999cbb9507c7a999c799997259a9c9c9bc99950079a997a9ca99003099c970a97b950412999501a999701102990013999502022790022100005999990279211059999990279950299caac90079975099c79995029970149aaac97012255438a99997011340036a",
    greenGlazedTerracotta: "0g0gh0iyik8v0k2mk1r0k2mku70l6w6wv0nf47b30pnsxrz0qrwxkv0rvpudb0rw6jnj0u4k7wf0v8o8hr0wcxukf0xh7gn3130u0an1jpqhof1ktuhhb1lxyi2n77gg22gg2ddabegd7dge34gg205ac8dggged3dge526bc58eged55fga865b965d2245fgd355aa665d04dfgd323ca52204ggggd2550a5239baggea32520623abaa20586322250ca942d2365aa5522aa43dd555ac53024ab25daacbb5329bab906daab9532baaa9315de856629aa421223egd8582aa435653dgdgedd2aa2ddddegd",
    brownGlazedTerracotta: "0g0gf05obklb05omtxb05oy41r0iy7l6n0qp3u9r0sxbunz0zluadb10psnwf12xv20v156edbz19morun1aqssfz1bv2fb31krc4jj1lvls736d6666a7d601d100d669bca7da00dd106666bba6ad602dd16966a6a68d6302dd6baa64b96da530116bb644ba6ad65300aabbabca68d8886467769aab96da5564dda8666996ad55466addda86668da4440066addda88ad3211003468addaae211dd2034845adee0341dd203844532144001dd006644013401000d104564004013",
    blackGlazedTerracotta: "0g0gj000007301440sf04gg2kf06oo3r307ss54v0a106bj0a1073z0b547pb0c987i70c988an0ddhv5r0ehlvr30flpwcf0gptwxr0ivuygv0nbitj311rk9of12voa9r167jev389ih87hh085000068hiig9hg080eige1iiig8775280i30g2hih675hhe60he3h25i67983hhe0ehhe387798763hhh1123ihi7i36260324hgi4gh6hi27hhii4gf44002ehh2i8fi4h4447785ei3hfhg4444452000h3hig44aacd2ehie14ee44bb4442h03i1hig4bb4aad0h30i1if44c4abbb3ehhf2h444c4bcbb50021he444b4cbcb",
    pinkGlazedTerracotta: "0g0g71e4v27z1f8z2tb1mxj5rz1o1yghr1uqmigv1vv1se71vwavb31016646322246326016632646666663206632366654654636632366564466566632366546456666442366644656544626646564466544562366646456666666223654656544456422364466544456666666456666666632444666544456632364446644566632366664466666432366136644633662366112364462236466011",
    limeGlazedTerracotta: "0g0gc0ol94ov0ppirjz0ymkc8v0zq7i0v10uh4vz11ywd8f1av67zz1tnw8an1us5vy71usbldr1y6e1hb1y6jvnj3a611111111008b3a8036666666607aa60013444646367b813111454446367b816311144453308a71634110773308a801634408aa7008a83164358b22a89a803166349a222aa80361633448b2288033616664408a800333606434008a80045330066088a8033663087798ab803456609abbba8803344309a3a879033666308b3",
    grayGlazedTerracotta: "0g0gd0ddhv5r0ehlvr30gptwxr0hu3klb0iy7l6n0k2blrz0majmyn0oj8lbz0qrazgf0rvf01r1584m4f16c8mpr17gcnb3411bc1770679441111ab7870068944111cb6411114885444bb64412444478544b143500340047778114661011000379717788cc42110433677877cbba1163111711479b1b415512a111147babc0001ab14711779bb0112c147941047876433a677774004785346c4744777007bbcacc143497401bb2034114477411cb2134114",
    cyanGlazedTerracotta: "0g0gj04jw93305o5wqn05obklb05oh7nj05omupr05pvv9b05q1ibj05qcsfz05qifi706ub5z306uxq7z0ddhv5r0ehlvr30flpwcf0gptwxr0iy7l6n1jpqhof1ktuhhb1lxyi2n225ffihiaff00780dc59ggiaff024768cc559gaff0224655662559ff0232232155ccd5f0dcd2222055ccb555cbc2320f77ccd065ecc420ffgi243dce56220ffagg444bcc6550ffaigf2dcbccde55fagiff4bcccccd659gigf02ccdedcc2559gf022cc032cc02559f222dd242cc30255522220ffgg6556cb44220ffghg7555dc2",
    blueGlazedTerracotta: "0g0g608wl14v08wqozj090z4e70c98pof0gq02yn0izsh6n3511301111103133531130111110311323310300000033110230452222540333053524333342531104543545453342310543545454453423543454245454434545435424542434531352345424535511110423542435431100114534535011333330142335330011113300545443330031130145452254353313010501004553",
    redGlazedTerracotta: "0g0ga11rk9of12voa9r167jev31ano6bj1cvqjnj1f3napr1jk905b1koiolb1krc4jj1lsxzb31011011124477344110101011149753441134443212997544114545441199977411977776107977911297777711102771267444572100117467433445964321247743664479543215677477347744462446779734775447743467743577445798434443469743498884454469674798878897777764778844788977765478844",
    lightGrayTerracotta: "0g0gd0zmmmf30zmmn7j10qfdof10qkzy710ql0qn10ql1j310qqn0f11uje9r11ujf2711up0jj11up1bz12yne2n12ynev3444444a94994333444aaa54446a94444414444449464497499444347444444444aa9903344aa4444a49444444449944a9964444844479994a444994994444499a963444446999aa494444444444466aa44444ac349aa4444444444449a99999444444444ab44444446696a444404449a4642344444994449444669a646443344",
    lightBlueTerracotta: "0g0ga0u2uynz0u2uzgf0u30lq70v6tc730v6tczj0v6yz9b0v6z01r0waxcsf0waxdkv0wb2z275111458527551115558886555585155152551115555555555554111755555555588551144188555585554555555555585555515841555754655155157555555565515155557778855551115155555588555118835588555115551555785557554555541587514555555556515401459855531541555552455555558555544155",
    magentaTerracotta: "0g0gi12xpq0v141iha7141o3jz141o4cf155gutb155mh33155mhvj155s3cv155s45b155s4xr155xqf3155xr7j169qhof169qigv169w3y7169w4qn17dov7j17dui9r622268fc2ee5222566ffd98578e8266283852225c8888a878e85222c866888558ecc812562ff8685e88858888888886ec888526c5268ec858652cc2cc86888888c82626668cecff888622262876688ff58822fh588ef886226862886ce888ec866667526fg525888888e8b52550258ee888426526888625c888888e888855268",
    yellowTerracotta: "0g0gf1cz0hrz1e2yw3j1f6x8u71f6x9mn1f6xaf31f72vwf1f72wov1f72xhb1f78iyn1gb1a7z1gb6whr1gb6xa71heznr31hf5a0v1hf5atb533336aa5aa3111355aa975355aa155361533133966668556a631139655566536aa9611333dd5563a69635566666665a9a6633493356aa939533993aa65666999a81333356aaaab696333333653366da55633dd266aa555335533566aa966aa633555333ec313566666a6a53330335aa6662153356695339666669a666633156",
    purpleTerracotta: "0g0gm0u1g3y70u1g4qn0v58v7j0v58vzz0v5ehhb0v5ei9r0w978qn0w9cv0f0w9cvsv0w9cwlb0w9cxdr0w9ii2n0w9iiv30xdb9bz0xdba4f0xdgvlr0xdgwe70xdgx6n0xdminz0yhf94v0yhf9xb0yhfapr855589gg5gg8222888ggga888bgg588581884248f8b88b87bg88225d888888878ggfb22685kk8888g8g88888888bb88gfgc8858e8588ggf8g885ff5fg88888ggggc284888cggggh8g88445858888bbkg88843kk78bgg888538885888gggbbgg888888858lj8588888bbgbg84880588ig8b86288588bf848f888bbggc8c886288",
    orangeTerracotta: "0g0gj169eu4f169euwv17dd7nj17dd8fz18h5ywv18hblz318hh88v18hh91b18hmuin18hmvb319l9zi719la0an19lflrz19lfmkf19ll81r19ll8u719ll9mn1apdzb31apjmdb533356fd3fd5222555dfd73556f6355351353335c66658666d65323a555655556ddc622233ff5565d66535555566665dc665535b5356dc637553cc3cd55556667d62333356dcddf565333333553366fd55533fi266fd565335533565df666cd533555533gh533656666d6953550355ed565425535566535c566666d666652256",
    whiteTerracotta: "0g0gf1ksfmrj1ksfnjz1ksl91b1ksl9tr1lwe0an1lwe1331lwjmkf1lwjncv1lwjo5b1lwp9mn1lwpaf31n0i0vz1n0nn5r1n0nny71n0t9fj711157d93c97000777ddd87779c9177173770007979779769975001b777777767cc9900451dd7777c79757777779977c9997717b51779c9597719919c77777999990707779cccdd797700171777799dd77701dd479cd777117771777cc999c9757777517dc71577779999a70750157ec7974075177997259777999c979754077",
    greenTerracotta: "0g0g90k2bcan0k2bd330k2gzcv0l69ptr0l69qm70l69ren0l6fcvz0l6fdof0madqf31111177717711111147777111677144111111111666616666764111441124441677661111177416176711444446666176771114541167761741166167414467777711111177777747411111141116677441117706677464114411461777667741114141178111646666727411401447742131141116641461662277727641146",
    brownTerracotta: "0g0g70k12dbz0l50qv30l50rnj0l56d4v0l56dxb0m8z56n0m94rgf2111244414410001214664111444011120111011444424334441001222242211464440011166224164421222224444264442112511244441411144144222244444401111244444624211111121114464122116614464231111211242464444421121111166101324444444111101124624210211224411142444446444411014",
    blackTerracotta: "0g0g608wf66708wf6yn0a0djpb0a0dkhr0a0j6rj0b4hkan3333334434432223334433333344233331332223434334323432223333333322344430223344333343432333333333344433333323334432433344344333334444423233334444434332233333334444233234423344333333333333444334433333323345322333344434223203234433322323333332243333344333322233",
    pinkTerracotta: "0g0gh1699fr31699gjj17d270f17d27sv17d7u2n18h0kjj18h0lbz18h67lr18h68e718hbtvj18hbunz19l4l4v19l4lxb19la7en19la8731ap8lq71ap8min744478ee4ee7222777eee87779ee377471773337e8a87a77ae77324b777777777eeea22564ff7777e7e77777777aa77eeea7747c7477eed7e774ee4ee77777eeeea273777aeeeee7e77334747777aafe77733ff58aee777437774787eeeaaee767777747gf737777899e9e73770477ee7975277477ad747e78899eea7a775278",
    limeTerracotta: "0g0gh0qram0v0qrg8an0qrg9330rv8zjz0rv90cf0rveltr0rvemm70sz7d330szczcv0szd05b0szd0xr0szimf30szin7j0u3bdof0u3begv0u3gzy70u3h0qn655569g95fb5003566ggea6559bb36656265303596666b989b95005d666666559fb9903345gg9695f99659966699996f9b96556d5569b9959655995bf66669999990636669fbfgg696633565656666gc59633gg369fg966536965966ff999b9646665556gd535669699b6c53551559bf6667065566996559666669f969953366",
    grayTerracotta: "0g0g60egz94v0fkxmnz0fkxngf0fl39q70gow0zj0gp1n9b2111223313311111213542111233111120111111222223112321111222222211253220111155222152221222222222252322112411223321211122133222222223311111223333522211111121112253122115512253211111211222352223321121111154111122222323111101123522211211222211122222225222211112",
    cyanTerracotta: "0g0gj0madz3z0madzwf0majldr0majm670neccn30nehywv0nehzpb0nei0hr0nenlz30nenmrj0nennjz0oigd8f0oige0v0oilzi70oim0an0oim1330oirmkf0oirncv0pmkdtr666669ee6ee6006666eeea6668ee666673666366e9997ed8ee96316b666866669eeee06666ee6696e9e76666669ee96eee97666c666deee6e666ee6ee66669eeee91666669eeeef6e6666666666699ge66766ei59eee686666666697eeeeeee666666666hi666869999e9g66662666ge6974066667ee666e79999ee999966669",
    blueTerracotta: "0g0g90ixfjen0k1dwxr0k1dxq70k1jj7j0k1jjzz0l5cagv0l5cb9b0l5hxj30l5njsv1111147717711111117774111374111121111111744424334741111511131111477741111177114174421111114444177442111611137741411177177111144447411111147777714111111111114477112117714477131111111142774447711111111177111314444744111101118714211111124411172444447444411114",
    redTerracotta: "0g0ge11snny711snoqn12wm1hb12wm29r12wrojj12wrpbz140kf0f140q22n140q2v3140q3nj140vp4v154oge7154u2nz154u3gf433338aa4aa3003344acb94347aa34434143313385554a778a731137444444437ca8803333cc7473c78437744478874c8a84333b3347aa738433883aa44447888aa1333348aaaad484333333443355ca47433cc258ca744334733754ac888aa433444333db333447577a4a43330337ac4446043344874338455448c848733345",
    terracotta: "0g0g5155rvgf155xhq7169vw1r16a1ibj17du8sf2111122204211112243333411333022120110111212243422224402334111112333111111143333411222111202211112223312333334210112111110001122243303444433323332122111212211132223333310133322204421422334423302110001122111114233334411101243322411111243341121111033422211122",
    
    ancientDebrisTop: "0g0g70dcebcv0hsdgjj0k0wr270pkzxmn0rtj9q70yiczjz157i0an1156665421013635056100014566653456545622110016643600126654242216023211100154050603254046521506060341306115050615125060501606261221606242550605215161510011130621605215664532262060400112111005206033345665643353565110000112246013556665441016131463454425656515",
    ancientDebrisSide: "0g0g70dcebcv0hsdgjj0k0wr270pkzxmn0rtj9q70yiczjz157i0an3442122024434134443456512344324333365445433332332344333331346654233322310155433313025666103333232105444565223232210444444402222221143434436666555013334435444444104563332344444310245664224434441113334512344433665233330233435645652332022333444443223025666244",
    
    yellowStainedGlassPaneSide: "0g0g500000001n1vyee1o5zyzq1pa3ysm1ribyee0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    yellowStainedGlass: "0g0g31ribyau1ribycb1ribycj2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    whiteStainedGlassPaneSide: "0g0g500000001tqkz521vyt0bq1x2x0x21y711ie0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    whiteStainedGlass: "0g0g31y711eu1y711gb1y711gj2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    redStainedGlassPaneSide: "0g0g5000000012w57fq14098121547lk61685z3a0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    redStainedGlass: "0g0g31685z0g1685z1o1685z332222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    purpleStainedGlassPaneSide: "0g0g500000000w8wgrq0xd0hd20ygyvom0ygywh20000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    purpleStainedGlass: "0g0g30ygywdi0ygywez0ygywf72222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    pinkStainedGlassPaneSide: "0g0g500000001qa0tt21re4uee1si8uzq1uq5mue0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    pinkStainedGlass: "0g0g31uq5mqu1uq5msb1uq5msj2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    orangeStainedGlassPaneSide: "0g0g500000001jm9zae1kqdzvq1luhzom1mygd7q0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    orangeStainedGlass: "0g0g31o2eqna1o2eqor1o2eqoz2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    magentaStainedGlassPaneSide: "0g0g5000000019ku12e1aoy1nq1bswfza1cx0gkm0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    magentaStainedGlass: "0g0g31cx0h9i1cx0haz1cx0hb72222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    limeStainedGlassPaneSide: "0g0g500000000we13ae0xi53vq0ym93om0ymepye0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    limeStainedGlass: "0g0g30ymkc4m0ymkc630ymkc6b2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    lightGrayStainedGlassPaneSide: "0g0g5000000012zwkx21440lie1584m3q16c8mp20000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    lightGrayStainedGlass: "0g0g316c8mli16c8mmz16c8mn72222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    lightBlueStainedGlassPaneSide: "0g0g500000000pogeee0qskezq0qsq21y0rwu2na0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    lightBlueStainedGlass: "0g0g30rwu3c60rwu3dn0rwu3dv2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    greenStainedGlassPaneSide: "0g0g500000000pnhtye0qrlujq0qrrgti0rvpucm0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    greenStainedGlass: "0g0g30rvpu920rvpuaj0rvpuar2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    grayStainedGlassPaneSide: "0g0g400000000ixwa920k20aue0l64bfq0000000320000000000000031000000000000003200000000000000220000000000000023000000000000003100000000000000210000000000000021000000000000003100000000000000210000000000000032000000000000003100000000000000320000000000000032000000000000003100000000000000320000000",
    grayStainedGlass: "0g0g30l64bc60l64bdn0l64bdv2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    cyanStainedGlassPaneSide: "0g0g500000000izs3qe0k3w4bq0k41rdy0l805pi0000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    cyanStainedGlass: "0g0g30l805ly0l805nf0l805nn2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    brownStainedGlassPaneSide: "0g0g400000000plmep20qpqfae0rtuf3a0000000320000000000000031000000000000003200000000000000220000000000000023000000000000003100000000000000210000000000000021000000000000003100000000000000210000000000000032000000000000003100000000000000320000000000000032000000000000003100000000000000320000000",
    brownStainedGlass: "0g0g30rtuezq0rtuf170rtuf1f2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    blueStainedGlassPaneSide: "0g0g500000000ca6k120deakme0dealeu0deg8h20000000420000000000000041000000000000004200000000000000220000000000000024000000000000004100000000000000210000000000000021000000000000004100000000000000210000000000000042000000000000004100000000000000420000000000000042000000000000004100000000000000430000000",
    blueStainedGlass: "0g0g30deg8di0deg8el0deg8fo2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    blackStainedGlassPaneSide: "0g0g3000000005kk35206oo3qe0000000220000000000000021000000000000002200000000000000220000000000000022000000000000002100000000000000210000000000000021000000000000002100000000000000210000000000000022000000000000002100000000000000220000000000000022000000000000002100000000000000220000000",
    blackStainedGlass: "0g0g306oo3mu06oo3ob06oo3oj2222222222222222200000000000000220001000000000022001000000000002201000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000002200000000000000220000000000000022000000000000102200000000000100220000000000000022222222222222222",
    
    lightGrayStainedGlassPaneTop: "0g0g5000000012zwkx21440lie1584m3q16c8mp20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    lightBlueStainedGlassPaneTop: "0g0g500000000pogeee0qskezq0qsq21y0rwu2na0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    magentaStainedGlassPaneTop: "0g0g5000000019ku12e1aoy1nq1bswfza1cx0gkm0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    yellowStainedGlassPaneTop: "0g0g500000001n1vyee1o5zyzq1pa3ysm1ribyee0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    purpleStainedGlassPaneTop: "0g0g500000000w8wgrq0xd0hd20ygyvom0ygywh20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    orangeStainedGlassPaneTop: "0g0g500000001jm9zae1kqdzvq1luhzom1mygd7q0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    whiteStainedGlassPaneTop: "0g0g500000001tqkz521vyt0bq1x2x0x21y711ie0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    greenStainedGlassPaneTop: "0g0g500000000pnhtye0qrlujq0qrrgti0rvpucm0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    brownStainedGlassPaneTop: "0g0g400000000plmep20qpqfae0rtuf3a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000333333232232233321221211111322120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    blackStainedGlassPaneTop: "0g0g3000000005kk35206oo3qe0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000222222222222222221221211111222120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    pinkStainedGlassPaneTop: "0g0g500000001qa0tt21re4uee1si8uzq1uq5mue0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    limeStainedGlassPaneTop: "0g0g500000000we13ae0xi53vq0ym93om0ymepye0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    grayStainedGlassPaneTop: "0g0g400000000ixwa920k20aue0l64bfq0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000333333232232233321221211111322120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    cyanStainedGlassPaneTop: "0g0g500000000izs3qe0k3w4bq0k41rdy0l805pi0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    blueStainedGlassPaneTop: "0g0g500000000ca6k120deakme0dealeu0deg8h20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    redStainedGlassPaneTop: "0g0g5000000012w57fq14098121547lk61685z3a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444444242242244431221211111422120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    
    cobweb: "0g0g400000001ils45b1riil1b1y711j31000000030000001030000123210003000213100300303000002000310002000000130310202030000100203002000200020103203020010122323332000300101003002332212310010012301003002003002030030302000020302013300100001201210002100003003200012320003000012210000301000003000000001",
    
    strippedCrimsonStemSW: "0g0g70xcdhbz0ygn4zj0zkr4sf0zkr6db11snxfj154opvj18gv4lb4440044044410124101241210012244352114442244232345445533233334444445644555553245543333445566522225455444444445555554555665544445544442244555544455562244656655554522455555444445544422552246566654112444444555444521124553325112222002113222222240011100101442102",
    strippedWarpedStemSW: "0g0g70cco7pb0dgs9vj0dgxxq70el7jsv0fpbl6n0gtwiyn0j1hzwf4440044044410124101241210012244362114442244232346446633233334444446544666663246643333446655622226466444444446666664666556644446644442244666644466652244565566664622466666444446644422662245655564112444444666444621124663326112222002113222222240011100101442102",
    strippedWarpedStem: "0g0g70cco7pb0dgs9vj0dgxxq70el7jsv0fpbl6n0gtwiyn0j1hzwf4344626664664242243462664665422014244264464541210234226446456122122336446646662441436544654562244043654665444321402366466662432001226645456246314243644544664610414344462466441004464346226242210216536642422101411463644524110140244346462412204166446646644620",
    strippedWarpedStemTop: "0g0g907uz2f30b7xmv30cb3t330dgxxq70el7jsv0elit4v0fodrlr0fouosf0fpbl6n3883433344488834377776765667777337002212111122583705577776777273362766666666716347176221122672683626606666266278361762611616716836176261262672633617626666166264862762202116716436176666666672643717767777757263371212222222227337776676656677783383333333333333",
    strippedCrimsonStem: "0g0g70xcdhbz0ygn4zj0zkr4sf0zkr6db11snxfj154opvj18gv4lb4344525554554242243452554556422014244254454641210234225445465122122335445545552441435644564652244043564556444321402355455552432001225546465245314243544644554510414344452455441004454345225242210215635542422101411453544624110140244345452412204155445545544520",
    strippedCrimsonStemTop: "0g0g80k0lmgv0pkufb30swv7r30ygss1r0zkr4sf10ov66711snxfj154opvj4664744477766647455553537335555445001121222211764507755553555154431533333333523475253112211351364313303333133156432531322323523643253132131351344325313333233137631531101223523743253333333351374525535555575134452121111111115445553353373355564464444444444444",
    
    copperBlock: "0g0g81416xof169eyv319lldkv1cxrri71hdwjr31jma77j1myayv31qahfy77776766777776542755445567666443175735567666473317431567656443130745566655442234075566655442124307567655442124330767655442124435077655432124435507655433224445561755433234445567175433334435567617473234435567350733134335566314072134335566654416121101022211011",
    
    crackedPolishedBlackstoneBricks: "0g0g605k8ttr08wf9bz0a0uhof0dd6ltr0gpioe70l5yqrj3550554554554430343135443213334034551123223141404143534443300130022333424204433022332223312321202112012321121110110011000010100131303320134255453241322024244543234513200445443344341330553441443023410045431540202223204433031321011110211101110001100000101100",
    crackedStoneBricks: "0g0g70oigd8f0qqoef30sz21vj0xf6vpb0yjgikf11vskcf17g711b1466366646665550244414553545454064113445424414403156044444111330643451343431432053333342543510303222232223232010110011000111111166615310450566664452442053134545554514303135541444440101645441444442655064445134332544305343503322323340322320021111110000111111",
    
    diamondHoe: "0g0ga0000073029bi0v03e7p4v0a6hfy70b4n4zj0bb80sf0dkjhtr0k17x8f0sxsoov11udg5b0000000000000000000000022200000000000026552000000000000113527800000000000133940000000000007531000000000007841000000000007940000000000007840000000000007940000000000007840000000000007940000000000007840000000000007940000000000000440000000000000000000000000000",
    goldenHoe: "0g0ga00000730b4n4zj0gp1iin0k17x8f0sxsoov0zm5ddr11udg5b1sk94vz1smlrlr1y70anz0000000000000000000000055500000000000059885000000000000227853400000000000277610000000000003872000000000003422000000000003610000000000003410000000000003610000000000003410000000000003610000000000003410000000000003610000000000000110000000000000000000000000000",
    ironHoe: "0g0g9000000006oo3r30ixwa9r0k17x8f0sxsoov11udg5b1hhcsn31o60w731y711j30000000000000000000000022200000000000028772000000000000116723400000000000166510000000000003761000000000003411000000000003510000000000003410000000000003510000000000003410000000000003510000000000003410000000000003510000000000000110000000000000000000000000000",
    stoneHoe: "0g0g9000007306oo3r30k17x8f0k20av30sxsoov0yjgikf11udg5b11vskcf16c8mpr0000000000000000000000033300000000000038773000000000000115732400000000000155610000000000002751000000000002411000000000002610000000000002410000000000002610000000000002410000000000002610000000000002410000000000002610000000000000110000000000000000000000000000",
    woodenHoe: "0g0g8000007308wkrnj0egz5z30k17x8f0sxsoov0sxyayn0wa4ovz11udg5b0000000000000000000000022200000000000027662000000000000115623400000000000155710000000000003651000000000003411000000000003710000000000003410000000000003710000000000003410000000000003710000000000003410000000000003710000000000000110000000000000000000000000000",
    
    podzolSide: function(n){
      var overlay = getPixels("0g0g01200000000htb7r30iwyby70iwycqn0ix3y7z0ix3z0f0ixkt1b0k0wq9r0k1dkan0l56ccf0l5bym70l5hkvz0l6f85b0m9ac5b0m9fyf30madlof0nd33en0nd8pof0ndeby70nehlhb0oh737j0ohcrun0ohibr30plb30f0plrxtr0qpf2tb0qpqbcv0rtdgcf0rtj2m70sxhg5b0sxn2f30u1lfy70v5e77j0w9i70f0yhvsvz11tqy9r142fy7z1btytxb95r2ts272xx11qj1a10iypg9g799xaecb8iuum59k3zvaq1bf2hd0m4r0r0uaqb80w0006o0d3301000wn0000000l0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
      var pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530")
      
			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}

			for (let i = 0; i < overlay.length; i += 4) {
        if(overlay[i+3]){
				  setPixel(n, i >> 2 & 15, i >> 6, overlay[i], overlay[i + 1], overlay[i + 2], overlay[i + 3]);
        }
			}
    },//"0g0g0170htb7r30iwyby70iwycqn0ix3y7z0ix3z0f0ixkt1b0k0wq9r0k1dkan0l56ccf0l5bym70l5hkvz0l6f85b0m9ac5b0m9fyf30madlof0nd33en0nd8pof0ndeby70nehlhb0oh737j0ohcrun0ohibr30plb30f0plrxtr0qpf2tb0qpqbcv0rtdgcf0rtj2m70sxhg5b0sxn2f30u1lfy70u30g730v5e77j0w9i70f0wa4vzz0xdxkvz0yhvsvz10rojr311tqy9r142fy7z156k0e71btytxb1f737r384q1sr161xx15pi0913h10of8f688x9dba7httl48j212u9p0ae1gc16l3qzq14t9pa714w14z145n14c22k13vzwmzzk1414z14kkkzzkzzz1616zzz11zz1616z1616z14z14zz16161414zz14k1414zz141414zz14z14zkz1414zzzkzz14kzzkkzzzzz1616z14z14z1616z1614k1616k141411z14zz141416z14v1414zk14zkzk14z141416zzzzzzz1616z14zzyz1414zk16kz16141414zk16zkzk1616z14zz141414z161414z11z1414zz1414zk",
    podzolTop: "0g0g60k12br30m9fxmn0ma2d4v0sxhfcv11twkjj1btyt4v3112111003310301111412001310301313133210311221511133231334003140034110135313100304100131433300133013332233013111113312113100111113013113001103333030303113042213443320133131121113410001331201231100003543121101100011421041431115400231013351004100112113100113",
    
    rawIronBlock: "0g0g70ru02670yicu0v12yyk8v1bvjgfz1o4aozj1sl7pbz1y5rt332114332345433210532222123432246544312102221235531201134530113342210356544201443310234543212454430112433220344332343233211033321245443221012200013453311254534201223322156543331110012235443232214200123443322144342101133323655413234432122454322215544111343331",
    rawGoldBlock: "0g0g61bua2gv1jn7lrz1tnqoe71vwwidb1x29fjz1y6pa0v4410012421123322542102542201232454321555321001453221355443210003321023343110552111001133110354222145301310044332145533010021223113431100135212100013110135532100010110112443321023310123124321013343113321221431145220321012553331321100011554431001100110234442",
    rawCopperBlock: "0g0gh0fnwqgv0l6l33z0lacfsv0oksv7j0v6nda70xglczj0yizfun10phgxr16brif317dizgf17eb2tb1aqn9bz1cxrri71f5zsov1myayv31siju2n1wzs3r399d9d9db5847ef47799997fgb47dggfcc41477effb7cedcd9446547ded979cd94dgf35979cd979999efe6497defe9777dd997977efgba549799777dd9dba558474177dffe9456449c7149fgff997cc14d9419dfed9794235c974774a97940306999de95541de404c14dfgf41119edd971deffe71347de4104edfed7025477100",
    barrier: "0g0g400000001cu0jjz1g5vo5b1q5h1xb0000000000000000000233333333200000333333333331000233200000033310033200000033231003300000033203100330000033200310033000033200031003300033200003100330033200000310033033200000031003333200000033100233200000033310001333333333310000011111111110000000000000000000",
    
    netheriteSword: "0g0ge000000005k38cf08w9kov0c8r9j30dcva4f0flk8hr0k0rb3z0l5hr7j0m9rgfz0pm95a70qoyby70v5eebj0v6nlz310r7oxr00000000000006660000000000006dd2000000000006dcd200000000006d8d200000000006c8c2000000000069892000006600068472000000696068472000000006c674720000000006cc472000000000006982000000000003a27420000000003b202242000000665200002200000064200000000000001220000000000000",
    netheriteShovel: "0g0gc000000008w9kov0c8r9j30flk8hr0hts9of0k0rb3z0l5hr7j0pm95a70qoyby70v5eebj0v6nlz310r7oxr00000000000000000000000000000000000000000005550000000000005bbb100000000005b77a10000000005a767a10000000000267a10000000000291a100000000002910100000000002810000000000002310000000000002310000000000022410000000000002910000000000000011000000000000000000000000000",
    netheritePickaxe: "0g0gc000000008w9kov0c8r9j30flk8hr0hts9of0k0rb3z0l5hr7j0pm95a70qoyby70v5eebj0v6nlz310r7oxr000000000000000000000000000000000000005555500000000005bbba7552000000005111679100000000000026710000000000028167100000000029101a100000000281001b100000002910001b100000023100001b1000002410000001000002310000000000002910000000000000110000000000000000000000000000",
    netheriteHoe: "0g0gd000000006oigov0c8r9j30dcva4f0flk8hr0hts9of0k0rabj0l5hr7j0pm95a70qoyby70v5eebj0v6nlz310r7oxr000000000000000000000006660000000000006ccc600000000000011bc3290000000000018ba10000000000002871000000000002911000000000002a10000000000002910000000000002a10000000000002510000000000002410000000000002510000000000002a10000000000000110000000000000000000000000000",
    netheriteAxe: "0g0gd000000008w9kov0c8r9j30dcva4f0flk8hr0hts9of0k0rb3z0l5hr7j0pm95a70qoyby70v5eebj0v6nlz310r7oxr00000000000000000000000006600000000000006cc6000000000006c77600000000006b777890000000001b778710000000000118737100000000002917710000000002a10110000000002910000000000002510000000000002410000000000002510000000000002a10000000000000110000000000000000000000000000",
    netheriteScrap: "0g0g800000000a07wn30hsdgjj0k0r3zz0pkzxmn0rtj9q70yiczjz157i0an0000000000000000000000000220000000000002277200000000022775462000000226655445620000256555555553100144554455531100001245445311000000011453113310000024311134543100024444445553100000255445553100000002455531100000000014311000000000000110000000000000000000000000",
    netheriteIngot: "0g0gb000000004gg2kf0a0oven0dd0x6n0flk8hr0gp7bwf0k1uolb0l5ne9r0l5yp6n0oiaqyn0v74gsf000000000000000000000000000000000000000000220000000000022277300000002226688773000222668999988630297787889999aa6327a998887aaa6341255a99aaa65335412444aa6533334441254464333354511003546533551110000035453111000000000331100000000000000000000000000000000000000000",
    
    itemFrameWood: "0g0g717znmrj19xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm75456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    itemFrame: "0g0gb0a0uigv0b4yi9r0dd6jgf0eh4wzj0ehak1r0v58nb30xdb0n30zlddz3155avwf19lfo5b1btnnr31224444442222220255555555665565227666675588778724678877777766762456567899867677246777999aaa7765247878aa99998777447779999999977644767a99aaa9a78742566899999997654267779aaaaa7776426767789998767642686665666658874267886655876665225555775775677621223222244444421",
    stonecutterTop: "0g0ga0ma8c1r0pmkdtr0sxn0u70sywflr0wb8hdr0xe33zz0yjgikf0zmgt1b12zwkxr156pipr9954888888884599972346666663327952234443444642254344686688664334866444646888846888666666644343488668884884446668843111111111136888300000000003688686668886688888864644334646644886666886666688684334686446633434522346644466422597246666666632799954888888884599",
    stonecutterSide: "0g0g800000000l50q2n0oh74sf0rtdhxb0sywflr0wb8hdr0yjgikf12zwkxr0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000321454556655532123267667776662321331223332321332123131122212132321344444444442133234676556654313321556677776512213277766666671322316665567766231",
    stonecutterSaw: "0g0g700000730v74gsf0znkj5r1asop331o60w731smgykf1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046366300000000436446466400000464446456663000034446456664600046456456664464006446443464464300346442112464460",
    stonecutterBottom: "0g0g50ma8c1r0u30g730wb8hdr0znkj5r11vmy2n0000000000000000023334433332221003322234334443300444334444444440011233334443322003333344444433400443444333321230044433222333444002234444443333400334444444444440034443322123333001223344444444300433334433443220044444444334333004322333322212100000000000000000",
    brewingStandBase: "0g0g60syfif30v6njlr0wax79b0znew3j12zfnr317fq3270000000000011100001232100111100001342132221222000140000422122210015100242122220101350253123443110123553213510421001122112500023010221121252001201023553123521310103521431235420110520004211221111040001422211211002302432221220100012321011110000011100000000000",
    brewingStand: "0g0gp000000007ss4cf0ddc7b30gpo9330l64bgf0oigd8f0pkompr0qqoef30zkwjy712uqfwf141701r154d2bj1aori7z1auvoqn1cuydxb1g95xbz1jlhv5r1ksfocf1lunlz31n0hkan1n0n2m71n360vz1o5j6kf1p3k0731y711j3000300000000300000034000000430000002474mj4742000003122377322130000260423324062000008052mm25080000070072mm270a0000f5c072mj270a0000hbh072km27050000oel072ik2707000lndeo72ki2700000dnndo52ik2500000d9e9l42gi24000000ddd000ig00000000000000gi00000000000000gg0000000",
    cakeTop: "0g0g800000001cv9r7j1lqwqnz1sff4sf1upod1b1vybwu71y6plvj1y711j30000000000000000055667777776655005677777777276500677435566777760067732677767776007756777777177700775776226776770072677243277677007767723216757700777676216765170077776556776577006742777777567700673156776477760056777556777765005566777777766500000000000000000",
    cakeSide: "0g0ga00000000ygsgzj12wx98f19kyqyn1f5d24f1ihjgu71qdm8e71vybwu71y6plvj1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007899999999998700789999999999870077899988999877006723873387237600134434554413310012455555355421001342554555443100112222222222110",
    cakeBottom: "0g0g500000000swuzun0ygsgzj12wx98f19kyqyn0000000000000000022334332333322002333333333343200333221233323230034232222122233003322122222213300322222322322340033212222221233003422221222233300333222222323320023331222221233003322223212223400333222223323330023233433333332002233333234332200000000000000000",
    cartographyTableTop: "0g0gr0039zwf004239b0b4hji70c98wsf0dcjwu70ehh4an0fkmbr30fkrx8f0govx1b0gppa7z0iwyb5r0k0r37j0l50pa70nfqnlr0oh1g5b0sywflr0t0lwqn0v7fojj0ylbjlr10qqebj17gcnb31asubcv1g7ai2n1gc4xz31ilgt8f1x2a7zz1y70z5raaccceeeceecccc7cca778acccaacc88caoolkcaaaennnj772obmh22ennpqpn2c7lm6ke7npqqmqjacafkhf87npnqqpjcccacccc7nqqqqqjc22424444nqnqpqj4a88aaaeenqpqjpj7cccccca8npppppj7444244ecnpppnje851093424ejjje42231gd92c7eea7accc59did2a78cccc88a999104c8eecccccc0099147774442422",
    cartographyTableSide3: "0g0g80b4hji70dcjwu70fkrx8f0govx1b0iwyb5r0l50pa70oh1g5b0u1fugv6777677767776777054305530556255405550653145315450555065405462545153506541536252515351654154615362545064615360546232215361222045626361535253514551656254525451456155425452545064615522535145516450554154514540655153515352354065505350535255306350111011101110111",
    cartographyTableSide2: "0g0gn0039zwf004239b004okcf0b4hji70c98wsf0dcjwu70ehh4an0fkrx8f0govx1b0gppa7z0iwyb5r0l50pa70oh1g5b0qpf2tb0u1fugv0w893b310qqebj1asd5hb1gc4xz31lwjcan1p7anlr1x2a7zz1y6oxdreeeceeecee769h01abb7cbb38b54h020bab58ba58b764009bab7cab3ab546496b7b7c8b5ab564649c8b5cab5ab53fmk3cab3c8b5caeceeeccba3777377737787bba75gjjjld7c8c7cba5diiijag5cbc5cac37dddgid3abb5bac5ilj3ilj57bb5bbc5jal3jal5abb3bbc5gij3gij5b8b5b8c7ccccccb7b8b35553555555535553",
    cartographyTableSide1: "0g0gk0039zwf004239b004okcf0b4hji70c98wsf0dcjwu70ehh4an0fkrx8f0govx1b0gppa7z0iwyb5r0l50pa70oh1g5b0u1fugv0w893b31asd5hb1lxblz31p7anlr1uu7p4v1y6oxdr099647dcdddcdddc2gf965b38bb38ab312ig97a58bc3bbb390gf97b3abc3bbb3699945b5abc3b8b53ejh35b5abc5b8b5dddcddb5cac3bab7cba3777377737787bba788888887c8c7cba5bbcccc75cbc5cac3ddbccc83abb5bac5cdbccb757bb5bbc5abbbba85abb3bbc577777785b8b5b8c7ccccccb7b8b35553555555535553",
    
    smithingTableTop: "0g0g70a1073z0c9dukf0ehg9hb0flkav30htscu70k20etb0mae3un5544455665555566544433334443344653322233300223445422222220622335342122121432224654213111221122355324011111122235532241111212444543211111111104434221111111311243422220111111224502224611111212454221111221122245533301121222233564334033223333356655655445404455",
    smithingTableSide: "0g0gh04gg2kf06oo4jj08x1udb0a1073z0c8abjz0c9dukf0ehg9hb0flkav30hsdgjj0htscu70k0a8e70k20etb0m8cmin0pkde670rusiyn0xdgpa7155xhq77763565555795557553315315555355333315335333333330000111000100000108888888888880130aaaga88888aa0330debbb9cddadd13514b9b9b4444441351a52255aaa8880531a44f448aaaaa0731cddgdddadddd0750444g444444441751888gaaaaa88a1371aaa4a8888aaa1571ddcdddddccdd171144444444444411",
    smithingTableFront: "0g0gf04gg2kf06oo4jj0a1073z0c8abjz0c9dukf0ehg9hb0flkav30hsdgjj0htscu70k0a8e70k20etb0m8cmin0pkde670xdgpa7155xhq766524544446844464422142144442442222142242222222200001100000011001077799999977701209998977799991221cabacc8aca8c12403a3a33a333a31241787d7789998714219d7e999a7a991621cecdccc8c8cc16413e3a3333a333164199999977877912619779999977791461cccccccbbccc161133333333333311",
    smithingTableBottom: "0g0g506oo4jj0c8abjz0hsdgjj0k0a8e70m8cmin0033322332223200001211121111210031344443344433133132222222222412324222222222241321422222222223232142222222222412213222222222241231322222222223233242222222222323324222222222241231422222222224132142222222222423213344433344332300122111121221000023332233233200",
    
    enderPearl: "0g0gb0000000001eqyn0165b0f02avv2703dwfsv04jf6db06sfe2n0a4rfun0cfhnnj0eld5a7133z4lb00000000000000000000000000000000000000044400000000000449974400000000499755771000000497a83355710000049a8222335100004978211123351000195321112375100017532111239510000173322238910000017533338a51000000165379951000000001155511000000000001110000000000000000000000",
    netherWartIcon: "0g0g800000000l3rq4g0l3rqbj0pjqvb40pjqvi719jk8ow19jk8vz1g88cfz0000000000000000000000000000000000000000000000000000000000000000000007656430000000000665421000000000042643665000000076442174300000002447644210000000062444300000000004216430000000000066221000000000004210000000000000000000000000000000000000000000000000000000",
    flowerPotIcon: "0g0gg00000000dc8p330eg72m70fkb2f30fkb37j0l4jv9b0m86ynz0m8ckxr0ncaygv0swpdkv0v4xerj0xd5fy70xdb30f11tlibj16a77r319mdmgv000000000000000000000000000000000000001223000000000043abca4300000004ab9999ca400000085999999570000008e555555d70000008befeeddb700000007bbbbbb7000000007deeddb70000000008efed700000000007dedb7000000000006777000000000000000000000000000000000000000000000000000000",
    cake: "0g0gh00000000gof0n30u0npj312wx98f15556gv19l9ypr1bthybj1cv9r7j1f5ipz31ihjgu71lqwqnz1n1fsvz1sff4sf1upod1b1vy69rz1y6v9q71y711j300000000000000000000bbbbbbbb000000bbeffffffebb000begg7gaaggggeb0beg7gfadcag7ggebbfggfgbcabgfgcfbbeggcfebbffggfebbeffggggggcgfeeb2effffffefeeeeb224efffffeeeeeb21235efffeeefe532124885e5853e355210249898986655310002289998953110000001111111100000000000000000000",
    
    furnaceFrontOn: "0g0gi04gg2kf08ww4xr0gpim0v0ma2ozj0pmeqrj0sywflr0wb8hdr10rojr31440lj317gcnb31asop331d0wq9r1hdfenz1ilgt8f1y2mc5b1y5l3b31y70gzj1y711j33333233322232233355665656656564324686756787865633577211111127653367200000000264226500011110008423650022222200843268aabbbbbbaa86226765465456565533dbddddddddddda33aaaba7777abab9239a84100001e8a933883e0ceecff36933680ffegffge0983286cfgfhfhgfc692252eehghegfef252",
    
    goldNugget: "0g0g800000000u1fpq70yhq3gf1p7anlr1sk94vz1x1c1rz1x2w8hr1y711j30000000000000000000000000000000000000000000000000000000000000000000000222000000000000256510000000000026667100000000002667410000000000277431000000000002533100000000000253100000000000002100000000000000000000000000000000000000000000000000000000000000000000000",
    ironNugget: "0g0gc00000000flpw5c0flpwcf0oim2gw0oim2nz0v87y0w0v87y7z18l3ain1f9rev31gdpse71o66ku71uuozr30000000000000000000000000000000000000000000000000000000000000000000000011000000000000044511100000000048a4445100000004abba772300000004baa766200000000498822200000000002220000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    redstone: "0g0g800000000c7i51b0efkj5r0hrfmyn0pj49of0v2qj271amknb31xx5on30000000000000000000000000000000000000000000000000000000440000000000000456400000000000467631000000000467657310000000466676343100000457653753621000046567653343100001367653633210000013653433210000000112332110000000000111100000000000000000000000000000000000000",
    
    pumpkinTop: "0g0g80qoy39b18hh2pr1apuq671e34c1r1ii08hr1qas8ov1qbvta71qc11bz4442454424442442445525552555252445555456466544544446525525426522455251441424545445651730114525645565437304124564452110377144554224554103301112544652144001445555562554141415225445455244245154244265255525542524245546645555255245526652456624522442445244544442",
    pumpkinSide: "0g0g60ygy03j18hh2pr1apuq671ii08hr1qas8ov1qbvta73331333123332131444134431443144145512554155513511452155514553153144314441444414314431444144441441444144414444144144414441444314414441444144431441444144404441344144314430444144414430443044414441343043304430433134033330333033101301311033101300110111101100110",
    carvedPumpkin: "0g0g80c7i51b0ivuvb30ygy03j18hmozj19lwcn31iibh1b1qb3h8f1qbvta75553555345554353666356653665366357730057350635733674010730005375366011163011036536601116301113663660111530111166366711653711117636667657567767663660305605503066360000100100106636011111111111163560171151115115356066163661266323525533353323522332353323322332",
    jackOLantern: "0g0ga0ygy03j18hmozj19lwcn31iibh1b1n0670f1qb3h8f1qbvta71y4nxfj1y5wsfz1y70jcv3332333123332131555335532553255136637736357535611563787637775363155788853788735315578995379983551557899327998455155699532689986515556536356656551557573573375755157777977977875515788999999988851357858939883843135655451554055101303311131101300110131101100110",
    
    pumpkinSeeds: "0g0g400000001jomm0v1jpevpb1jq1ibj0000000000000000000000000000000000000000000000000000000000000000000003000000000000000320000030000000021000003200000030000320210000002200321000000003000000000000000320003003320000021003200210000000000210000000000000000000000000000000000000000000000000000000",
    melonSeeds: "0g0g4000000007sgr270b4sr9b0qq7awv0000000000000000000000000000000000000000320000000000000021000000000013000000000000001200320030000000000021003200000000003300210000003030220000000003102000000000000210003003200000000002100110000000000000000000000000000000000000000000000000000000000000000000",
    
    shears: "0g0g900000000hts9of0pkolxb0u0teyn0v74gsf11syyv319l4hz31asop331n1wvlr0000000000000000000000000000000000000000378870000000000348870700000000357870780000000367870788000000362470788700000036200787420000036200047320000003520033320000000773335520000000700455220000000040012200000000000110000000000000000000000000000000000000000000",
    
    melonSide: "0g0g50dfir5r0ek3lrz0mc3h1b0u4elmn19ov6673412434114342143341143412434143334214343243414333422433423442343432234342244224342222434224322434222243422432243432234342343224334214334243412433411433414341143341043421433404334204241043240422410424104224042240042400422404224004240042340433401434014334043",
    melonTop: "0g0g50cb3i0v0dftzpb0mc3h1b0u4elmn19ov6673421433414341243334224342432243443342434242343421433323413143321214333432143221244321342233223443344212102123433223343143023322212223304203443214334431002333444344311332143223343213342323412241224324134134442244324312422233443423432434222333422433243342243",
    melonSlice: "0g0gd00000000iy77r30ofy1vj0oiwven0xbl24f10rtm9r18k4q2n1bquayn1g7r9q71hc6kfz1ijfcov1jm4min1n0nlkv0000000000000000000000000000000000000000005300000000000008a6300000000000888a630000000008748c630000000089877c530000000888287c510000008777888c51000008782877bc51000088478878c6100005a88888bc631000016accccc5310000001666553110000000011111100000000000000000000000",

    //pretty: "0g0g40001blc009d4hc009efw01ulak1c3300022112200033333022111122033303332112211233300033312222133300022333222233322022113330033311222112233333322112112220333302221111222033330222112112233333322112221133300333112202233322223332200033312222133300033321122112333033302211112203333300222112200033",
    
    //pigFace: "0g0gr000006w14172ew1hejb3s1heul881luzbw81lvx4oo1o2w1dk1qb44541qbfcoo1sj0ws81sjc3qw1sjc5bs1sjndvc1sjnfg81sjynzs1sjypko1sk9y481skl9tk1ur8we01urk6ig1urvf201urvgmw1urvi7s1us6p6g1us6qrc1ustb081x2x0xkaa669999ddddbbddaa669999ddddbbdd7766ccii99kknnnn7766ccii99kknnnn88cceeeeddddeenn88cceeeeddddeenn00qqbbbbjjjjqq0000qqbbbbjjjjqq0099ddhhppppppggdd99ddhhppppppggddcccc11ddff11llllcccc11ddff11llll999922335544oomm999922335544oommbbbbddeellffffnnbbbbddeellffffnn",
    /*
    steveFace: "0g0gw08wkrnc0b4hipk0b4sr940dcpjw80fkxji00hs7rw80hsj0fs0hsuak80m9axh40sxbw8o0sxbxtk0xdgohk0zloo3c0zlopo811ta86w11twpa0141thx416a1hiw16acrnc16ao3co18i9h4o1aqhlh41aqsvlk1ar45q01cypmns1cz0ws81cz0yd41czc5bs1f78we01f78xyw1hfh0qg1x2x0xk221111110000111122111111000011111111113377441111111111337744111111rrttuuttttll3311rrttuuttttll33mmppmmnnjjttiiiimmppmmnnjjttiiiippvv88oott88vvmmppvv88oott88vvmmhhooqqaaaasskkcchhooqqaaaasskkccgggg66eeee66ffddgggg66eeee66ffdd999966556666ddbb999966556666ddbb",
    steveHeadTop: "0g0g406ocs1k08w9j3s08wkrnc0b4hipk3333223333222200333322333322221133223333332222223322333333222222333333223322222233333322332222222233332233333333223333223333333333333322223333333333332222333333333322223333333333332222333333333322333333113333332233332200333333333322222233333333222222223333",
    lexiFace: "0g0g6009pbso06oo3qw1urv2ew1utfnco1wxln201x2x0xk3333333333333333333333333333333333332222222233333333222222223333331111222211113333111122221111333355002222005533335500222200553333550022220055333355002222005533332222222222223333222222222222333322224444222233332222444422223333332222222233333333222222223333",
		lexiTop: "0g0g11utfnco0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    sarahFace: "0g0g6009ehh406o1hx406oo3qw1wugttk1x1114o1x2x0xk1111111111111111111111111111111111114411111111111111441111111111111122441111111111112244111111111155004444111111115500444411111111550044444411111155004444441111114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
		sarahTop: "0g0g106o1hx40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    sallyFace: "0g0g6000006w006lb0806oo3qw1sgim7s1wzrth41x2x0xk0000000000000000000000000000000000004444444400000000444444440000000022444422000000002244442200000000114444110000000011444411000000551144441155000055114444115500004444444444440000444444444444000044443333444400004444333344440000444444444444000044444444444400",
		sallyTop: "0g0g1000006w0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		face: "0g0g60077lrs0fkme480ohifp41unspvc1x1114o1x2x0xk1111111111111111111111111111111111114444444411111111444444441111112222444422221111222244442222111155004444005511115500444400551111550044440055111155004444005511114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
		faceTop: "0g0g10fkme480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    //*/
    
    cowSide:"0g0g400000000qoh7n40qoh7nc1uuozqw0000000000000000000000000000000000000000000000000000000000000000001111111111100011111111331111112233222333322322223332233332332222333222332233222233322222223322222222233322332222222222222222220220000000002200022000000000220002200000000022000220000000002200",
    cow: "0g0g20xd56go1uuozqw0000000000000000000100000001110000111000100111100011100000001111000110000000111100000001100001110010000111000000001100111100000000010011100110000000011100011000100001110000000011000000000001101100110000000100110011100011000010001111000110000000011100011100",
    
    error:function(n){
      for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
          let p = false
          if(x>=8){
            if(y>=8){
              p=true
            }
          }else{
            if(y<8){
              p=true
            }
          }
					if(p){
					  setPixel(n, x, y, 0, 0, 0);
          }else{
            setPixel(n, x, y, 255, 0, 255);
          }
				}
			}
    }//"0g0g2000006w1ulbvg81111111100000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000000000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000011111111",
	}
  window.textures = textures

	const blockData = [
		{
			name: "air",
			id: 0,
			textures: [],
			transparent: true,
			shadow: false,
		},
		{
			name: "grass",
			textures: [ "dirt", "grassTop", "grassSide" ],
      breakTime: 0.9,
      drop:"dirt",
      type:"ground",
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
		{ name: "dirt", breakTime:0.75, type:"ground",
      digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
      stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"]
    },
		{ name: "stone", drop:"cobblestone", type:"rock1", breakTime:7.5, stoneSound:true},
		{ name: "bedrock", breakTime:Infinity, stoneSound:true},
		{ name: "sand", breakTime:0.75,
      onupdate: function(x,y,z){
        fall(x,y,z,blockIds.sand)
      },
      digSound: ["block.sand.dig1", "block.sand.dig2", "block.sand.dig3", "block.sand.dig4"],
      stepSound: ["block.sand.step1", "block.sand.step2","block.sand.step3","block.sand.step4","block.sand.step5"]},
		{ name: "gravel", breakTime:0.9, type:"ground",
      onupdate: function(x,y,z){
        fall(x,y,z,blockIds.gravel)
      },
      drop: function(){
        if(round(random(10)) === 1) return "flint"
        else return "gravel"
      },
      digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
      stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"]},
		{
			name: "leaves",
			transparent: true,
      breakTime: 0.3,
      type:"plant2",
      drop: function(){
        if(rand() > 0.8){
          let r = floor(rand(3))
          if(r === 0) return "stick"
          else if(r === 1) return "oakSapling"
          else return "apple"
        }
      },
      dropSelfWhenSheared:true,
      shearBreakTime:0.05,
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
		{
			name: "glass",
			transparent: true,
			shadow: false,
      breakTime: 0.45,
      type: "glass",
      glassSound: true
		},
		{ name: "cobblestone", breakTime:10, type:"rock1", stoneSound:true},
		{ name: "mossyCobble", breakTime:10, type:"rock1", stoneSound:true},
		{ name: "stoneBricks", breakTime:7.5, type:"rock1", stoneSound:true},
		{ name: "mossyStoneBricks", breakTime:7.5, type:"rock1", stoneSound:true},
		{ name: "bricks", breakTime:10, type:"rock1", stoneSound:true},
		{ name: "coalOre", breakTime:15, type:"rock1", drop:"coal", stoneSound:true},
		{ name: "ironOre", breakTime:15, type:"rock2", drop:"rawIron", stoneSound:true},
		{ name: "goldOre", breakTime:15, type:"rock3", drop:"rawGold", stoneSound:true},
		{ name: "diamondOre", breakTime:15, type:"rock3", drop:"diamond", stoneSound:true},
		{ name: "redstoneOre", breakTime:15, type:"rock3", stoneSound:true, drop:"redstoneDust", dropAmount:[4,5]},
		{ name: "lapisOre", breakTime:15, type:"rock2", drop:"lapisLazuli", stoneSound:true},
		{ name: "emeraldOre", breakTime:15, type:"rock3", drop:"emerald", stoneSound:true},
		{ name: "coalBlock", breakTime:25, type:"rock1", stoneSound:true},
		{ name: "ironBlock", breakTime:25, type:"metal2", stoneSound:true},
		{ name: "goldBlock", breakTime:15, type:"metal3", stoneSound:true},
		{ name: "diamondBlock", breakTime:25, type:"metal3", stoneSound:true},
		{ name: "redstoneBlock", breakTime:25, type:"metal1", stoneSound:true},
		{ name: "lapisBlock", breakTime:15, type:"metal2", stoneSound:true},
		{ name: "emeraldBlock", breakTime:25, type:"metal3", stoneSound:true},
		{ name: "oakPlanks", type:"wood", breakTime:3, woodSound:true},
		{
			name: "oakLog",
			textures: [ "logTop", "logSide" ],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
		{ name: "acaciaPlanks", type:"wood", breakTime:3, woodSound:true},
		{
			name: "acaciaLog",
			textures: [ "acaciaLogTop", "acaciaLogSide" ],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
		{ name: "birchPlanks", type:"wood", breakTime:3, woodSound:true},
		{
			name: "birchLog",
			textures: [ "birchLogTop", "birchLogSide" ],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
		{ name: "darkOakPlanks", type:"wood", breakTime:3, woodSound:true},
		{
			name: "darkOakLog",
			textures: [ "darkOakLogTop", "darkOakLogSide" ],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
		{ name: "junglePlanks", type:"wood", breakTime:3,woodSound:true},
		{
			name: "jungleLog",
			textures: [ "jungleLogTop", "jungleLogSide" ],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
		{ name: "sprucePlanks", type:"wood", breakTime:3, woodSound:true},
		{
			name: "spruceLog",
			textures: [ "spruceLogTop", "spruceLogSide" ],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
		{ name: "whiteWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "orangeWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "magentaWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "lightBlueWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "yellowWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "limeWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "pinkWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "grayWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "lightGrayWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "cyanWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "purpleWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "blueWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "brownWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "greenWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "redWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "blackWool", breakTime:1.2, clothSound:true, shearBreakTime:0.2},
		{ name: "whiteConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "orangeConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "magentaConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "lightBlueConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "yellowConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "limeConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "pinkConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "grayConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "lightGrayConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "cyanConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "purpleConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "blueConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "brownConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "greenConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "redConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{ name: "blackConcrete", breakTime:9, type:"rock1", stoneSound:true},
		{
			name: "bookshelf",
			textures: [ "oakPlanks", "bookshelf" ],
      stoneSound: true,
      type:"wood", 
		},
		{ name: "netherrack",
      digSound: ["block.netherrack.dig1", "block.netherrack.dig2", "block.netherrack.dig3", "block.netherrack.dig4", "block.netherrack.dig5", "block.netherrack.dig6"],
      stepSound: ["block.netherrack.step1", "block.netherrack.step2","block.netherrack.step3","block.netherrack.step4","block.netherrack.step5","block.netherrack.step6"]},
		{ name: "soulSand",
      _1PixLower: true,
      speedFactor: 0.5,
      digSound: ["block.soul_sand.dig1", "block.soul_sand.dig2", "block.soul_sand.dig3", "block.soul_sand.dig4", "block.soul_sand.dig5", "block.soul_sand.dig6","block.soul_sand.step7","block.soul_sand.step8","block.soul_sand.step9"],
      stepSound: ["block.soul_sand.step1", "block.soul_sand.step2","block.soul_sand.step3","block.soul_sand.step4","block.soul_sand.step5","block.soul_sand.step6"]},
		{
			name: "glowstone",
			lightLevel: 15,
      glassSound: true
		},
		{ name: "netherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
		{ name: "redNetherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
		{ name: "netherQuartzOre", 
      digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
      stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"]},
		{
			name: "quartzBlock",
			textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"],
      stoneSound: true
		},
		{
			name: "quartzPillar",
			textures: ["quartzPillarTop", "quartzPillar"],
      stoneSound: true
		},
		{
			name: "chiseledQuartzBlock",
			textures: ["chiseledQuartzBlock", "chiseledQuartzBlockTop"],
        stoneSound: true
		},
		{ name: "chiseledStoneBricks", stoneSound:true},
		{ name: "smoothStone", stoneSound:true},
		{ name: "andesite", stoneSound:true},
		{ name: "polishedAndesite", stoneSound:true},
		{ name: "diorite", stoneSound:true},
		{ name: "polishedDiorite", stoneSound:true},
		{ name: "granite", stoneSound:true},
		{ name: "polishedGranite", stoneSound:true},
		{ // I swear, if y'all don't stop asking about TNT every 5 minutes!
		  name: "tnt",
		  textures: ["tntBottom", "tntTop", "tntSides"],
      //onupdate: function(x,y,z){
      //  explode(x,y,z,5)
      //}, flint and steel explodes it
      explode: function(x,y,z){
        world.setBlock(x,y,z,0)
        world.addEntity(new PrimedTNT(x,y,z))
        playSound("entity.tnt.fuse", 0, posSound(x,y,z))
      },
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
    {
      name: "portal",
      solid:false,
      shadow: false,
      portal: true,
      transparent:true,
      lightLevel: 11,
      ontouch: function(){
        portalEffect += 2
        if(portalEffect >= 100){
          portalEffect = 0
          //releasePointer()
          if(world.type === "nether"){
            world = dimensions.overworld
            //world.loadSave(world.getSaveString())
            //changeScene("loading")
          }else{
            world = dimensions.nether
            //world.loadSave(world.getSaveString())
            //changeScene("netherLoading")
          }
        }
      },
      glassSound: true
    },
    { name: "obsidian", stoneSound:true},
    {
      name:"redstoneDust",
      flatIcon:true,
      iconTexture:"redstone",
      /*onupdate: function(x,y,z){
        var neigbors = [
          world.getBlock(x+1,y,z),
          world.getBlock(x-1,y,z),
          world.getBlock(x,y,z+1),
          world.getBlock(x,y,z-1),
          world.getBlock(x,y+1,z),
          world.getBlock(x,y-1,z)
        ];
        
        if(neigbors.includes(blockIds.redstoneBlock) || neigbors.includes(blockIds.redstoneDustOn)){
          world.setBlock(x,y,z, blockIds.redstoneDustOn, false, true)
        }
        
      }*/
    },
    {
      name:"redstoneDustOn",
      hidden: true,
      /*onupdate: function(x,y,z){
        var checked = []
        
        function touchingSource(x,y,z, t){
          t = t || 0;
          t ++;
          
          var neighbors = [
            [x+1,y,z],
            [x-1,y,z],
            [x,y,z+1],
            [x,y,z-1],
            [x,y+1,z],
            [x,y-1,z]
          ];
          
          for(var i=0; i<neighbors.length; i++){
            var value = neighbors[i];
            var block = world.getBlock(value[0], value[1], value[2])
            
            if(block === blockIds.redstoneBlock){
              return true;
            }
            
            if(t<10){
              if( !(checked.includes[value]) && (block === blockIds.redstoneDust || block === blockIds.buffer) && touchingSource(value[0], value[1], value[2], t)){
                checked.push(value);
                return true
              };
            }
            
          }
          return false;
        }
        
        if(!touchingSource(x,y,z)){
          world.setBlock(x,y,z, blockIds.redstoneDust);
        }
        
        //world.setBlock(x,y,z, blockIds.redstoneDust);
      }*/
    },
    {
      name: "buffer",
      textures: ["bufferTop", "bufferMiddle"],
      onupdate: function(x,y,z){
        setTimeout(() => {
          var isOn = world.getBlock(x,y+1,z);
          isOn = isOn === blockIds.redstoneDustOn || isOn === blockIds.redstoneBlock;
          if(isOn && world.getBlock(x,y-1,z) === blockIds.redstoneDust ){
            setTimeout(function(){world.setBlock(x,y-1,z, blockIds.redstoneDustOn)}, 500);
          }
        }, 10)
      }
    },
    { name: "soup"},
    { name: "soup2"},
    {
      name: "soup3",
      transparent:true,
    },
    { name: "soup4"},
    { name: "randomSoup"},
    {
      name: "redStain",
      transparent: true,
    },
    {
      name:"poision potion",
      transparent:true,
      crossShape:true,
    },
    
    {
      name: "light",
      textures: "none",
      transparent:true,
      lightLevel: 15,
      solid: false,
      icon: "glass",
      shadow: false
    },
    
    {
			name: "autumnLeaves",
			transparent: true,
		},
		{
			name: "darkLeaves",
			transparent: true,
		},
		{
			name: "redBerryLeaves",
			transparent: true,
		},
		{
			name: "blueBerryLeaves",
			transparent: true,
		},
    {
      name: "pinkLeaves",
      transparent: true,
    },
    
    { name: "flowerOftheValley",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
		{ name: "poppy",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
		{ name: "dandelion",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "blueOrchid",
		    solid: false,
		    transparent: true,
		    shadow: false,
        crossShape: true,
		},
    { name: "pinkTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "orangeTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "redTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "whiteTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "azureBluet",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "cornFlower",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "purpleFlower",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "allium",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "oxeyeDaisy",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "lilac",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "lilacTop",
        tallcrossShape: true,
		},
    { name: "roseBush",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "roseBushTop",
        tallcrossShape: true,
		},
    { name: "peony",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "peonyTop",
        tallcrossShape: true,
		},
    { name: "witherRose",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
      ontouch: () => {witherEffect = 120; witherDamage = 1; witherTime = 2000}
		},
    { name: "TallGrass",
		    solid: false,
		    transparent: true,
		    shadow: false,
        crossShape: true,
      drop: "wheatSeeds",
      dropAmount:[0,1],
      dropSelfWhenSheared:true,
      shearDropAmount:1
		},
    
		{ 
      name: "oakDoor",
		  transparent: true,
		  shadow: false,
      textures: "oakDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "spruceDoor",
		  transparent: true,
		  shadow: false,
      textures:"spruceDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "ironDoor",
		  transparent: true,
		  shadow: false,
      textures:"ironDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "darkOakDoor",
		  transparent: true,
		  shadow: false,
      textures:"darkOakDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "birchDoor",
		  transparent: true,
		  shadow: false,
      textures:"birchDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "jungleDoor",
		  transparent: true,
		  shadow: false,
      textures:"jungleDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "acaciaDoor",
		  transparent: true,
		  shadow: false,
      textures:"acaciaDoorBottom",
      door:true,
      woodSound:true
    },
		{
      name: "warpedDoor",
		  transparent: true,
		  shadow: false,
      textures:"warpedDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "crimsonDoor",
		  transparent: true,
		  shadow: false,
      textures:"crimsonDoorBottom",
      door:true,
      woodSound:true
		},
    
    {
      name: "torch",
		  transparent: true,
		  shadow: false,
      torch: true,
      lightLevel: 13,
      woodSound:true
		},
		{
      name: "soulTorch",
		  transparent: true,
		  shadow: false,
      torch: true,
      lightLevel: 10,
      woodSound:true
		},
    
    {
      name: "lantern",
		  transparent: true,
		  shadow: false,
      lightLevel: 13,
      iconTexture: "lanternIcon",
      lantern: true,
      digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
      placeSound: ["block.lantern.place1", "block.lantern.place2","block.lantern.place3","block.lantern.place4","block.lantern.place5","block.lantern.place6"]
		},
    {
      name: "soulLantern",
		  transparent: true,
		  shadow: false,
      lightLevel: 10,
      iconTexture:"soulLanternIcon",
      lantern: true,
      digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
      placeSound: ["block.lantern.place1", "block.lantern.place2","block.lantern.place3","block.lantern.place4","block.lantern.place5","block.lantern.place6"]
		},
    
    {
      name: "beacon", 
		  transparent: true,
		  shadow: false,
      beacon: true,
      lightLevel: 15,
      glassSound: true
		},
    
    {
      name: "cactus",
		  textures: ["cactusBottom", "cactusTop", "cactusSide"],
		  transparent: true,
      cactus: true,
      damage: 1,
      potCross: true
		},
    
    {
			name: "glassPane",
			transparent: true,
			shadow: false,
      breakTime: 60,
      pane:true,
      textures: ["glassPaneTop","glassPaneTop","glass","glass","glassPaneSide","glassPaneSide"],
      glassSound: true
		},
    
    { name: "ladder",
		  transparent: true,
		  shadow: false,
		  wallFlat: true,ladder:true
		},
		{ name: "vine",
		  transparent: true,
		  shadow: false,
		  wallFlat: true,ladder:true,
      noDrop:true,
      dropSelfWhenSheared:true,
      shearBreakTime:0.35
		},
    
    {
      name: "Water",
      transparent: true,
      liquid: true,
      solid:false,
      shadow: false, //to hide faces
      semiTrans: true
    },
    {
      name: "Lava",
      transparent: true,
      liquid: true,
      solid:false,
      lightLevel:15,
      damage:4,
      dieMessage: () => username+" tried to swim in lava.",
      shadow: false
    },
    
    {
      name: "craftingTable",
      textures: ["oakPlanks","craftingTableTop","craftingTableFront","craftingTableSide"],
      onclick: () => {changeScene("crafting"); releasePointer()},
      woodSound: true
    },
    
    {
      name: "crimsonNylium",
      textures: ["netherrack", "crimsonNyliumTop", "crimsonNyliumSide"],
      nyliumSound: true
    },
    {
      name: "warpedNylium",
      textures: ["netherrack", "warpedNyliumTop", "warpedNyliumSide"],
      nyliumSound: true
    },
    {
      name: "crimsonStem",
      textures: ["crimsonStemTop", "crimsonStemSide"],
      stemSound: true
    },
    {
      name: "warpedStem",
      textures: ["warpedStemTop", "warpedStemSide"],
      stemSound: true
    },
    { name: "netherWartBlock",
      digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
      stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
    { name: "warpedWartBlock",
      digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
      stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
    { name: "shroomlight", lightLevel:15,
      digSound: ["block.shroomlight.dig1", "block.shroomlight.dig2", "block.shroomlight.dig3", "block.shroomlight.dig4", "block.shroomlight.dig5"],
      stepSound: ["block.shroomlight.step1", "block.shroomlight.step2","block.shroomlight.step3","block.shroomlight.step4","block.shroomlight.step5","block.shroomlight.step6"]},
    { 
		  name: "warpedFungus",
		  solid: false,
		  shadow: false,
      transparent: true,
      crossShape: true,
      potCross: true,
      digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
		},
    {
			name: "blackstone",
			textures: ["blackstoneTop", "blackstone" ],
      stoneSound: true
		},
		{ name: "gildedBlackstone", stoneSound: true},
		{ name: "polishedBlackstoneBricks", stoneSound: true},
		{ name: "chiseledPolishedBlackstone", stoneSound: true},
		{
      name: "netheriteBlock",
      type:"rock4",
      breakTime:250,
      digSound: ["block.netherite.dig1", "block.netherite.dig2", "block.netherite.dig3", "block.netherite.dig4"],
      stepSound: ["block.netherite.step1", "block.netherite.step2","block.netherite.step3","block.netherite.step4","block.netherite.step5","block.netherite.step6"]
    },
    {
			name: "basalt",
			textures: [ "basaltTop", "basaltSide" ],
      basaltSound: true
		},
    {
			name: "polishedBasalt",
			textures: [ "polishedBasaltTop", "polishedBasaltSide" ],
      basaltSound: true
		},
		{ name: "chain", transparent:true, shadow:false, chain:true, iconTexture:"chainIcon",
      digSound: ["block.chain.dig1", "block.chain.dig2", "block.chain.dig3", "block.chain.dig4"],
      stepSound: ["block.chain.step1", "block.chain.step2","block.chain.step3","block.chain.step4","block.chain.step5","block.chain.step6"]},
		{ name: "warpedPlanks", woodSound:true},
		{ 
		  name: "warpedTrapdoor",
		  transparent: true,
      shadow: false,
      trapdoor: true,
      woodSound:true
		},
		{ name: "magma", lightLevel:15},
		{
		  name: "crimsonFungus",
		  solid: false,
		  shadow: false,
      transparent: true,
      crossShape: true,
      potCross: true,
      digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
		},
		{ 
		    name: "warpedRoots",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true,
        rootSound: true
		},
		{ 
		    name: "crimsonRoots",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true,
      rootSound: true
		},
		{ 
		    name: "twistingVines",
      transparent: true,
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true
		},
		{ 
		    name: "twistingVinesPlant",
      transparent: true,
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true
		},
		{ 
		    name: "weepingVines",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true
		},
		{ 
		    name: "weepingVinesPlant",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true
		},
		{ 
		    name: "netherSprouts",
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true,
      digSound: ["block.nether_sprouts.dig1", "block.nether_sprouts.dig2", "block.nether_sprouts.dig3", "block.nether_sprouts.dig4"],
      stepSound: ["block.nether_sprouts.step1", "block.nether_sprouts.step2","block.nether_sprouts.step3","block.nether_sprouts.step4","block.nether_sprouts.step5"]
		},
    
    { name: "stoneButton", textures:"stone", button:true, transparent: true },
    
    { 
		  name: "RespawnAnchorOff",
		  textures: ["respawnAnchorBottom", "respawnAnchorTopOff", "respawnAnchorSide0"],
      onupdate: (x,y,z) => {if(world.type !== "nether"){explode(x,y,z,2)}}
		},
		{ 
		  name: "RespawnAnchor1",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop1", "respawnAnchorSide1"],
      //hidden: true
		},
		{ 
		  name: "RespawnAnchor2",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop2", "respawnAnchorSide2"],
      //hidden: true
		},
		{ 
		  name: "RespawnAnchor3",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop3", "respawnAnchorSide3"],
      //hidden: true
		},
		{ 
		  name: "RespawnAnchor",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop", "respawnAnchorSide4"],
      //hidden: true
		},
    
    {
      name:"redBed",
      textures: "bedbottom",
      iconTexture: "bedIcon",
      flatIcon: true,
      onclick: (x,y,z) => {
        if(world.type !== ""){explode(x,y,z,5); return}
        world.spawnPoint.x=x
        world.spawnPoint.y=y
        world.spawnPoint.z=z
        Messages.add("You can't sleep in beds yet")
        Messages.add("Respawn point set")
      },
      transparent: true,
      bed: true,
      bounciness: 0.6
    },
    
    {
      name: "flintAndSteel",
      textures: "flintAndSteel",
      item: true,
      onuse: (x,y,z, block) => {
        if(block === blockIds.tnt){
          blockData[blockIds.tnt].explode(x,y,z)
        }
      }
    },
    
    {
      name: "barrier",
      textures: "none",
      iconTexture: "barrier",
      flatIcon:true,
      transparent:true
    },
    {
      name: "oakSapling",
      crossShape: true,
      potCross: true,
      transparent: true,
      solid: false,
      shadow:false,
      grow: function(wx,wy,wz){
        let i=wx, j=wy, k=wz
        var ground = wy//this.chunk.tops[i * 16 + k]
        var top = ground + floor(4.5 + (Math.random()*2.5) )
        var rand = floor(Math.random()*4096)
        let tree = blockIds.oakLog
        let leaf = blockIds.leaves
        let groundBlock = blockIds.dirt

        //Center
        for (let j = ground + 1; j <= top; j++) {
          world.setBlock(i, j, k, tree)
        }
        world.setBlock(i, top + 1, k, leaf)
        world.setBlock(i, ground, k, groundBlock)

        //Bottom leaves
        for (let x = -2; x <= 2; x++) {
          for (let z = -2; z <= 2; z++) {
            if (x || z) {
              if ((x * z & 7) === 4) {
                place = rand & 1
                rand >>>= 1
                if (place) {
                  world.setBlock(wx + x, top - 2, wz + z, leaf)
                }
              } else {
                world.setBlock(wx + x, top - 2, wz + z, leaf)
              }
            }
          }
        }

        //2nd layer leaves
        for (let x = -2; x <= 2; x++) {
          for (let z = -2; z <= 2; z++) {
            if (x || z) {
              if ((x * z & 7) === 4) {
                place = rand & 1
                rand >>>= 1
                if (place) {
                  world.setBlock(wx + x, top - 1, wz + z, leaf)
                }
              } else {
                world.setBlock(wx + x, top - 1, wz + z, leaf)
              }
            }
          }
        }

        //3rd layer leaves
        for (let x = -1; x <= 1; x++) {
          for (let z = -1; z <= 1; z++) {
            if (x || z) {
              if (x & z) {
                place = rand & 1
                rand >>>= 1
                if (place) {
                  world.setBlock(wx + x, top, wz + z, leaf)
                }
              } else {
                world.setBlock(wx + x, top, wz + z, leaf)
              }
            }
          }
        }

        //Top leaves
        world.setBlock(wx + 1, top + 1, wz, leaf)
        world.setBlock(wx, top + 1, wz - 1, leaf)
        world.setBlock(wx, top + 1, wz + 1, leaf)
        world.setBlock(wx - 1, top + 1, wz, leaf)
      }
    },
    
    { 
		  name: "crimsonTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "oakTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "spruceTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "darkOakTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "birchTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "jungleTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "acaciaTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "ironTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    
    { 
      name: "cryingObsidian",
      shadow: false,
      lightLevel: 10
    },
    { name: "netherGoldOre",
      digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
      stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"]},
    {
			name: "flowerPot",
			transparent: true,
			shadow: false,
      pot: true,
      iconTexture:"flowerPotIcon",
      flatIcon:true
		},
		{
			name: "acaciaSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "birchSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true,
      grow:function(wx,wy,wz){
        let i=wx, j=wy, k=wz
        var ground = wy//this.chunk.tops[i * 16 + k]
        var top = ground + floor(4.5 + (Math.random()*2.5) )
        var rand = floor(Math.random()*4096)
        let tree = blockIds.birchLog
        let leaf = blockIds.leaves
        let groundBlock = blockIds.dirt

        //Center
        for (let j = ground + 1; j <= top; j++) {
          world.setBlock(i, j, k, tree)
        }
        world.setBlock(i, top + 1, k, leaf)
        world.setBlock(i, ground, k, groundBlock)

        //Bottom leaves
        for (let x = -2; x <= 2; x++) {
          for (let z = -2; z <= 2; z++) {
            if (x || z) {
              if ((x * z & 7) === 4) {
                place = rand & 1
                rand >>>= 1
                if (place) {
                  world.setBlock(wx + x, top - 2, wz + z, leaf)
                }
              } else {
                world.setBlock(wx + x, top - 2, wz + z, leaf)
              }
            }
          }
        }

        //2nd layer leaves
        for (let x = -2; x <= 2; x++) {
          for (let z = -2; z <= 2; z++) {
            if (x || z) {
              if ((x * z & 7) === 4) {
                place = rand & 1
                rand >>>= 1
                if (place) {
                  world.setBlock(wx + x, top - 1, wz + z, leaf)
                }
              } else {
                world.setBlock(wx + x, top - 1, wz + z, leaf)
              }
            }
          }
        }

        //3rd layer leaves
        for (let x = -1; x <= 1; x++) {
          for (let z = -1; z <= 1; z++) {
            if (x || z) {
              if (x & z) {
                place = rand & 1
                rand >>>= 1
                if (place) {
                  world.setBlock(wx + x, top, wz + z, leaf)
                }
              } else {
                world.setBlock(wx + x, top, wz + z, leaf)
              }
            }
          }
        }

        //Top leaves
        world.setBlock(wx + 1, top + 1, wz, leaf)
        world.setBlock(wx, top + 1, wz - 1, leaf)
        world.setBlock(wx, top + 1, wz + 1, leaf)
        world.setBlock(wx - 1, top + 1, wz, leaf)
      }
		},
		{
			name: "darkOakSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "jungleSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "spruceSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "blueOrchidPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
		{
			name: "warpedRootsPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
		{
			name: "crimsonRootsPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
    { name: "whiteCarpet", textures: "whiteWool", carpet: true, clothSound:true},
		{ name: "orangeCarpet", textures: "orangeWool", carpet: true, clothSound:true},
		{ name: "magentaCarpet", textures: "magentaWool", carpet: true, clothSound:true},
		{ name: "lightBlueCarpet", textures: "lightBlueWool", carpet: true, clothSound:true},
		{ name: "yellowCarpet", textures: "yellowWool", carpet: true, clothSound:true},
		{ name: "limeCarpet", textures: "limeWool", carpet: true, clothSound:true},
		{ name: "pinkCarpet", textures: "pinkWool", carpet: true, clothSound:true},
		{ name: "grayCarpet", textures: "grayWool", carpet: true, clothSound:true},
		{ name: "lightGrayCarpet", textures: "lightGrayWool", carpet: true, clothSound:true},
		{ name: "cyanCarpet", textures: "cyanWool", carpet: true, clothSound:true},
		{ name: "purpleCarpet", textures: "purpleWool", carpet: true, clothSound:true},
		{ name: "blueCarpet", textures: "blueWool", carpet: true, clothSound:true},
		{ name: "brownCarpet", textures: "brownWool", carpet: true, clothSound:true},
		{ name: "greenCarpet", textures: "greenWool", carpet: true, clothSound:true},
		{ name: "redCarpet", textures: "redWool", carpet: true, clothSound:true},
		{ name: "blackCarpet", textures: "blackWool", carpet: true, clothSound:true},
    
    { name: "polishedBlackstone", stoneSound:true},
    { name: "chiseledNetherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
    { name: "crackedNetherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
    { name: "smoothBasalt", basaltSound: true},
    
    {
			name: "oakLogSW",
			textures: ["logSide","logSide","logTop","oakLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "acaciaLogSW",
			textures: ["acaciaLogSide","acaciaLogSide","acaciaLogTop","acaciaLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "birchLogSW",
			textures: ["birchLogSide","birchLogSide","birchLogTop","birchLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "darkOakLogSW",
			textures: ["darkOakLogSide","darkOakLogSide","darkOakLogTop","darkOakLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "jungleLogSW",
			textures: ["jungleLogSide","jungleLogSide","jungleLogTop","jungleLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "spruceLogSW",
			textures: ["spruceLogSide","spruceLogSide","spruceLogTop","spruceLogSW"],
      rotate: true, woodSound:true
		},
    {
			name: "crimsonStemSW",
			textures: ["crimsonStemSide","crimsonStemSide","crimsonStemTop","crimsonStemSW"],
      rotate: true, stemSound:true
		},
    {
			name: "warpedStemSW",
			textures: ["warpedStemSide","warpedStemSide","warpedStemTop","warpedStemSW"],
      rotate: true, stemSound:true
		},
    {
			name: "basaltSW",
			textures: ["basaltSide","basaltSide","basaltTop","basaltSideSW"],
      rotate: true, basaltSound:true
		},
    {
			name: "polishedBasaltSW",
			textures: ["polishedBasaltSide","polishedBasaltSide","polishedBasaltTop","polishedBasaltSideSW"],
      rotate: true, basaltSound: true
		},
    { name:"crimsonPlanks",woodSound:true },
    {
      name:"deadBush",
      solid: false,
      transparent: true,
      shadow: false,
      potCross: true,
      crossShape: true,
      drop: "stick",
      dropAmount: [0,2],
      dropSelfWhenSheared:true,
      shearDropAmount:1
    },
    { name:"stick", item:true },
    { name:"coal", item:true },
    { name:"ironIngot", item:true },
    { name:"copperIngot", item:true },
    { name:"goldIngot", item:true },
    { name:"diamond", item:true },
    { name:"lapisLazuli", item:true },
    { name:"emerald", item:true },
    { name:"copperOre", breakTime:15, drop:"rawCopper", type:"rock2", stoneSound:true },
    { name:"rawIron", item:true },
    { name:"rawCopper",item:true },
    { name:"rawGold",item:true },
    
    {
      name: "netherWart",
      transparent: true,
      shadow: false,
      solid: false,
      crop: true,
      flatIcon:true,
      iconTexture:"netherWartIcon"
		},
		{
      name: "wheat",
      transparent: true,
      shadow: false,
      solid: false,
      crop: true,
      flatIcon:true,
      iconTexture:"wheatIcon",
      drop:["wheat","wheatSeeds"]
		},
    {
      name: "lodestone",
      textures: ["lodestoneTop", "lodestoneSide"]
    },
    {
      name: "anvil",
      transparent: true,
      anvil: true,
      digSound: "block.anvil.land",
      stepSound: ["block.stone.step1", "block.stone.step2","block.stone.step3","block.stone.step4","block.stone.step5","block.stone.step6"],
      onupdate: function(x,y,z,b){
        fall(x,y,z,b)
      },
		},
    
    { name: "slime",
		  transparent: true,
		  shadow: false,
		  bounciness: 0.8,
      speedFactor: 0.5
		},
    { 
      name:"soulSoil",
      _1PixLower: true,
      speedFactor: 0.5,
    },
    { name:"blueIce", slide:0.9, glassSound: true},
    { name:"ice", slide:0.9, glassSound: true},
    { name:"packedIce", slide:0.9, glassSound: true},
    { name:"calcite" },
    {
      name:"furnace",
      textures: ["furnaceTop","furnaceTop","furnaceSide","furnaceFront","furnaceSide","furnaceSide"],
      rotate: true,
      onclick: (x,y,z) => {
        furnaceData.x = x
        furnaceData.y = y
        furnaceData.z = z
        changeScene("furnace")
        releasePointer()
      },
      stoneSound:true
    },
    {
      name:"blastFurnace",
      textures: ["blastFurnaceTop","blastFurnaceTop","blastFurnaceSide","blastFurnaceFront","blastFurnaceSide","blastFurnaceSide"],
      rotate: true
    },
    {
      name:"smoker",
      textures: ["smokerBottom","smokerTop","smokerSide","smokerFront","smokerSide","smokerSide"],
      rotate: true
    },
    {
      name:"noteBlock"
    },
    {
      name:"jukebox",
      textures: ["jukeboxTop","jukeboxSide"]
    },
    {
      name:"loom",
      textures: ["loomBottom","loomTop","loomFront","loomSide","loomSide","loomSide"],
      rotate: true
    },
    
    {
      name:"sandstone",
      textures: ["sandstoneBottom", "sandstoneTop", "sandstone"]
    },
    { name:"chiseledSandstone",
      textures: ["sandstoneBottom", "sandstoneTop","chiseledSandstone"]
    },
    { name:"cutSandstone",
      textures: ["sandstoneBottom", "sandstoneTop","cutSandstone"]
    },
    { name:"smoothSandstone", textures:"sandstoneTop" },
    { name: "DoubleTallGrass",
      solid: false,
      transparent: true,
      shadow: false,
      textures: "tallGrassTop",
      tallcrossShape: true,
		},
    {
      name:"apple",
      edible: true,
      eatWhenFull: false,
      food: 4,
      saturation: 2.4
    },
    
    {
      name:"woodenPickaxe",
      item: true,
      pickaxe: true,
      mineSpeed: 2,
      durability: 59,
      attackDamage: 2
    },
    {
      name:"stonePickaxe",
      item: true,
      pickaxe: true,
      mineSpeed: 4,
      durability: 131,
      attackDamage: 2
    },
    {
      name:"ironPickaxe",
      item: true,
      pickaxe: true,
      mineSpeed: 6,
      durability: 250,
      attackDamage: 3
    },
    {
      name:"goldenPickaxe",
      item: true,
      pickaxe: true,
      mineSpeed: 12,
      durability: 32,
      attackDamage: 4
    },
    {
      name:"diamondPickaxe",
      item: true,
      pickaxe: true,
      mineSpeed: 8,
      durability: 1561,
      attackDamage: 5
    },
    { name:"flint", item:true },
    {
      name:"mossBlock",
      breakTime:0.15,
      type: "plant2"
    },
    {
      name:"mossCarpet",
      textures: "mossBlock",
      breakTime:0.15,
      carpet: true
    },
    {
      name: "caveVines",
      solid: false,
      transparent: true,
      shadow: false,
      crossShape: true,
    },
    {
      name: "caveVinesPlant",
      solid: false,
      transparent: true,
      shadow: false,
      crossShape: true,
    },
    {
      name: "caveVinesLit",
      solid: false,
      transparent: true,
      shadow: false,
      crossShape: true,
      lightLevel: 14
    },
    {
      name: "caveVinesPlantLit",
      solid: false,
      transparent: true,
      shadow: false,
      crossShape: true,
      lightLevel: 14
    },
    
    {
      name:"sporeBlossom",
      sporeBlossom: true,
      shadow:false,
      transparent: true
		},
    {
      name: "rootedDirt",
    },
    {
      name: "hangingRoots",
      solid: false,
      transparent: true,
      shadow: false,
      crossShape: true
    },
    {
      name:"azalea",
      textures: ["azaleaTop", "azaleaSide"],
      potTex:["pottedAzaleaBushTop","pottedAzaleaBushSide"],
      azalea: true,
      transparent: true,
      potCross:true
    },
    {
      name:"floweringAzalea",
      textures: ["floweringAzaleaTop","floweringAzaleaSide"],
      potTex:["pottedFloweringAzaleaBushTop","pottedFloweringAzaleaBushSide"],
      azalea: true,
      transparent: true,
      potCross:true
    },
    
    {
      name:"sunflower",
      textures:["sunflowerBack","sunflowerFront","sunflowerTop"],
      sunflower: true,
      transparent:true,
      shadow:false,
      iconTexture: "sunflowerFront"
		},
    
    {
      name: "bucket",
      item: true,
      onuse: (x,y,z, block, replaceItem) => {
        if(blockData[block].name === "Water"){
          replaceItem(blockIds.waterBucket)
          world.setBlock(x,y,z,0)
        }
        if(blockData[block].name === "Lava"){
          replaceItem(blockIds.lavaBucket)
          world.setBlock(x,y,z,0)
        }
        if(block === blockIds.powderSnow){
          replaceItem(blockIds.powderSnowBucket)
          world.setBlock(x,y,z,0)
        }
      },
      stackSize: 1,
      allHitbox: true
    },
    {
      name: "waterBucket",
      item: true,
      onuse: (x,y,z, block, replaceItem) => {
        replaceItem(blockIds.bucket)
        var pos = getPosition()
        world.setBlock(pos[0],pos[1],pos[2],blockIds.Water)
      },
      stackSize: 1
    },
    {
      name: "lavaBucket",
      item: true,
      onuse: (x,y,z, block, replaceItem) => {
        replaceItem(blockIds.bucket)
        var pos = getPosition()
        world.setBlock(pos[0],pos[1],pos[2],blockIds.Lava)
      },
      stackSize: 1
    },
    
    {
      name: "cowSpawnEgg",
      item: true,
      onuse: (x,y,z, block, replaceItem) => {
        world.addEntity(new Cow(p2.x,p2.y,p2.z))
      }
    },
    
    {
      name:"sugarCane",
      iconTexture: "sugarCaneIcon",
      crossShape: true,
      solid: false,
      transparent: true,
      shadow: false,
    },
    
    {
      name:"woodenSword",
      item: true,
      sword: true,
      durability: 59,
      attackDamage: 4
    },
    {
      name:"stoneSword",
      item: true,
      sword: true,
      durability: 131,
      attackDamage: 5
    },
    {
      name:"ironSword",
      item: true,
      sword: true,
      durability: 250,
      attackDamage: 6
    },
    {
      name:"goldenSword",
      item: true,
      sword: true,
      durability: 32,
      attackDamage: 4
    },
    {
      name:"diamondSword",
      item: true,
      sword: true,
      durability: 1561,
      attackDamage: 7
    },
    
    { name:"azaleaLeaves",
      transparent: true,
      breakTime: 0,
      type:"plant2",
      drop: function(){
        if(rand() > 0.05){
          let r = floor(rand(2))
          if(r === 0) return "azalea"
          else return "floweringAzalea"
        }
      },
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
    },
    { name:"floweringAzaleaLeaves",
      transparent: true,
      breakTime: 0,
      type:"plant2",
      drop: function(){
        if(rand() > 0.05){
          let r = floor(rand(2))
          if(r === 0) return "azalea"
          else return "floweringAzalea"
        }
      },
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
    },
    
    {
      name: "pigSpawnEgg",
      item: true,
      onuse: (x,y,z, block, replaceItem) => {
        world.addEntity(new Pig(p2.x,p2.y,p2.z))
      }
    },
    
    {name:"tuff",breakTime:1.5},
    {name:"deepslate", textures:["deepslateTop","deepslate"],breakTime:3},
    {name:"cobbledDeepslate"},
    {name:"chiseledDeepslate",breakTime:3.5},
    {name:"polishedDeepslate",breakTime:3.5},
    {name:"deepslateTiles",breakTime:3.5},
    {name:"deepslateBricks",breakTime:3.5},
    {name:"crackedDeepslateTiles"},
    {name:"crackedDeepslateBricks"},
    {name:"deepslateCoalOre",breakTime:22.5},
    {name:"deepslateIronOre",breakTime:22.5},
    {name:"deepslateCopperOre",breakTime:22.5},
    {name:"deepslateGoldOre",breakTime:22.5},
    {name:"deepslateDiamondOre",breakTime:22.5},
    {name:"deepslateRedstoneOre",breakTime:22.5},
    {name:"deepslateEmeraldOre",breakTime:22.5},
    {name:"deepslateLapisOre",breakTime:22.5},
    
    {name:"amethystBlock", amethystSound: true},
    {name:"amethystShard",item:true},
    {name:"buddingAmethyst", amethystSound: true},
    {name:"smallAmethystBud",sideCross:true,
      solid: false,
      transparent: true,
      shadow: false,
      amethystClusterSound: true
    },
    {name:"mediumAmethystBud",sideCross:true,
      solid: false,
		  transparent: true,
		  shadow: false,
      amethystClusterSound: true
    },
    {name:"largeAmethystBud",sideCross:true,
      solid: false,
		  transparent: true,
		  shadow: false,
      amethystClusterSound: true
    },
    {name:"amethystCluster",sideCross:true,
      solid: false,
		  transparent: true,
		  shadow: false,
      amethystClusterSound: true,
      drop: "amethystShard"
    },
    
    {
      name:"snowBlock",
      textures:"snow",
      breakTime: 1,
      drop:"snowball",
      dropAmount: 4
    },
    {
      name:"snow",
      layers: true,
      transparent:true,
      drop:"snowball",
      breakTime: 0.5,
      onupdate: function(x,y,z,b){
        fall(x,y,z,b)
      },
    },
    {
      name:"powderSnow",
      solid:false,
      powder: true,
      breakTime: 0.4,
      drop:"air"
    },
    {
      name:"snowball",
      item: true
    },
    {
      name:"powderSnowBucket",
      item:true,
      onuse: (x,y,z, block, replaceItem) => {
        replaceItem(blockIds.bucket)
        var pos = getPosition()
        world.setBlock(pos[0],pos[1],pos[2],blockIds.powderSnow)
      },
      stackSize: 1
    },
    
    {
      name:"bread",
      edible: true,
      eatWhenFull: false,
      food: 6,
      saturation: 11
    },
    
    {
      name:"boneBlock",
      textures:["boneBlockTop","boneBlockSide"]
    },
    {
      name:"farmland",
      textures:["dirt","farmland","dirt"],
      _1PixLower: true
    },
    
    {
      name:"glowBerries",
      edible: true,
      eatWhenFull: false,
      food: 2,
      saturation: 0.4
    },
    
    {
      name:"hayBlock",
      textures:["hayBlockTop","hayBlockSide"],
      type:"plant2"
    },
    {
      name:"hayBlockSW",
      textures: ["hayBlockSide","hayBlockSide","hayBlockTop","hayBlockSW"],
      rotate: true,
    },
    
    {
      name:"woodenShovel",
      item: true,
      shovel: true,
      durability: 59,
      mineSpeed:2,
      attackDamage: 2
    },
    {
      name:"stoneShovel",
      item: true,
      shovel: true,
      durability: 131,
      mineSpeed:3.6,
      attackDamage: 4
    },
    {
      name:"ironShovel",
      item: true,
      shovel: true,
      durability: 250,
      mineSpeed:6,
      attackDamage: 4
    },
    {
      name:"goldenShovel",
      item: true,
      shovel: true,
      durability: 32,
      mineSpeed:12,
      attackDamage: 2
    },
    {
      name:"diamondShovel",
      item: true,
      shovel: true,
      durability: 1561,
      mineSpeed:8,
      attackDamage: 5
    },
    
    {
      name:"woodenAxe",
      item: true,
      axe: true,
      durability: 59,
      mineSpeed:2,
      attackDamage: 7,
      attackSpeed:0.8
    },
    {
      name:"stoneAxe",
      item: true,
      axe: true,
      durability: 131,
      mineSpeed:4,
      attackDamage: 9,
      attackSpeed:0.8
    },
    {
      name:"ironAxe",
      item: true,
      axe: true,
      durability: 250,
      mineSpeed:6,
      attackDamage: 9,
      attackSpeed:0.9
    },
    {
      name:"goldenAxe",
      item: true,
      axe: true,
      durability: 32,
      mineSpeed:12,
      attackDamage: 7,
      attackSpeed:1
    },
    {
      name:"diamondAxe",
      item: true,
      axe: true,
      durability: 1561,
      mineSpeed:8,
      attackDamage: 9,
      attackSpeed:1
    },
    
    {
			name: "strippedOakLog",
			textures: ["strippedOakLogTop", "strippedOakLog"],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
    {
			name: "strippedOakLogSW",
			textures: ["strippedOakLog", "strippedOakLog", "strippedOakLogTop","strippedOakLogSW"],
      breakTime:3,
      woodSound:true,
      type:"wood",
      rotate:true
		},
    {
			name: "strippedBirchLog",
			textures: ["strippedBirchLogTop", "strippedBirchLog"],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
    {
			name: "strippedBirchLogSW",
			textures: ["strippedBirchLog", "strippedBirchLog", "strippedBirchLogTop","strippedBirchLogSW"],
      breakTime:3,
      woodSound:true,
      type:"wood",
      rotate:true
		},
    {
			name: "strippedAcaciaLog",
			textures: ["strippedAcaciaLogTop", "strippedAcaciaLog"],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
    {
			name: "strippedAcaciaLogSW",
			textures: ["strippedAcaciaLog", "strippedAcaciaLog", "strippedAcaciaLogTop","strippedAcaciaLogSW"],
      breakTime:3,
      woodSound:true,
      type:"wood",
      rotate:true
		},
    {
			name: "strippedJungleLog",
			textures: ["strippedJungleLogTop", "strippedJungleLog"],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
    {
			name: "strippedJungleLogSW",
			textures: ["strippedJungleLog", "strippedJungleLog", "strippedJungleLogTop","strippedJungleLogSW"],
      breakTime:3,
      woodSound:true,
      type:"wood",
      rotate:true
		},
    {
			name: "strippedSpruceLog",
			textures: ["strippedSpruceLogTop", "strippedSpruceLog"],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
    {
			name: "strippedSpruceLogSW",
			textures: ["strippedSpruceLog", "strippedSpruceLog", "strippedSpruceLogTop","strippedSpruceLogSW"],
      breakTime:3,
      woodSound:true,
      type:"wood",
      rotate:true
		},
    {
			name: "strippedDarkOakLog",
			textures: ["strippedDarkOakLogTop", "strippedDarkOakLog"],
      breakTime:3,
      woodSound:true,
      type:"wood",
		},
    {
			name: "strippedDarkOakLogSW",
			textures: ["strippedDarkOakLog", "strippedDarkOakLog", "strippedDarkOakLogTop","strippedDarkOakLogSW"],
      breakTime:3,
      woodSound:true,
      type:"wood",
      rotate:true
		},
    
    {
      name:"boneBlockSW",
      textures:["boneBlockSide","boneBlockSide","boneBlockTop","boneBlockSW"],
      rotate:true
    },
    
    {
      name:"redMushroom",
      solid: false,
      transparent: true,
      shadow: false,
      potCross: true,
      crossShape: true,
    },
    {
      name:"brownMushroom",
      solid: false,
      transparent: true,
      shadow: false,
      potCross: true,
      crossShape: true,
    },
    {
      name:"mushroomStem",
      mushroomBlock:true
    },
    {
      name:"redMushroomBlock",
      mushroomBlock:true
    },
    {
      name:"brownMushroomBlock",
      mushroomBlock:true
    },
    
    {
      name:"mycelium",
      textures:["dirt","myceliumTop","myceliumSide"],
      type:"ground"
    },
    
    {
      name:"terracotta"
    },
    {
      name:"redTerracotta"
    },
    {
      name:"blueTerracotta"
    },
    {
      name:"cyanTerracotta"
    },
    {
      name:"grayTerracotta"
    },
    {
      name:"limeTerracotta"
    },
    {
      name:"pinkTerracotta"
    },
    {
      name:"blackTerracotta"
    },
    {
      name:"brownTerracotta"
    },
    {
      name:"greenTerracotta"
    },
    {
      name:"whiteTerracotta"
    },
    {
      name:"orangeTerracotta"
    },
    {
      name:"purpleTerracotta"
    },
    {
      name:"yellowTerracotta"
    },
    {
      name:"magentaTerracotta"
    },
    {
      name:"lightBlueTerracotta"
    },
    {
      name:"lightGrayTerracotta"
    },
    {
      name:"redGlazedTerracotta"
    },
    {
      name:"blueGlazedTerracotta"
    },
    {
      name:"cyanGlazedTerracotta"
    },
    {
      name:"grayGlazedTerracotta"
    },
    {
      name:"limeGlazedTerracotta"
    },
    {
      name:"pinkGlazedTerracotta"
    },
    {
      name:"blackGlazedTerracotta"
    },
    {
      name:"brownGlazedTerracotta"
    },
    {
      name:"greenGlazedTerracotta"
    },
    {
      name:"whiteGlazedTerracotta"
    },
    {
      name:"orangeGlazedTerracotta"
    },
    {
      name:"purpleGlazedTerracotta"
    },
    {
      name:"yellowGlazedTerracotta"
    },
    {
      name:"magentaGlazedTerracotta"
    },
    {
      name:"lightBlueGlazedTerracotta"
    },
    {
      name:"lightGrayGlazedTerracotta"
    },
    
    {
      name:"ancientDebris",
      textures:["ancientDebrisTop","ancientDebrisSide"]
    },
    
    {
      name:"wheatSeeds",
      item:true,
      useAs:function(x,y,z,block,face){
        if(!block) return
        if(face === "top" && blockData[block].name === "farmland") return "wheat"
      }
    },
    
    {
      name:"yellowStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"whiteStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"redStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"purpleStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"pinkStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"orangeStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"magentaStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"limeStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"lightGrayStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"lightBlueStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"greenStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"grayStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"cyanStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"brownStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"blueStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    {
      name:"blackStainedGlass",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      type:"glass",
      glassSound: true
    },
    
    {
      name: "yellowStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["yellowStainedGlassPaneTop","yellowStainedGlassPaneTop","yellowStainedGlass","yellowStainedGlass","yellowStainedGlassPaneSide","yellowStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "whiteStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["whiteStainedGlassPaneTop","whiteStainedGlassPaneTop","whiteStainedGlass","whiteStainedGlass","whiteStainedGlassPaneSide","whiteStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "redStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["redStainedGlassPaneTop","redStainedGlassPaneTop","redStainedGlass","redStainedGlass","redStainedGlassPaneSide","redStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "purpleStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["purpleStainedGlassPaneTop","purpleStainedGlassPaneTop","purpleStainedGlass","purpleStainedGlass","purpleStainedGlassPaneSide","purpleStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "pinkStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["pinkStainedGlassPaneTop","pinkStainedGlassPaneTop","pinkStainedGlass","pinkStainedGlass","pinkStainedGlassPaneSide","pinkStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "orangeStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["orangeStainedGlassPaneTop","orangeStainedGlassPaneTop","orangeStainedGlass","orangeStainedGlass","orangeStainedGlassPaneSide","orangeStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "magentaStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["magentaStainedGlassPaneTop","magentaStainedGlassPaneTop","magentaStainedGlass","magentaStainedGlass","magentaStainedGlassPaneSide","magentaStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "limeStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["limeStainedGlassPaneTop","limeStainedGlassPaneTop","limeStainedGlass","limeStainedGlass","limeStainedGlassPaneSide","limeStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "lightGrayStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["lightGrayStainedGlassPaneTop","lightGrayStainedGlassPaneTop","lightGrayStainedGlass","lightGrayStainedGlass","lightGrayStainedGlassPaneSide","lightGrayStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "lightBlueStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["lightBlueStainedGlassPaneTop","lightBlueStainedGlassPaneTop","lightBlueStainedGlass","lightBlueStainedGlass","lightBlueStainedGlassPaneSide","lightBlueStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "greenStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["greenStainedGlassPaneTop","greenStainedGlassPaneTop","greenStainedGlass","greenStainedGlass","greenStainedGlassPaneSide","greenStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "grayStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["grayStainedGlassPaneTop","grayStainedGlassPaneTop","grayStainedGlass","grayStainedGlass","grayStainedGlassPaneSide","grayStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "cyanStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["cyanStainedGlassPaneTop","cyanStainedGlassPaneTop","cyanStainedGlass","cyanStainedGlass","cyanStainedGlassPaneSide","cyanStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "brownStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["brownStainedGlassPaneTop","brownStainedGlassPaneTop","brownStainedGlass","brownStainedGlass","brownStainedGlassPaneSide","brownStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "blueStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["blueStainedGlassPaneTop","blueStainedGlassPaneTop","blueStainedGlass","blueStainedGlass","blueStainedGlassPaneSide","blueStainedGlassPaneSide"],
      glassSound: true
    },
    {
      name: "blackStainedGlassPane",
			transparent: true,
			shadow: false,
      breakTime: 0.3,
      pane:true,
      textures: ["blackStainedGlassPaneTop","blackStainedGlassPaneTop","blackStainedGlass","blackStainedGlass","blackStainedGlassPaneSide","blackStainedGlassPaneSide"],
      glassSound: true
    },
    
    {
      name: "cobweb",
      solid: false,
      transparent: true,
      shadow: false,
      crossShape: true,
      breakTime:20,
      noDrop:true,
      dropSelfWhenSheared:true,
      shearBreakTime:0.4
		},
    
    {
			name: "strippedCrimsonStem",
			textures: ["strippedCrimsonStemTop", "strippedCrimsonStem"],
      breakTime:2,
      stemSound:true
		},
    {
			name: "strippedCrimsonStemSW",
			textures: ["strippedCrimsonStem", "strippedCrimsonStem", "strippedCrimsonStemTop","strippedCrimsonStemSW"],
      breakTime:2,
      stemSound:true,
      rotate:true
		},
    {
			name: "strippedWarpedStem",
			textures: ["strippedWarpedStemTop", "strippedWarpedStem"],
      breakTime:2,
      stemSound:true
		},
    {
			name: "strippedWarpedStemSW",
			textures: ["strippedWarpedStem", "strippedWarpedStem", "strippedWarpedStemTop","strippedWarpedStemSW"],
      breakTime:2,
      stemSound:true,
      rotate:true
		},
    
    {
      name: "oakPressurePlate",
      textures: "oakPlanks",
      carpet: true
    },
    {
      name: "birchPressurePlate",
      textures: "birchPlanks",
      carpet: true
    },
    {
      name: "sprucePressurePlate",
      textures: "sprucePlanks",
      carpet: true
    },
    {
      name: "junglePressurePlate",
      textures: "junglePlanks",
      carpet: true
    },
    {
      name: "acaciaPressurePlate",
      textures: "acaciaPlanks",
      carpet: true
    },
    {
      name:"darkOakPressurePlate",
      textures: "darkOakPlanks",
      carpet: true
    },
    {
      name: "warpedPressurePlate",
      textures: "warpedPlanks",
      carpet: true
    },
    {
      name: "crimsonPressurePlate",
      textures: "crimsonPlanks",
      carpet: true
    },
    {
      name: "stonePressurePlate",
      textures: "stone",
      carpet: true
    },
    {
      name: "polishedBlackstonePressurePlate",
      textures: "polishedBlackstone",
      carpet: true
    },
    {
      name: "lightWeightedPressurePlate",
      textures: "goldBlock",
      carpet: true
    },
    {
      name: "heavyWeightedPressurePlate",
      textures: "ironBlock",
      carpet: true
    },
    {
      name:"oakButton",
      textures:"oakPlanks",
      button:true,
      transparent: true
    },
    {
      name:"birchButton",
      textures:"birchPlanks",
      button:true,
      transparent: true
    },
    {
      name:"acaciaButton",
      textures:"acaciaPlanks",
      button:true,
      transparent: true
    },
    {
      name:"darkOakButton",
      textures:"darkOakPlanks",
      button:true,
      transparent: true
    },
    {
      name:"jungleButton",
      textures:"junglePlanks",
      button:true,
      transparent: true
    },
    {
      name:"spruceButton",
      textures:"sprucePlanks",
      button:true,
      transparent: true
    },
    {
      name:"warpedButton",
      textures:"warpedPlanks",
      button:true,
      transparent: true
    },
    {
      name:"crimsonButton",
      textures:"crimsonPlanks",
      button:true,
      transparent: true
    },
    {
      name:"polishedBlackstoneButton",
      textures:"polishedBlackstone",
      button:true,
      transparent:true
    },
    {
      name:"copperBlock"
    },
    
    {
      name:"crackedPolishedBlackstoneBricks"
    },
    {
      name:"crackedStoneBricks"
    },
    
    {
      name:"woodenHoe",
      item: true,
      hoe: true,
      durability: 59,
      mineSpeed:2,
      attackDamage: 1,
      attackSpeed:1
    },
    {
      name:"stoneHoe",
      item: true,
      hoe: true,
      durability: 131,
      mineSpeed:4,
      attackDamage: 1,
      attackSpeed:2
    },
    {
      name:"ironHoe",
      item: true,
      hoe: true,
      durability: 250,
      mineSpeed:6,
      attackDamage: 1,
      attackSpeed:3
    },
    {
      name:"goldenHoe",
      item: true,
      hoe: true,
      durability: 32,
      mineSpeed:12,
      attackDamage: 1,
      attackSpeed:1
    },
    {
      name:"diamondHoe",
      item: true,
      hoe: true,
      durability: 1561,
      mineSpeed:8,
      attackDamage: 1,
      attackSpeed:4
    },
    
    {
      name:"podzol",
      textures:["dirt","podzolTop","podzolSide"]
    },
    
    {
      name:"rawIronBlock",
      type:"rock2",
      breakTime:25
    },
    {
      name:"rawGoldBlock",
      type:"rock3",
      breakTime:25
    },
    {
      name:"rawCopperBlock",
      type:"rock2",
      breakTime:25
    },
    
    {
      name:"netheriteScrap",
      item:true
    },
    {
      name:"netheriteIngot",
      item:true
    },
    {
      name:"netheritePickaxe",
      item: true,
      pickaxe: true,
      mineSpeed: 9,
      durability: 2031,
      attackDamage: 6
    },
    {
      name:"netheriteSword",
      item: true,
      sword: true,
      durability: 2031,
      attackDamage: 8
    },
    {
      name:"netheriteAxe",
      item: true,
      axe: true,
      durability: 2031,
      mineSpeed:9,
      attackDamage: 10,
      attackSpeed:1
    },
    {
      name:"netheriteShovel",
      item: true,
      shovel: true,
      durability: 2031,
      mineSpeed:9,
      attackDamage: 6
    },
    {
      name:"netheriteHoe",
      item: true,
      hoe: true,
      durability: 2031,
      mineSpeed:9,
      attackDamage: 1,
      attackSpeed:4
    },
    
    {
      name:"cartographyTable",
      textures: ["cartographyTableSide3","cartographyTableTop","cartographyTableSide3","cartographyTableSide1","cartographyTableSide2","cartographyTableSide3"],
      rotate:true
    },
    
    {
      name:"cake",
      textures:["cakeBottom","cakeTop","cakeSide"],
      cake:true,
      transparent:true,
      flatIcon:true,
      iconTexture:"cake"
    },
    
    {
      name:"smithingTable",
      textures:["smithingTableBottom","smithingTableTop","smithingTableFront","smithingTableSide"],
    },
    {
      name:"stonecutter",
      textures:["stonecutterBottom","stonecutterTop","stonecutterSide"],
      transparent:true,
      stonecutter:true
    },
    {
      name:"itemFrame",
      transparent:true,
      itemFrame:true
    },
    
    {
      name:"enderPearl",
      item:true,
      onuse:function(){
        world.addEntity(new EnderPearl(p.x,p.y,p.z, p.direction.x, p.direction.y, p.direction.z))
      },
      minusOnUse:true,
      useAnywhere:true
    },
    
    {
      name:"ironNugget",
      item:true
    },
    {
      name:"goldNugget",
      item:true
    },
    
    {
      name:"pumpkin",
      textures:["pumpkinSide","pumpkinTop","pumpkinSide"]
    },
    {
      name:"carvedPumpkin",
      textures:["pumpkinSide","pumpkinTop","pumpkinSide","carvedPumpkin","pumpkinSide","pumpkinSide"],
      rotate:true
    },
    {
      name:"jackOLantern",
      textures:["pumpkinSide","pumpkinTop","pumpkinSide","jackOLantern","pumpkinSide","pumpkinSide"],
      lightLevel:15,
      rotate:true
    },
    
    {
      name:"shears",
      item:true,
      shears:true
    },
    
    {
      name:"pumpkinSeeds",
      item:true
    },
    {
      name:"melonSeeds",
      item:true
    },
    
    {
      name:"melon",
      textures:["melonSide","melonTop","melonSide"],
      breakTime:1.5,
      drop:"melonSlice",
      dropAmount:[3,7]
    },
    {
      name:"melonSlice",
      item:true,
      edible: true,
      food: 2,
      saturation: 1.2
    },
    
    /*
    { name: "pigFace" },
		{ 
		  name: "steveFace",
		  textures: ["steveHeadTop", "steveFace"]
		},
    { name: "sarahFace",
      textures: ["sarahTop", "sarahFace"]
    },
    {
      name: "lexiFace",
      textures: ["lexiTop","lexiFace"]
    },
    {
      name: "sallyFace",
      textures: ["sallyTop","sallyFace"]
    },
    {
      name: "face",
      textures: ["faceTop","face"]
    },//*/
	];

	window.BLOCK_COUNT = blockData.length;
  window.console.log(BLOCK_COUNT)

  window.emptyFunc = function(){}
  var stoneDigSound = ["block.stone.dig1", "block.stone.dig2", "block.stone.dig3", "block.stone.dig4"],
      stoneStepSound = ["block.stone.step1", "block.stone.step2","block.stone.step3","block.stone.step4","block.stone.step5","block.stone.step6"],
      woodDigSound = ["block.wood.dig1", "block.wood.dig2", "block.wood.dig3", "block.wood.dig4"],
      woodStepSound = ["block.wood.step1", "block.wood.step2","block.wood.step3","block.wood.step4","block.wood.step5","block.wood.step6"],
      clothDigSound = ["block.cloth.dig1", "block.cloth.dig2", "block.cloth.dig3", "block.cloth.dig4"],
      clothStepSound = ["block.cloth.step1", "block.cloth.step2","block.cloth.step3","block.cloth.step4"],
      glassDigSound = ["block.glass.dig1", "block.glass.dig2", "block.glass.dig3"],
      nyliumDigSound = ["block.nylium.dig1", "block.nylium.dig2", "block.nylium.dig3", "block.nylium.dig4", "block.nylium.dig5", "block.nylium.dig6"],
      nyliumStepSound = ["block.nylium.step1", "block.nylium.step2","block.nylium.step3","block.nylium.step4","block.nylium.step5","block.nylium.step6"],
      stemDigSound = ["block.stem.dig1", "block.stem.dig2", "block.stem.dig3", "block.stem.dig4", "block.stem.dig5", "block.stem.dig6"],
      stemStepSound = ["block.stem.step1", "block.stem.step2","block.stem.step3","block.stem.step4","block.stem.step5","block.stem.step6"],
      basaltDigSound = ["block.basalt.dig1", "block.basalt.dig2", "block.basalt.dig3", "block.basalt.dig4", "block.basalt.dig5"],
      basaltStepSound = ["block.basalt.step1", "block.basalt.step2","block.basalt.step3","block.basalt.step4","block.basalt.step5","block.basalt.step6"],
      rootDigSound = ["block.roots.dig1", "block.roots.dig2", "block.roots.dig3", "block.roots.dig4", "block.roots.dig5", "block.roots.dig6"],
      rootStepSound = ["block.roots.step1", "block.roots.step2","block.roots.step3","block.roots.step4","block.roots.step5","block.roots.step6"],
      amethystPlaceSound = ["block.amethyst.place1","block.amethyst.place2","block.amethyst.place3","block.amethyst.place4"],
      amethystDigSound = ["block.amethyst.dig1","block.amethyst.dig2","block.amethyst.dig3","block.amethyst.dig4"],
      amethystStepSound = (function(){var arr=[]; for(var i=0; i<14; i++){arr.push("block.amethyst.step"+(i+1))};return arr})(),
      amethystClusterPlaceSound = ["block.amethyst_cluster.place1", "block.amethyst_cluster.place2", "block.amethyst_cluster.place3", "block.amethyst_cluster.place4"],
      amethystClusterDigSound = ["block.amethyst_cluster.dig1", "block.amethyst_cluster.dig2", "block.amethyst_cluster.dig3", "block.amethyst_cluster.dig4"]
	// Set defaults on blockData
	for (let i = 1; i < BLOCK_COUNT; ++i) {
		const data = blockData[i];
		data.id = i;

		if ( !("textures" in data) ) {
			data.textures = new Array(6).fill(data.name);
		} else if (typeof data.textures === "string") {
			data.textures = new Array(6).fill(data.textures);
		} else {
			const { textures } = data;

			if (textures.length === 3) {
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
			} else if (textures.length === 2) {
				// Top and bottom are the first texture, sides are the second.
				textures[2] = textures[1];
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
				textures[1] = textures[0];
			}else if(textures.length === 4){
        textures[4] = textures[5] = textures[3]
        textures[3] = textures[2]
      }
		}
    for(let t = 0; t<data.textures.length; t++){
      if(!textures[data.textures[t]]){
        window.console.log("Missing texture for "+data.textures[t])
        data.textures[t] = "error"
      }
    }

		data.transparent = data.transparent || false

		data.shadow = data.shadow !== undefined ? data.shadow	: true

		data.lightLevel = data.lightLevel || 0
    
    data.onupdate = data.onupdate || emptyFunc
    
    if(data.solid === undefined)data.solid = true
    
    data.breakTime = data.breakTime ? data.breakTime*1000 : 0.05*1000 //time for breaking
    
    if(data.dropAmount === undefined) data.dropAmount = 1
    
    if(data.item || data.edible || data.crossShape || data.tallcrossShape || data.sideCross || data.ladder || data.torch || data.door || data.lantern || data.chain || data.sunflower || data.pane) data.flatIcon = true
    if(data.door) data.iconTexture = data.name
    
    if(data.liquid) data.noHitbox = true
    
    if(!data.stackSize)data.stackSize = 64
    if(data.pickaxe){
      data.stackSize = 1
      data.attackTime = 20/1.2
    }
    if(data.sword){
      data.stackSize = 1
      data.attackTime = 20/1.6
    }
    if(data.shovel){
      data.stackSize = 1
      data.attackTime = 20/1
    }
    if(data.axe){
      data.stackSize = 1
    }
    
    if(data.attackSpeed) data.attackTime = 20/data.attackSpeed
    
    if(data.stoneSound){
      data.digSound = stoneDigSound
      data.stepSound = stoneStepSound
    }
    if(data.woodSound){
      data.digSound = woodDigSound
      data.stepSound = woodStepSound
    }
    if(data.clothSound){
      data.digSound = clothDigSound
      data.stepSound = clothStepSound
    }
    if(data.glassSound){
      data.digSound = glassDigSound
      data.placeSound = stoneDigSound
    }
    if(data.nyliumSound){
      data.digSound = nyliumDigSound
      data.stepSound = nyliumStepSound
    }
    if(data.stemSound){
      data.digSound = stemDigSound
      data.stepSound = stemStepSound
    }
    if(data.basaltSound){
      data.digSound = basaltDigSound
      data.stepSound = basaltStepSound
    }
    if(data.rootSound){
      data.digSound = rootDigSound
      data.stepSound = rootStepSound
    }
    if(data.amethystSound){
      data.placeSound = amethystPlaceSound
      data.digSound = amethystDigSound
      data.stepSound = amethystStepSound
    }
    if(data.amethystClusterSound){
      data.placeSound = amethystClusterPlaceSound
      data.digSound = amethystClusterDigSound
    }
	}
  
  let textureIds = {}
  let idx = -1
  for(var i in textures){
    idx ++
    textureIds[i] = idx
  }
  window.textureIds = textureIds
  
  // survival inventory
  let invItems = [1];
  let invLength = 13*9;
  for(let i=0; i<invLength; i++){
    if(!invItems[i]){
      invItems.push({id:0,amount:64})
    }
  }
  //add something to inventory
  function newInvItem(id){
    //look for empty slot
    for(let i=0; i<inventory.hotbar.length; i++){
      if(!inventory.hotbar[i].id){
        inventory.hotbar[i] = {id:id, amount:1, animation:1.5}
        return true
      }
      if(inventory.hotbar[i].id === id && inventory.hotbar[i].amount < blockData[inventory.hotbar[i].id].stackSize){
        inventory.hotbar[i].amount ++;
        inventory.hotbar[i].animation = 1.5
        return true
      }
    }
    for(let i=0; i<invLength; i++){
      if(!(invItems[i] && invItems[i].id)){
        invItems[i] = {id:id, amount:1}
        return true
      }
      if(invItems[i].id === id && invItems[i].amount < blockData[invItems[i].id].stackSize){
        invItems[i].amount ++;
        return true
      }
    }
    return false
  }
  
  const crafts = {
    "oakLog": {name:"oakPlanks", amount:4, shapeless: true},
    "acaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
    "birchLog": {name:"birchPlanks", amount:4, shapeless: true},
    "darkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
    "jungleLog": {name:"junglePlanks", amount:4, shapeless: true},
    "spruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
    "oakPlanks,air,air,oakPlanks": {name:"stick", amount:4},
    "acaciaPlanks,air,air,acaciaPlanks": {name:"stick", amount:4},
    "birchPlanks,air,air,birchPlanks": {name:"stick", amount:4},
    "darkOakPlanks,air,air,darkOakPlanks": {name:"stick", amount:4},
    "junglePlanks,air,air,junglePlanks": {name:"stick", amount:4},
    "sprucePlanks,air,air,sprucePlanks": {name:"stick", amount:4},
    "oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"oakDoor", amount:3},
    "acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"acaciaDoor", amount:3},
    "birchPlanks,birchPlanks,air,birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"birchDoor", amount:3},
    "darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks":{name:"darkOakDoor", amount:3},
    "junglePlanks,junglePlanks,air,junglePlanks,junglePlanks,air,junglePlanks,junglePlanks":{name:"jungleDoor", amount:3},
    "sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks":{name:"spruceDoor", amount:3},
    "warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks":{name:"warpedDoor", amount:3},
    "crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air":{name:"crimsonDoor",amount:3},
    "ironIngot,ironIngot,air,ironIngot,ironIngot,air,ironIngot,ironIngot,air":{name:"ironDoor",amount:3},
    "oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"oakTrapdoor", amount:2},
    "birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks":{name:"birchTrapdoor", amount:2},
    "darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks":{name:"darkOakTrapdoor", amount:2},
    "junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks":{name:"jungleTrapdoor", amount:2},
    "sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks":{name:"spruceTrapdoor", amount:2},
    "acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks":{name:"acaciaTrapdoor", amount:2},
    "warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks":{name:"warpedTrapdoor", amount:2},
    "crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks":{name:"crimsonTrapdoor", amount:2},
    "ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironTrapdoor", amount:2},
    "redWool,redWool,redWool,oakPlanks,oakPlanks,oakPlanks":{name:"redBed", amount:3},
    "oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"craftingTable"},
    "birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"craftingTable"},
    "darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks":{name:"craftingTable"},
    "acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"craftingTable"},
    "sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks":{name:"craftingTable"},
    "junglePlanks,junglePlanks,air,junglePlanks,junglePlanks":{name:"craftingTable"},
    "warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks":{name:"craftingTable"},
    "crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks":{name:"craftingTable"},
    "coal,air,air,stick":{name:"torch",amount:4},
    "coal,coal,coal,coal,coal,coal,coal,coal,coal":{name:"coalBlock"},
    "ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironBlock"},
    "goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldBlock"},
    "diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond":{name:"diamondBlock"},
    "lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli":{name:"lapisBlock"},
    "emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald":{name:"emeraldBlock"},
    "oakPlanks,oakPlanks,oakPlanks,air,stick,air,air,stick":{name:"woodenPickaxe"},
    "cobblestone,cobblestone,cobblestone,air,stick,air,air,stick":{name:"stonePickaxe"},
    "ironIngot,ironIngot,ironIngot,air,stick,air,air,stick":{name:"ironPickaxe"},
    "goldIngot,goldIngot,goldIngot,air,stick,air,air,stick":{name:"goldenPickaxe"},
    "diamond,diamond,diamond,air,stick,air,air,stick":{name:"diamondPickaxe"},
    "ironIngot,air,air,air,flint": {name:"flintAndSteel"},
    "air,oakPlanks,air,air,oakPlanks,air,air,stick": {name:"woodenSword"},
    "air,cobblestone,air,air,cobblestone,air,air,stick": {name:"stoneSword"},
    "air,ironIngot,air,air,ironIngot,air,air,stick": {name:"ironSword"},
    "air,goldIngot,air,air,goldIngot,air,air,stick": {name:"goldenSword"},
    "air,diamond,air,air,diamond,air,air,stick": {name:"diamondSword"},
    "air,air,air,snowBlock,snowBlock,snowBlock": {name:"snow", amount:6},
    "snowball,snowball,air,snowball,snowball": {name:"snowBlock"},
    "ironIngot,air,ironIngot,air,ironIngot":{name:"bucket"},
    "cobblestone,cobblestone,cobblestone,cobblestone,air,cobblestone,cobblestone,cobblestone,cobblestone":{name:"furnace"},
    "wheat,wheat,wheat":{name:"bread"},
    "oakPlanks,air,air,stick,air,air,stick":{name:"woodenShovel"},
    "cobblestone,air,air,stick,air,air,stick":{name:"stoneShovel"},
    "ironIngot,air,air,stick,air,air,stick":{name:"ironShovel"},
    "goldIngot,air,air,stick,air,air,stick":{name:"goldenShovel"},
    "diamond,air,air,stick,air,air,stick":{name:"diamondShovel"},
    "oakPlanks,oakPlanks,air,oakPlanks,stick,air,air,stick":{name:"woodenAxe"},
    "cobblestone,cobblestone,air,cobblestone,stick,air,air,stick":{name:"stoneAxe"},
    "ironIngot,ironIngot,air,ironIngot,stick,air,air,stick":{name:"ironAxe"},
    "goldIngot,goldIngot,air,goldIngot,stick,air,air,stick":{name:"goldenAxe"},
    "diamond,diamond,air,diamond,stick,air,air,stick":{name:"diamondAxe"},
    "birchPlanks,birchPlanks":{name:"birchPressurePlate",shapeless:true},
    "oakPlanks,oakPlanks":{name:"oakPressurePlate",shapeless:true},
    "junglePlanks,junglePlanks":{name:"junglePressurePlate",shapeless:true},
    "sprucePlanks,sprucePlanks":{name:"sprucePressurePlate",shapeless:true},
    "darkOakPlanks,darkOakPlanks":{name:"darkOakPressurePlate",shapeless:true},
    "acaciaPlanks,acaciaPlanks":{name:"acaciaPressurePlate",shapeless:true},
    "warpedPlanks,warpedPlanks":{name:"warpedPressurePlate",shapeless:true},
    "crimsonPlanks,crimsonPlanks":{name:"crimsonPressurePlate",shapeless:true},
    "stone,stone":{name:"stonePressurePlate",shapeless:true},
    "polishedBlackstone,polishedBlackstone":{name:"polishedBlackstone",shapeless:true},
    "goldIngot,goldIngot":{name:"lightWeightedPressurePlate",shapeless:true},
    "ironIngot,ironIngot":{name:"heavyWeightedPressurePlate",shapeless:true},
    "strippedOakLog": {name:"oakPlanks", amount:4, shapeless: true},
    "strippedAcaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
    "strippedBirchLog": {name:"birchPlanks", amount:4, shapeless: true},
    "strippedDarkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
    "strippedJungleLog": {name:"junglePlanks", amount:4, shapeless: true},
    "strippedSpruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
    "warpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
    "crimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
    "strippedWarpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
    "strippedCrimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
    "warpedPlanks,air,air,warpedPlanks": {name:"stick", amount:4},
    "crimsonPlanks,air,air,crimsonPlanks": {name:"stick", amount:4},
    "stone":{name:"stoneButton", shapeless: true},
    "oakPlanks":{name:"oakButton", shapeless: true},
    "birchPlanks":{name:"birchButton", shapeless: true},
    "darkOakPlanks":{name:"darkOakButton", shapeless: true},
    "acaciaPlanks":{name:"acaciaButton", shapeless: true},
    "sprucePlanks":{name:"spruceButton", shapeless: true},
    "junglePlanks":{name:"jungleButton", shapeless: true},
    "warpedPlanks":{name:"warpedButton", shapeless: true},
    "crimsonPlanks":{name:"crimsonButton", shapeless: true},
    "polishedBlackstone":{name:"polishedBlackstoneButton", shapeless:true},
    "ironBlock": {name:"ironIngot",amount:9,shapeless:true},
    "goldBlock": {name:"goldIngot",amount:9,shapeless:true},
    "coalBlock": {name:"coal",amount:9,shapeless:true},
    "emeraldBlock": {name:"emerald",amount:9,shapeless:true},
    "diamondBlock": {name:"diamond",amount:9,shapeless:true},
    "copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot":{name:"copperBlock"},
    "copperBlock": {name:"copperIngot",amount:9,shapeless:true},
    "oakPlanks,oakPlanks,air,air,stick,air,air,stick":{name:"woodenHoe"},
    "cobblestone,cobblestone,air,air,stick,air,air,stick":{name:"stoneHoe"},
    "ironIngot,ironIngot,air,air,stick,air,air,stick":{name:"ironHoe"},
    "goldIngot,goldIngot,air,air,stick,air,air,stick":{name:"goldenHoe"},
    "diamond,diamond,air,air,stick,air,air,stick":{name:"diamondHoe"},
    "rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron":{name:"rawIronBlock"},
    "rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold":{name:"rawGoldBlock"},
    "rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper":{name:"rawCopperBlock"},
    "rawIronBlock":{name:"rawIron",amount:9,shapeless:true},
    "rawGoldBlock":{name:"rawGold",amount:9,shapeless:true},
    "rawCopperBlock":{name:"rawCopper",amount:9,shapeless:true},
    "netheriteScrap,netheriteScrap,netheriteScrap,netheriteScrap,goldIngot,goldIngot,goldIngot,goldIngot":{name:"netheriteIngot"},
    "netheriteIngot,netheriteIngot,netheriteIngot,air,stick,air,air,stick":{name:"netheritePickaxe"},
    "netheriteIngot,air,air,netheriteIngot,air,air,stick":{name:"netheriteSword"},
    "netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteShovel"},
    "netheriteIngot,netheriteIngot,air,netheriteIngot,stick,air,air,stick":{name:"netheriteAxe"},
    "netheriteIngot,netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteHoe"},
    "netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot":{name:"netheriteBlock"},
    "netheriteBlock":{name:"netheriteIngot",amount:9},
    "wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat":{name:"hayBlock"},
    "hayBlock":{name:"wheat",amount:9,shapeless:true},
    "ironIngot":{name:"ironNugget",amount:9,shapeless:true},
    "goldIngot":{name:"goldNugget",amount:9,shapeless:true},
    "ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget":{name:"ironIngot"},
    "goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldIngot"},
    "ironNugget,ironNugget,ironNugget,ironNugget,torch,ironNugget,ironNugget,ironNugget,ironNugget":{name:"lantern"},
    "stick,air,stick,stick,stick,stick,stick,air,stick":{name:"ladder",amount:3},
    "ironNugget,air,air,ironIngot,air,air,ironNugget":{name:"chain"},
    "stone,stone,air,stone,stone":{name:"stoneBricks",amount:4},
    "stoneBricks,vine":{name:"mossyStoneBricks",shapeless:true},
    "cobblestone,vine":{name:"mossyCobble",shapeless:true},
    "chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,netheriteIngot,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks":{name:"lodestone"},
    "oakPlanks,oakPlanks,oakPlanks,oakPlanks,redstoneDust,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"noteBlock"},
    "oakPlanks,oakPlanks,oakPlanks,oakPlanks,diamond,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"jukebox"},
    "ironIngot,ironIngot,ironIngot,ironIngot,furnace,ironIngot,smoothStone,smoothStone,smoothStone":{name:"blastFurnace"},
    "air,oakLog,air,oakLog,furnace,oakLog,air,oakLog":{name:"smoker"},
    "carvedPumpkin,torch":{name:"jackOLantern",shapeless:true},
    "air,ironIngot,air,ironIngot":{name:"shears"},
    "melonSlice":{name:"melonSeeds",shapeless:true},
    "melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice":{name:"melon"},
  }
  
  function shapelessCraft(craft) {
    let arr2 = craft;
    arr2.sort(function(a, b) {
      return a - b;
    });
    let arr = [];
    for(let i in crafts) {
      if(!crafts[i].shapeless) continue;

      arr = i.split(",");
      arr.sort(function(a, b) {
        return a - b;
      });
      let comp = arr.map(num => Number(num));
      if(arrayValues(comp,arr2)) {
        return i;
      }
    }
  }
  
  var breakTypes = {
    plant: "axe",
    wood: "axe",
    metal1: "pickaxe",
    metal2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
    metal3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
    metal4: ["diamondPickaxe","netheritePickaxe"],
    rock1: "pickaxe",
    rock2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
    rock3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
    rock4: ["diamondPickaxe","netheritePickaxe"],
    ground: "shovel",
    plant2: "hoe"
  }
  var handBreakable = [
    "plant","wood","plant2","ground"
  ]
  var allPickaxes = ["woodenPickaxe","stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe","goldenPickaxe"]
  var allShovels = ["woodenShovel","stoneShovel","ironShovel","diamondShovel","netheriteShovel","goldenShovel"]
  for(var b in breakTypes){
    var t = breakTypes[b]
    if(t === "pickaxe"){
      breakTypes[b] = allPickaxes
    }
    if(t === "shovel"){
      breakTypes[b] = allShovels
    }
  }
  
  var smelts = {
    rawIron: {name:"ironIngot", time:200, xp:0.7},
    rawCopper: {name:"copperIngot", time:200, xp:0.7},
    rawGold: {name:"goldIngot", time:200, xp:1},
    sand: {name:"glass",time:200,xp:0.1, furnace:true},//furnace propertie means it can only be smelted in furnace
    cobblestone: {name:"stone",time:200,xp:0.1, furnace:true},
    stone: {name:"smoothStone", time:200, xp:0.1, furnace:true},
    stoneBricks: {name:"crackedStoneBricks",time:200,xp:0.1, furnace:true}
  }
  var smeltFuel = { //time is in seconds
    oakLog: {time:15},
    coal: {time:80},
    oakPlanks: {time:15},
    stick: {time:5},
  }
  
  var achievementTypes = {
    "Taking Inventory":{
      score: 10,
      description:"Open your inventory"
    },
    "Getting Wood":{
      score:10,
      description:"Punch a tree until a block of wood pops out."
    },
    "Benchmaking":{
      score:10,
      description:"Craft a Crafting Table with four blocks of wooden planks."
    },
    "Time to Mine!":{
      score:10,
      description:"Use planks and sticks to make a pickaxe."
    },
    "Getting an Upgrade":{
      score:15,
      description:"Construct a better pickaxe."
    },
    "Bake Bread":{
      score:15,
      description:"Turn wheat into bread."
    },
    "Time to Strike!":{
      score:10,
      description:"Use planks and sticks to make a sword."
    },
    "DIAMONDS!":{
      score:20,
      description:"Acquire diamonds with your iron tools."
    },
    "Diamonds to you!":{ //how is this possible to code???
      score:15,
      description:"Throw diamonds at another player."
    },
    "Time to Farm!":{
      score:10,
      description:"Make a Hoe."
    }
  }
  for(var a in achievementTypes){
    achievementTypes[a].name = a
  }
  var achievments = []
  function achievment(name){
    var a = achievementTypes[name]
    if(!a) return console.log("No such achievment: "+name)
    if(achievments.includes(name)) return
    if(cheats) return
    achievments.push(name)
    sideMessage("Achievment made: "+a.name, a.description)
    if(multiplayer) send({type:"achievment",data:a.name})
  }
  
	// implementation of xxHash
	const {
		seedHash,
		hash
	} = (() => {
		// closure around mutable `seed`; updated via calls to `seedHash`

		let seed = Math.random() * 2100000000 | 0;

		const PRIME32_2 = 1883677709;
		const PRIME32_3 = 2034071983;
		const PRIME32_4 = 668265263;
		const PRIME32_5 = 374761393;

		const seedHash = s => {
			seed = s | 0;
		}

		const { imul } = Math;

		const hash = (x, y) => {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += imul(x, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(y, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};

		return {
			seedHash,
			hash
		};
	})();

	const win = window.parent;
	const doc = document;
	const { console } = win;
	win.world = undefined;
	let worldSeed;
  win.dimensions = null
  function setSeed(seed){
    worldSeed = seed
		seedHash(worldSeed)
		caveNoise = openSimplexNoise(worldSeed)
		noiseProfile.noiseSeed(worldSeed)
  }

	class Marsaglia {
		// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c

		nextInt() {
			const { z, w } = this;

			this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
			this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;

			return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
		}

		nextDouble() {
			const i = this.nextInt() / 4294967296;

			const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0

			return is_less_than_zero + i;
		}

		constructor(i1, i2) { // better param names
			this.z = (i1 | 0) || 362436069;
			this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
		}
	}

	// The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls

	const {
		randomSeed,
		random
	} = (() => {
		// closure around mut `currentRandom`

		let currentRandom = null;

		const randomSeed = seed => {
			currentRandom = new Marsaglia(seed);
		};

		const random = (min, max) => {
			if (!max) {
				if (min) {
					max = min;
					min = 0;
				} else {
					min = 0;
					max = 1;
				}
			}

			return currentRandom.nextDouble() * (max - min) + min;
		};

		return {
			randomSeed,
			random
		};
	})();

	class PerlinNoise {
		// http://www.noisemachine.com/talk1/17b.html
		// http://mrl.nyu.edu/~perlin/noise/

		static grad3d(i, x, y, z) {
			const h = i & 15; // convert into 12 gradient directions

			const u = h < 8
				? x
				: y;

			const v = h < 4
				? y
				: h === 12 || h === 14
					? x
					: z;

			return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
		}

		static grad2d(i, x, y) {
			const v = (i & 1) === 0
				? x
				: y;

			return (i & 2) === 0
				? -v
				: v;
		}

		static grad1d(i, x) {
			return (i & 1) === 0
				? -x
				: x;
		}

		static lerp(t, a, b) {
			return a + t * (b - a);
		}

		// end of statics

		// permutation
		perm = new Uint8Array(0x200);

		// prototype functions:
		noise3d(x, y, z) {
			const { floor } = Math;

			const X = floor(x) & 0xff;
			const Y = floor(y) & 0xff;
			const Z = floor(z) & 0xff;

			x -= floor(x);
			y -= floor(y);
			z -= floor(z);

			const fx = (3 - 2 * x) * x * x;
			const fy = (3 - 2 * y) * y * y;
			const fz = (3 - 2 * z) * z * z;

			const { perm } = this;

			const p0 = perm[X] + Y;
			const p00 = perm[p0] + Z;
			const p01 = perm[p0 + 1] + Z;
			const p1 = perm[X + 1] + Y;
			const p10 = perm[p1] + Z;
			const p11 = perm[p1 + 1] + Z;

			const { lerp, grad3d } = PerlinNoise;

			return lerp(
				fz,
				lerp(
					fy,
					lerp(
						fx,
						grad3d(perm[p00], x, y, z),
						grad3d(perm[p10], x - 1, y, z)
					),
					lerp(
						fx,
						grad3d(perm[p01], x, y - 1, z),
						grad3d(perm[p11],x - 1, y - 1, z)
					)
				),
				lerp(
					fy,
					lerp(
						fx,
						grad3d(perm[p00 + 1], x, y, z - 1),
						grad3d(perm[p10 + 1], x - 1, y, z - 1)
					),
					lerp(
						fx,
						grad3d(perm[p01 + 1], x, y - 1, z - 1),
						grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
					)
				)
			);
		}

		noise2d(x, y) {
			const { floor } = Math;

			const X = floor(x) & 0xff;
			const Y = floor(y) & 0xff;

			x -= floor(x);
			y -= floor(y);

			const { perm } = this;
			const fx = (3 - 2 * x) * x * x;
			const fy = (3 - 2 * y) * y * y;
			const p0 = perm[X] + Y;
			const p1 = perm[X + 1] + Y;

			const { lerp, grad2d } = PerlinNoise;

			return lerp(
				fy,
				lerp(
					fx,
					grad2d(
						perm[p0],
						x,
						y
					),
					grad2d(
						perm[p1],
						x - 1,
						y
					)
				),
				lerp(
					fx,
					grad2d(
						perm[p0 + 1],
						x,
						y - 1
					),
					grad2d(
						perm[p1 + 1],
						x - 1,
						y - 1
					)
				)
			);
		}

		noise1d(x) {
			const { floor } = Math;

			const X = floor(x) & 0xff;

			x -= floor(x);

			const fx = (3 - 2 * x) * x * x;

			const { lerp, grad1d } = PerlinNoise;

			return lerp(
				fx,
				grad1d(perm[X], x),
				grad1d(perm[X + 1], x - 1)
			);
		}

		constructor(seed) {
			if (seed === undefined) {
				throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
			}

			const rnd = new Marsaglia(seed);

			// generate permutation
			const { perm } = this;

			// fill 0x0..0x100
			for (let i = 0; i < 0x100; ++i) {
				perm[i] = i;
			}

			for (let i = 0; i < 0x100; ++i) {
				const j = rnd.nextInt() & 0xFF;
				const t = perm[j];
				perm[j] = perm[i];
				perm[i] = t;
			}

			// copy to avoid taking mod in perm[0]
			// copies from first half of array, into the second half
			perm.copyWithin(0x100, 0x0, 0x100);
		}
	}

	const noiseProfile = {
		generator: undefined,
		octaves: 4,
		fallout: 0.5,
		seed: undefined,
		noiseSeed(seed) {
			this.seed = seed;
			this.generator = new PerlinNoise(noiseProfile.seed);
		},
		noise(x, y, z) {
			const { generator, octaves, fallout } = (this || noiseProfile);

			let effect = 1,
				k = 1,
				sum = 0;

			for (let i = 0; i < octaves; ++i) {
				effect *= fallout;

				const k = 1 << i;

				let temp;
				switch (arguments.length) {
					case 1: {
						temp = generator.noise1d(k * x);
						break;
					} case 2: {
						temp = generator.noise2d(k * x, k * y);
						break;
					} case 3: {
						temp = generator.noise3d(k * x, k * y, k * z);
						break;
					}
				}

				sum += effect * (1 + temp) / 2;
			}

			return sum;
		}
	};
  const noise = noiseProfile.noise

	let caveNoise;
	// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
	function openSimplexNoise(clientSeed) {
		const SQ4 = 2
		const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) }
		const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) }
		const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) }
		const NORM_3D = 1.0 / 206.0
		const SQUISH_3D = 1 / 3
		const STRETCH_3D = -1 / 6
		var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
		const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
		var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) }
		var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
		const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a }
		const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} }

		function shuffleSeed(seed,count){
			seed = seed * 1664525 + 1013904223 | 0
			count -= 1
			return count > 0 ? shuffleSeed(seed, count) : seed
		}
		const types = {
			_3D : {
				base : base3D,
				squish : SQUISH_3D,
				dimensions : 3,
				pD : p3D,
				lookup : lookupPairs3D,
			}
		}

		function createContribution(type, baseSet, index) {
			var i = 0
			const multiplier = baseSet[index ++]
			const c = { next : undefined }
			while(i < type.dimensions) {
				const axis = ("xyzw")[i]
				c[axis + "sb"] = baseSet[index + i]
				c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
			}
			return c
		}

		function createLookupPairs(lookupArray, contributions){
			var i
			const a = lookupArray()
			const res = new Map()
			for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
			return res
		}

		function createContributionArray(type) {
			const conts = []
			const d = type.dimensions
			const baseStep = d * d
			var k, i = 0
			while (i < type.pD.length) {
				const baseSet = type.base[type.pD[i]]
				let previous, current
				k = 0
				do {
					current = createContribution(type, baseSet, k)
					if (!previous) { conts[i / baseStep] = current; }
					else { previous.next = current; }
					previous = current
					k += d + 1
				} while(k < baseSet.length)

				current.next = createContribution(type, type.pD, i + 1)
				if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
				if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
				i += baseStep
			}
			const result = [conts, createLookupPairs(type.lookup, conts)]
			type.base = undefined
			type.lookup = undefined
			return result
		}

		let temp = createContributionArray(types._3D)
		const contributions3D = temp[0], lookup3D = temp[1]
		const perm = new Uint8Array(256)
		const perm3D = new Uint8Array(256)
		const source = new Uint8Array(setOf(256))
		var seed = shuffleSeed(clientSeed, 3)
		doFor(256, function(i) {
			i = 255 - i
			seed = shuffleSeed(seed, 1)
			var r = (seed + 31) % (i + 1)
			r += r < 0 ? i + 1 : 0
			perm[i] = source[r]
			perm3D[i] = (perm[i] % 24) * 3
			source[r] = source[i]
		})
		base3D = undefined
		lookupPairs3D = undefined
		p3D = undefined

		return function(x, y, z) {
			const pD = perm3D
			const p = perm
			const g = gradients3D
			const stretchOffset = (x + y + z) * STRETCH_3D
			const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
			const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
			const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
			const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
			const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
			const inSum = xins + yins + zins
			var c = lookup3D.get(
				(yins - zins + 1) |
				((xins - yins + 1) << 1) |
				((xins - zins + 1) << 2) |
				(inSum << 3) |
				((inSum + zins) << 5) |
				((inSum + yins) << 7) |
				((inSum + xins) << 9)
			)
			var i, value = 0
			while (c !== undefined) {
				const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
				let attn = 2 - dx * dx - dy * dy - dz * dz
				if (attn > 0) {
					i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF]
					attn *= attn
					value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
				}
				c = c.next
			}
			return value * NORM_3D + 0.5
		}
	}
  
  //copied from https://gist.github.com/bzdgn/d722c961f45d97ea8efc6cef3aa39e76
  function nodeRotationX(node, theta) {
				var cosTheta = Math.cos(theta);
				var sinTheta = Math.sin(theta);
				
				var y = node.y;
				var z = node.z;
				
				node.y = y * cosTheta - z * sinTheta;
				node.z = y * sinTheta + z * cosTheta;
	}
  function nodeRotationY(node, theta) {
				var cosTheta = Math.cos(theta);
				var sinTheta = Math.sin(theta);
				
				var x = node.x;
				var z = node.z;
				
				node.x = x * cosTheta - z * sinTheta;
				node.z = x * sinTheta + z * cosTheta;
	}
  var node = {x:0, y:0, z:0}
  function getRotation(rotX, rotY){
    //node.x = -sin(rotY) * cos(rotX)
    //node.y = sin(rotX)
    //node.z = cos(rotY) * cos(rotX)
    node.x = 0;node.y=0;node.z=1
    nodeRotationX(node,rotX+Math.PI)
    node.z = -node.z
    nodeRotationY(node,rotY)
    
    return node
  }
  win.getRotation = getRotation

	class PVector {
		constructor(x, y, z) {
			this.x = x
			this.y = y
			this.z = z
		}
		set(x, y, z) {
			if (y === undefined) {
				this.x = x.x
				this.y = x.y
				this.z = x.z
			} else {
				this.x = x
				this.y = y
				this.z = z
			}
		}
		normalize() {
			let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
			this.x /= mag
			this.y /= mag
			this.z /= mag
		}
		add(v) {
			this.x += v.x
			this.y += v.y
			this.z += v.z
		}
		mult(m) {
			this.x *= m
			this.y *= m
			this.z *= m
		}
	}
	let fill = function(r, g, b, a) {
		if (g === undefined) {
			g = r
			b = r
		}
    a = a || a === 0 ? a : 100
		ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ", "+a+"%)"
	}
	let stroke = function(r, g, b) {
		if (g === undefined) {
			g = r
			b = r
		}
		ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let line = function(x1, y1, x2, y2) {
		ctx.moveTo(x1, y1)
		ctx.lineTo(x2, y2)
	}
  let ellipse = function(x,y,w,h){
	    if(ctx.ellipse){
	        ctx.ellipse(x,y,w,h,0, 0,Math.PI*2)
	    }
	}
	function text(txt, x, y, h) {
		h = h || 0

		let lines = txt.split("\n")
		for (let i = 0; i < lines.length; i++) {
      if(lines[i].includes("")){
        let middle = ctx.measureText(lines[i].replace(/./g, "")).width
        let m2 = middle / 2
        let codes = lines[i].split("")
        ctx.fillText(codes[0], x-m2, y + h * i)
        let tx = ctx.measureText(codes[0]).width
        for(var j=1; j<codes.length; j++){
          let str = codes[j]
          ctx.fillStyle = colors[str.substring(0,1)]
          str = str.substring(1)
          ctx.fillText(str, x+tx-m2, y+h*i)
          tx += ctx.measureText(str).width
        }
      }else{
        ctx.fillText(lines[i], x, y + h * i)
      }
		}
	}
	function textSize(size) {
		ctx.font = size + 'px VT323' // VT323
	}
	let strokeWeight = function(num) {
		ctx.lineWidth = num
	}
  function map(v, min, max, min2, max2){
    return min2 + (max2 - min2) * ((v - min) / (max - min));
  }
  function dist2(x,y,x2,y2){
    let xDist = x - x2
    let yDist = y - y2
    return sqrt((xDist*xDist)+(yDist*yDist))
  }
  function dist3(x,y,z,x2,y2,z2){
    let xDist = x - x2
    let yDist = y - y2
    let zDist = z - z2
    return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
  }
  win.dist2 = dist2; win.dist3 = dist3
	const ARROW = "arrow"
	const HAND = "pointer"
	let cursor = function(type) {
		canvas.style.cursor = type
	}
	randomSeed(Math.random() * 10000000 | 0)

	async function createDatabase() {
		return await new Promise(async (resolve, reject) => {
			let request = window.indexedDB.open("MineKhan", 1)

			request.onupgradeneeded = function(event) {
				let DB = event.target.result
				// Worlds will contain and ID containing the timestamp at which the world was created, a "saved" timestamp,
				// and a "data" string that's identical to the copy/paste save string
				let store = DB.createObjectStore("worlds", { keyPath: "id" })
				store.createIndex("id", "id", { unique: true })
				store.createIndex("data", "data", { unique: false })
			}

			request.onsuccess = function(e) {
				resolve(request.result)
			}

			request.onerror = function(e) {
				console.error(e)
				reject(e)
			}
		})
	}
	async function loadFromDB(id) {
		return await new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = id ? store.get(id) : store.getAll()
			req.onsuccess = function(e) {
				resolve(req.result)
				db.close()
			}
			req.onerror = function(e) { 
				resolve(null)
				db.close()
			}
		})
	}
	async function saveToDB(id, data) {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = store.put({ id: id, data: data })
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(e)
			}
		})
	}
	async function deleteFromDB(id) {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = store.delete(id)
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(e)
			}
		})
	}

	function save() {
    world = dimensions.overworld
		saveToDB(world.id, {
			id: world.id,
			edited: Date.now(),
			name: world.name,
			version: world.version || version,
			code: world.getSaveString(),
      nether: world.getNetherSaveString(),
      inv: world.getInv(),
      surviv: world.getSurvivStr(),
      ent: world.getEntities(),
      mod: world.mod,
      thumbnail: genWorldImage(),
      achievments:achievments,
      playersInv: playersInv
		}).then(() => world.edited = Date.now()).catch(e => console.error(e))
	}
  win.save = save
  
  let thumbCnv = document.createElement("canvas")
  thumbCnv.width = thumbCnv.height = 70
  let thumbCtx = thumbCnv.getContext("2d")
  win.genWorldImage = function(){
    var midx = gl.canvas.width / 2, midy = gl.canvas.height / 2
    var size = min(gl.canvas.width, gl.canvas.height), s2 = size / 2
    thumbCtx.drawImage(gl.canvas, midx - s2, midy - s2, size,size, 0,0,70,70)
    return thumbCnv.toDataURL("image/png")
  }
  win.thumbCnv = thumbCnv, win.thumbCtx = thumbCtx

	// Expose these functions to the global scope for debugging
	win.saveToDB = saveToDB
	win.loadFromDB = loadFromDB
	win.createDatabase = createDatabase
	win.deleteFromDB = deleteFromDB

	//globals
	//{
	let version = "Alpha 1.0.3"
  doc.title = "MineKhan "+version
  let normReach = 5
  let bigReach = 40
  let reach = normReach // Max distance player can place or break blocks
	let sky = [/*0.33, 0.54, 0.72, <originl sky>*/  0.6, 0.8, 0.9] // 0 to 1 RGB color scale
  function changeSky(type){
    if(type === "nether"){
      sky = [0,0,0]
    }else{
      sky = [0.6, 0.8, 0.9]
    }
  }
  let soundOn = true
	let superflat = false
	let trees = true
	let caves = true
  let survival = false;
  let cheats = false
  let dieMessage = ""

  let touchMoveLimit = 500 //(touch screen only) miliseconds before it decides you want to break a block
  
	let blockIds = {}
	blockData.forEach(block => blockIds[block.name] = block.id)
  blockData.forEach(block => {
    if(block.rotate && block.name.includes("SW")){
      var unSw = block.name.replace("SW",'')
      if(blockIds[unSw]){
        block.drop = unSw
        var obj = blockData[blockIds[unSw]]
        block.breakTime = obj.breakTime
        block.type = obj.type
      }
    }
  })
	win.blockData = blockData
	win.blockIds = blockIds
  
  //fill the crafts that have less than 9 items. Ex: "thing" => "thing,air,air..."
  let arr
  for(let i in crafts){
    arr = i.split(",")
    for(let j = 0; j<9; j++){
      if(arr[j]){
        arr[j] = blockIds[arr[j]]
      }else{
        arr.push(0)
      }
    }
    crafts[i].id = blockIds[crafts[i].name]
    if(crafts[i].amount === undefined) crafts[i].amount = 1
    crafts[arr.join(",")] = crafts[i]
    
    delete crafts[i]
  }
  win.crafts = crafts
  
  for(i in smelts){
    smelts[i].id = blockIds[smelts[i].name]
    smelts[blockIds[i]] = smelts[i]
    delete smelts[i]
  }
  for(i in smeltFuel){
    smeltFuel[i].operations = smeltFuel[i].time / 10
    smeltFuel[i].ops = smeltFuel[i].operations / smeltFuel[i].time //operations per seconds
    smeltFuel[blockIds[i]] = smeltFuel[i]
    delete smeltFuel[i]
  }
  win.smelts = smelts; win.smeltFuel = smeltFuel

	let currentFov

	// Configurable and savable settings
	let settings = {
		renderDistance: 4,
		fov: 70, // Field of view in degrees
		mouseSense: 100 // Mouse sensitivity as a percentage of the default
	}
	let locked = true
	let generatedChunks
	let mouseX, mouseY, mouseDown
	let width = window.innerWidth
	let height = window.innerHeight
  
  class Skybox{ //from https://www.khanacademy.org/computer-programming/skybox/5709195676041216 with syntax modifications
    constructor(){
      this.vertexData = new Float32Array([
        //bottom vertices
        -1.0, -1.0, -1.0,
        1.0, -1.0, -1.0,
        1.0, -1.0,  1.0,
        -1.0, -1.0,  1.0,

        // top vertices
        -1.0,  1.0, -1.0,
        1.0,  1.0, -1.0,
        1.0,  1.0,  1.0,
        -1.0,  1.0,  1.0
      ]);
      this.faceData = new Uint8Array([
        //-y
        1, 0, 3,
        1, 3, 2,
        //+y
        5, 7, 4,
        5, 6, 7,
        //+x
        1, 2, 5,
        2, 6, 5,
        //-x
        0, 4, 3,
        3, 4, 7,
        //-z
        0, 1, 5,
        0, 5, 4,
        //+z
        3, 7, 6,
        3, 6, 2
      ]);
      gl.enableVertexAttribArray(glCache.skyboxVertex);
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
      glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
      
      this.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
      
      this.indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.faceData, gl.STATIC_DRAW);
      
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
    render() {
      gl.vertexAttribPointer(glCache.skyboxVertex, 3, gl.FLOAT, false, 4 * 3, 0);
      gl.uniformMatrix4fv(glCache.skyboxView, false, p.transformation.elements)
      glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
      gl.drawElements(gl.TRIANGLES, this.faceData.length, gl.UNSIGNED_BYTE, 0);
      glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  let skybox
  
  let colors = {
    0: "#000",
    1: "#00a",
    2: "#0a0",
    3: "#0aa",
    4: "#a00",
    5: "#a0a",
    6: "#fa0",
    7: "#aaa",
    8: "#555",
    9: "#55f",
    a: "#5f5",
    b: "#5ff",
    c: "#f55",
    d: "#f5f",
    e: "#ff5",
    f: "#fff",
    g: "#DDD605",//minecoin gold
  }

	if (height === 400) alert("Canvas is too small. Click the \"Settings\" button to the left of the \"Vote Up\" button under the editor and change the height to 600.")

	let generator = {
		height: 80, // Height of the hills
		smooth: 0.01, // Smoothness of the terrain
		extra: 30, // Extra height added to the world.
		caveSize: 0.00, // Redefined right above where it's used
    biomeSmooth: 0.007, // Smoothness of biomes
	}
	let maxHeight = 255
	let blockOutlines = false
	let blockFill = true
	let updateHUD = true
  
  var explodeVaos = []
  
  let images = {
    attackIndicatorCrosshair: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAHBAMAAAC8U9OhAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAKlBMVEUAAAD///86OzzS0tbX2erq7PI6OzxbSkmCbWxtWVfX2er////q7PL///+PAAbaAAAABnRSTlMAAAAAAABupgeRAAAAAWJLR0QN9rRh9QAAAAd0SU1FB+UICBISCBYUzEAAAAABb3JOVAHPoneaAAAASklEQVQI12NgYGOAAHYwyQilGRjSoKCzcxUYQOnVMAmFzs4zu4HABEobMKAZxeIAMwoNMAoKigouAWIsEoJRqxwFA7HpCFkClAAAVfMfb4rLipMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDgtMDhUMTg6MTc6MTgrMDA6MDB6HTijAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA4LTA4VDE4OjE3OjE4KzAwOjAwC0CAHwAAAABJRU5ErkJggg==",
    deadHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAT0lEQVQoU62OwQ3AMAwCz1N4//E8RSqjuiVRn/ULocMQvLduGYBr2uhbmSlRVbgGQqkx7esjO/QvtG3yyq6aTeNv2wYQdYwV6MAXpOozfAGB1SIH1uYKrgAAAABJRU5ErkJggg==",
    heart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAXElEQVQoU3XQQRKAIAiF4Z97ua8j19572UCSTytWjHwCgzGi9dQAzfEHj/YrwOJXgFqhFGl8pw4GepUXdADbBzqBvXeKnVaYwE0uPkEFuZcOio4+QqY8J5igAi9cnpgXB7uKmTQAAAAASUVORK5CYII=",
    halfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAY0lEQVQoU4WOwQ3AMAgDzS50i/zbkTtAxmCXVLiBoKhS+YDMYSxYNeYoAOoMF7xGVVWVopl5E14R6B1ojctjQgEuqPz9hG4A5w/ETBUMp5opPBJ0KAAmL1/S8XrF3O0Qwf34AVFaJQc+FQukAAAAAElFTkSuQmCC",
    whiteHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAARUlEQVQoU61QQQ4AIAiK/z+aBsuNbN7ykKQEJtYJkhQEgMSu6VBRzQn7VRFKNbP7/0h9jscqZ+m2efePcg21ghS4SJP1BvDiR/68vCmnAAAAAElFTkSuQmCC",
    witherHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAJ1BMVEUAAAAAAAA7ExPLy8srKysvDw8nJycdHR0qDg4gICA5HBxHHBz///8BX2maAAAAAXRSTlMAQObYZgAAAAFiS0dEDIGzUWMAAAAHdElNRQfkCBcNAScIdsCqAAAAAW9yTlQBz6J3mgAAADpJREFUCNdjYBBkFGBgYFQSUmRgEDJRcRJgEHVxcxdgkJjmMkuAgbHTcyEDA4PEbKAaBsaNDCAAZAIArksGwN+RpQkAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTM6MDE6MzkrMDA6MDAs2fv0AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDEzOjAxOjM5KzAwOjAwXYRDSAAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MTg3Njk53UrJaAAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTA3NzIwNzAyOTQ0NjEzMTIwMzcf2rzMAAAAAElFTkSuQmCC",
    witherHalfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAlElEQVQoU2NkQID/UCYjAwMDMpsBJAAC/y24ucGME1+/MoiLi4PZL1++BFGMYF0gBVMOHmSIjo5mEHzyhOE+Dw/cfJBCsCJtNjaGP4qKcIkPHz5gKlJlY2P4KiLCwMHBwcDKysqATRHYTTCFvLy8cEXIboIZDVf49+9fuKPBLkcKArCJrqKiDLtfv0aRQ1cEVoiuGQBusjgHiQpSWAAAAABJRU5ErkJggg==",
    freezeHeart:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAKVJREFUKFNjZECA/1AmIwMDAzKbASTAwMjE/N9r5zWwmq2u6gzeu2/C2SBpsC6QYKy1KsPio7cZzLTFGU5dfckQZ6PGsOjILbAmuCKQVpACDUF+hhvvP4IVwkwGK1r5/T9YIlGMnyFz/y2wKSA+SEM4JyPETWCH7v/E0Kj+D6xw/quPDPU3mRgYHPnAToYpQlGIrACsCikI4AphJsDk0BVBFKJpBgBbYkAHTYvoqAAAAABJRU5ErkJggg==",
    freezeHalfHeart:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAJxJREFUKFNjZECA/1AmIwMDAzKbASTAwMjE/N9r5zWwmq2u6gwaGhpg9o0bN8DSYF3eu28yxFqrMiw+epvBTFucYbmTBdx8kEK4IpAoSIGGID9DvaEmpqKV3/8z3Hj/kSFRjJ8hc/8thru5/hiKQAL/GfZ/YmhU/wdW6KYDMQnZTTBdcIUgN8EUgF2OFARwExkc+VDk0BVBFKJpBgBAXzsHeDkERgAAAABJRU5ErkJggg==",
    bubble: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEUAAAAAAAAAlP/R6/9WuP////8DieLBAAAAAXRSTlMAQObYZgAAAAFiS0dEBfhv6ccAAAAHdElNRQflBhwAOQFmUYA6AAAAAW9yTlQBz6J3mgAAAC9JREFUCNdjYGAUZAACISUBBgZGBQZFIJPZgEUASDKASAYQCRR3BKoRcQGqAasHADZEAh1qmnpBAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA2LTI4VDAwOjU1OjAxKzAwOjAwEE5qGwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNi0yOFQwMDo1NTowMSswMDowMGET0qcAAAAASUVORK5CYII=",
    bubblePop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADFBMVEUAAAAAlP8AAAD///8Mq+G/AAAAAXRSTlMAQObYZgAAAAFiS0dEAxEMTPIAAAAHdElNRQflBhwBAwbcXqHXAAAAAW9yTlQBz6J3mgAAACVJREFUCNdjYHBgYHBwZGCY0MbAoMDBAAYOjA4MLUwNDBIsYDEAStwDy/jv20gAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDYtMjhUMDE6MDM6MDYrMDA6MDB0NlEVAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA2LTI4VDAxOjAzOjA2KzAwOjAwBWvpqQAAAABJRU5ErkJggg==",
    drumstickBG: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAQAAABKmM6bAAAABGdBTUEAALGPC/xhBQAAAAJiS0dEAP+Hj8y/AAAAB3RJTUUH5AgXESYlKYFJ9wAAAAFvck5UAc+id5oAAAA8SURBVAjXZc2xDcAwDAPBk6bR/tN4G6VQ4MTwV8SDBIHWNoEurMmIEX4yv0GZeYrlJLml/dnV5zdeeXU9xdgUJaD0S9kAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTc6Mzg6MzcrMDA6MDDZqKf0AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDE3OjM4OjM3KzAwOjAwqPUfSAAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MjA0MzE3ULE6DQAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTIwMTgzMjY0MzU0MzI0OTcxOTF/QUjUAAAAAElFTkSuQmCC",
    drumstick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAJFBMVEUAAAAAAADUKiqyGBjfsY+4hFidbUNhPBt7US3i1ar/99z///9NiP3lAAAAAXRSTlMAQObYZgAAAAFiS0dECx/XxMAAAAAHdElNRQfkCBcRJiawiBhNAAAAAW9yTlQBz6J3mgAAAC5JREFUCNdjYBBkAAJGZQEgKeQUCCSFVVOBHMaKNJCQeAeIZBScCKIYpMCkIAMAcDQEJB3YgfcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTc6Mzg6MzgrMDA6MDAv4NcdAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDE3OjM4OjM4KzAwOjAwXr1voQAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MjA0MzE4wA4nnAAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTMzODIyODY4OTM1NDEwNTg2ODQQPSTjAAAAAElFTkSuQmCC",
    halfDrumstick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAjUlEQVQoU2NkQID/UCYjkhiYCRP4r6GhwdD98iWD7/v3yOJwRWAFB+fWMbxJqGe49+YNhkKQSWBFILChIJjhb+8qhicJRgzu1SvhJmJYB5J5HWPAkDR5P4YikADYREvBNwzS4qIMLRuuY1UEVgjz2eNraxhktUJQfIfua7CG/9/vMjByKsODAKsiWLgBAAIkLghjp1NyAAAAAElFTkSuQmCC",
    explode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAAXNSR0IArs4c6QAAABhJREFUGFdj/M/w/z8jAwgyMPz/z/CfAQA5DAX/rY1o3wAAAABJRU5ErkJggg==",//"https://data.thingmaker.repl.co/images/explode.png",
    freezeEffect: "assets/images/freeze_effect.png",
    minekhan: "assets/images/minekhan.png",
    panorama: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAAXNSR0IArs4c6QAAABhJREFUGFdj/M/w/z8jAwgyMPz/z/CfAQA5DAX/rY1o3wAAAABJRU5ErkJggg==",//"https://data.thingmaker.repl.co/images/panorama.png",
  }
  let crossOriginImages = ["explode","panorama"]
  for(var i in images){
    var url = images[i]
    images[i] = new Image()
    images[i].src = url
    images[i].onload = () => loadDone()
    images[i].onerror = err => {loadDone(); console.log(err)}
    if(crossOriginImages.includes(i)){
      images[i].crossOrigin = ""
    }
  }
  win.images = images
  let audioCtx
  
	let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
      CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,WALL,
      WALLU,//wall withe exteion under another wall
      FENCQ,//fence (one extension)
      BUTTON,CHAIN,POT,POTCROSS,CARPET,LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,
	    FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
  let isCube
  var prevConstVersion = null
  
  var curConst = 0
  function nextConst(rotate, flip){
    var n = 1
    if(rotate) n = 4
    if(flip) n = 8
    var p=curConst
    curConst += n*500
    return p
  }
  function verMoreThan(a,b){
    a = a.split(".")
    b = b.split(".")
    if(a[0] > b[0]) return true
    if(a[1] > b[1] && a[0] === b[0]) return true
    if(a[2] > b[2] && a[1] === b[1]) return true
  }
  function constVersion(v){
    if(v === prevConstVersion) return
    prevConstVersion = v
    isCube = 0xff
    var verNum = v.replace(/Alpha /, '')//.replace(/(?<=\..*)\./g, '') //second regex removes the periods after the first
    if(verMoreThan(verNum, "1.0.3") || verNum==="1.0.3"){
CUBE = 0
LAYER2 = SLAB = 0x100<<5 // 9th bit
LAYER3 = STAIR = 0x200<<5 // 10th bit
LAYER4 = CROSS = 0x300<<5
LAYER5 = TALLCROSS = 0x700<<5
LAYER6 = LANTERN = 0x900<<5
LAYER7 = LANTERNHANG=0x1100<<5
BEACON = 0x1300<<5
CACTUS = 0x1400<<5
POT = 0x1500<<5
POTCROSS = 0x1700<<5
LAYER1 = TORCH = 0x1800<<5
CHAIN = 0x1900<<5
LAYER8 = DOOR = 0x2100<<5
PORTAL = 0x2200<<5
WALLFLAT = 0x2300<<5
PANE = 0x4400<<5
TRAPDOOR = 0x2800<<5
TRAPDOOROPEN=0x4000<<5
FENCE = 0x6000<<5
WALLPOST = 0x6200<<5
WALL = 0x6400<<5
WALLU = 0x6600<<5 //wall withe exteion under another wall
FENCQ = 0x4100<<5 //fence (one extension)
BUTTON = 0x4200<<5
CARPET    = 0x4300<<5
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
isCube = 0xff*2
    }else if(verNum >= 1){
CUBE = 0
LAYER2 = SLAB = 0x100 // 9th bit
LAYER3 = STAIR = 0x200 // 10th bit
LAYER4 = CROSS = 0x300
FLIP = 0x400 // 11th bit
LAYER5 = TALLCROSS = 0x700
LAYER6 = LANTERN = 0x900
LAYER7 = LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
LAYER1 = TORCH = 0x1800
CHAIN = 0x1900
LAYER8 = DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
WALL = 0x6400
WALLU = 0x6600 //wall withe exteion under another wall
FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
    }else{
      CUBE      = 0
      LAYER2 = SLAB      = 0x100 // 9th bit
      LAYER3 = STAIR     = 0x200 // 10th bit
      LAYER4 = CROSS     = 0x2000
      LAYER5 = TALLCROSS = 0x2200
      LAYER8 = DOOR      = 0x2400
      LAYER1 = TORCH     = 0x2600
      LAYER6 = LANTERN   = 0x2800
      LAYER7 = LANTERNHANG=0x3000
      BEACON    = 0x4200
      CACTUS    = 0x4400
      PANE      = 0x4600
      PORTAL    = 0x5000
      WALLFLAT  = 0x4800
      TRAPDOOR  = 0x5200
      TRAPDOOROPEN=0x5400
      FENCE     = 0x6000
      WALLPOST  = 0x6200
      WALL      = 0x6400
      WALLU     = 0x6600 //wall withe exteion under another wall
      FENCQ     = 0x6800 //fence (one extension)
      BUTTON    = 0x7000
      CHAIN     = 0x7200
      POT       = 0x8000
      POTCROSS  = 0x8200
      CARPET    = 0x8400
      FLIP      = 0x400 // 11th bit
      NORTH     = 0 // 12th and 13th bits for the 4 directions
      SOUTH     = 0x800
      EAST      = 0x1000
      WEST      = 0x1800
      ROTATION  = 0x1800 // Mask for the direction bits
    }
    initBlockData()
    genIcons()
  }
	let blockMode   = CUBE
  win.changeBlockMode = m => blockMode = m
	let tex
	let textureAtlas
	let textureMap
	let dirtBuffer, netherBuffer, explodeBuffer
	let dirtTexture, netherTexture, explodeTexture, panoramaTexture
	let textureCoords
	let texCoordsBuffers
	let mainbg, dirtbg, netherbg // Background images
	let bigArray = win.bigArray || new Float32Array(600000)
	win.bigArray = bigArray

	// Callback functions for all the screens; will define them further down the page
	let drawScreens = {
		"main menu": () => {},
		"options": () => {},
		"play": () => {},
		"pause": () => {},
		"creation menu": () => {},
		"inventory": () => {},
		"multiplayer menu": () => {},
		"comingsoon menu": () => {},
		"loadsave menu": () => {},
    "marketplace": () => {},
	}
	let html = {
		pause: {
			enter: [window.message],
			exit: [window.savebox, window.saveDirections, window.message]
		},
		"loadsave menu": {
			enter: [window.worlds, window.boxCenterTop, window.quota],
			exit: [window.worlds, window.boxCenterTop, window.quota],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter Save String (Optional)"
				if (navigator && navigator.storage && navigator.storage.estimate) {
					navigator.storage.estimate().then(data => {
						window.quota.innerText = `${data.usage.toLocaleString()} / ${data.quota.toLocaleString()} bytes (${(100 * data.usage / data.quota).toLocaleString(undefined, { maximumSignificantDigits: 2 })}%) of your quota used`
					}).catch(console.error)
				}
				window.boxCenterTop.onmousedown = e => {
					let elem = document.getElementsByClassName("selected")
					if (elem && elem[0]) {
						elem[0].classList.remove("selected")
					}
					selectedWorld = 0
					Button.draw()
				}
			},
			onexit: () => {
				window.boxCenterTop.onmousedown = null
			}
		},
    "multiplayer menu": {
			enter: [window.servers],
			exit: [window.servers],
      onenter: initServersMenu
		},
		"creation menu": {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = ""
			}
		},
		loading: {
			onenter: () => {
        startLoad()
        constVersion(world.version || version)
      },
      onexit: () => {
        if(multiplayer){
          send({
            "type":"joined",
            username: username
          })
        }
        Messages.add("<span style='color:lime;'>Press / to open chat. "+(cheats ? "Type /? for help with commands." : "")+"</span>")
      }
		},
    netherLoading: {
			onenter: startLoad
		},
		editworld: {
			enter: [window.boxCenterTop, window.editworld],
			exit: [window.boxCenterTop, window.editworld],
			onenter: () => {
        var w = worlds[selectedWorld]
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = w.name
        window.url.value = w.thumbnail
			}
		},
    marketplace: {
      enter: [window.marketplace],
      exit: [window.marketplace]
    },
    play: {
      enter: [window.messageHolder, window.onscreenControl_Element],
      exit: [window.messageHolder, window.onscreenControl_Element],
      onexit: () => Messages.clear()
    },
    help:{
      enter: [window.help],
      exit: [window.help]
    }
	}

	let screen = "main menu"
	let previousScreen = screen
	function changeScene(newScene) {
		if (screen === "options") {
			saveToDB("settings", settings).catch(e => console.error(e))
		}

		if (html[screen] && html[screen].exit) {
			for (let element of html[screen].exit) {
				element.classList.add("hidden")
			}
		}

		if (html[newScene] && html[newScene].enter) {
			for (let element of html[newScene].enter) {
				element.classList.remove("hidden")
			}
		}

		if (html[newScene] && html[newScene].onenter) {
			html[newScene].onenter()
		}
		if (html[screen] && html[screen].onexit) {
			html[screen].onexit()
		}

		previousScreen = screen
		screen = newScene
		mouseDown = false
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
    
    if(newScene === "main menu" || newScene === "play" || newScene === "paused" || newScene === "inventory" || newScene === "options"){
      themeColor.content = "#fff"
    }else{
      themeColor.content = "#110"
    }
	}
  win.changeScene = changeScene
  win.getScene = () => screen
	let hitBox = {}
  win.entHitbox = {}
	let holding = 0
  let crack = {
    0: "crack1",
    1: "crack2",
    2: "crack3",
    3: "crack4",
    4: "crack5",
    5: "crack6",
    6: "crack7",
    7: "crack8",
    8: "crack9",
    9: "crack10",
    10: "crack10",
    length: 10,
    idx: 0, // block will break if idx is 4
    tex: "crack1",
    shape: null,
    pos: [0,0,0],
    prevPos: [-1,-1,-1],
    breakStart: 0,
    delayBetween:60*3/10,
    delayDone:0,
    entity: null, //define later
    soundTimer: 0
  }
  win.crack = crack
  {
    //command system
    var copiedBlocks = [];
    var prevPos;
    function fill(x,y,z,x2,y2,z2, blockID){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}
      for(var X=x; x2>=X; X++){
        for(var Y=y; y2>=Y; Y++){
          for(var Z=z; z2>=Z; Z++){
            world.setBlock(X,Y,Z,blockID)
          }
        }
      }
    }
    function copy(x,y,z,x2,y2,z2){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}

      copiedBlocks = [];
      for(var X=x; x2>=X; X++){
        var xRow = [];
        for(var Y=y; y2>=Y; Y++){
          var yRow = []
          for(var Z=z; z2>=Z; Z++){
            yRow.push(world.getBlock(X,Y,Z));
          }
          xRow.push(yRow);
        }
        copiedBlocks.push(xRow);
      }
    }
    function paste(x,y,z){
      for(var X = 0; X<copiedBlocks.length; X++){
        var xRow = copiedBlocks[X];
        for(var Y=0; Y<xRow.length; Y++){
          var yRow = xRow[Y];
          for(var Z=0; Z<yRow.length; Z++){
            var block = yRow[Z];
            world.setBlock(X+x,Y+y,Z+z,block)
          }
        }
      }
    }
    function replaceBlocks(x,y,z,x2,y2,z2, replace, into){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}
      for(var X=x; x2>=X; X++){
        for(var Y=y; y2>=Y; Y++){
          for(var Z=z; z2>=Z; Z++){
            if(world.getBlock(X,Y,Z) === replace){
              world.setBlock(X,Y,Z,into)
            }
          }
        }
      }
    }

    function fromPlayer(){
      prevPos = [p2.x, p2.y, p2.z]
    }
    function fillToPlayer(id){
      //fills at player feet
      fill(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, id)
    }

    function copyToPlayer(){
      copy(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z);
    }
    function pasteAtPlayer(){
      paste(p2.x,p2.y-1,p2.z)
    }

    function hcyl(bottom, height, radius, id) {
        let radsq = radius * radius
        let innerRadsq = (radius - 1.2) * (radius - 1.2)
        height += bottom
        for (let x = -radius; x <= radius; x++) {
            for (let y = bottom; y < height; y++) {
                for (let z = -radius; z <= radius; z++) {
                    let d = x * x + z * z
                    if (d < radsq && d >= innerRadsq) {
                        world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                    }
                }
            }
        }
    }

    function cyl(bottom, height, radius, id) {
        let radsq = radius * radius
        height += bottom
        for (let x = -radius; x <= radius; x++) {
            for (let y = bottom; y < height; y++) {
                for (let z = -radius; z <= radius; z++) {
                    let d = x * x + z * z
                    if (d < radsq) {
                        world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                    }
                }
            }
        }
    }

    function sphereoid(w, h, d, id, X,Y,Z) {
        let w2 = w * w
        let h2 = h * h
        let d2 = d * d
        let w3 = (w - 1.5) * (w - 1.5)
        let h3 = (h - 1.5) * (h - 1.5)
        let d3 = (d - 1.5) * (d - 1.5)

        for (let y = -h; y < h; y++) {
            for (let x = -w; x <= w; x++) {
                for (let z = -d; z <= d; z++) {
                    let n = x * x / w2 + y * y / h2 + z * z / d2
                    let n2 = x * x / w3 + y * y / h3 + z * z / d3
                    if (n < 1 && n2 >= 1) {
                        world.setBlock(X + x, Y + y, Z + z, id)
                    }
                }
            }
        }
    }
    var cmds = [
      {
        name: "showAll",
        info: "Shows all messages.",
        func: () => Messages.showAll(),
        noCheats: true
      },
      {
        name: "clear",
        info: "Clears shown messages",
        func: () => Messages.clear(),
        noCheats: true
      },
      {
        name: "fromPlayer",
        info: "Sets position 1 to player",
        func: () => fromPlayer()
      },
      {
        name: "fillToPlayer",
        args: ["block_name"],
        info: "Fills from position 1 to player position",
        func: split => {
          let id = blockIds[split[1]]
          if(!split[1]) id = 0
          fillToPlayer(id)
        }
      },
      {
        name: "copyToPlayer",
        info: "Copys blocks from position 1 to player position",
        func: () => copyToPlayer()
      },
      {
        name: "pasteAtPlayer",
        info: "Pastes copied blocks at the player's position",
        func: () => pasteAtPlayer()
      },
      {
        name: "sphereoid",
        args: ["width", "height", "depth", "block_name", "x", "y", "z"],
        func: split => {
          let id = blockIds[split[4]]
          if(!split[4]) id = 0
          let x = split[5] ? parseInt(split[5]) : p2.x,
              y = split[6] ? parseInt(split[6]) : p2.y,
              z = split[7] ? parseInt(split[7]) : p2.z
          sphereoid(split[1], split[2], split[3], id, x,y,z)
        }
      },
      {
        name: "replaceToPlayer",
        args: ["replace_what", "with_what"],
        func: split => {
          let replace = blockIds[split[1]]
          if(!split[1]) replace = 0
          let into = blockIds[split[2]]
          if(!split[2]) into = 0
          replaceBlocks(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, replace, into)
        }
      },
      {
        name: "give",
        args: ["target", "block_name", "amount"],
        info: "Gives the target the the specified amount of specified blocks",
        func: split => {
          let id = blockIds[split[2]]
          var amount = split[3] || 1
          if(split[1] === "@s"){
            if(id){
              for(var i=0; i<amount; i++){
                newInvItem(id)
              }
            }
          }else if(split[1] === "@a"){
            for(var i in players){
              var p = players[i]
              for(var a=0; a<amount; a++){
                world.addEntity(new Item(p.x,p.y,p.z,0,0,0,id))
              }
            }
          }else if(hasPlayer(split[1])){
            var p = getPlayerByUsername(split[1])
            for(var a=0; a<amount; a++){
              world.addEntity(new Item(p.x,p.y,p.z,0,0,0,id))
            }
          }else{
            Messages.add("Can't select with selector "+split[1])
          }
        }
      },
      {
        name: "kill",
        args: ["selector","message"],
        info: "Kills someone. Selectors: @s, your username, someone's uername, @a, @e",
        func: split => {
          split[1] = split[1] || "@s"
          if(split[1] === "@s" || split[1] === username){
            dieMessage = split[2] || (username+" killed themself with the kill command. Why would you do that???")
            die()
          }else if(split[1] === "@a" || hasPlayer(split[1])){
            send({type:"kill", message:split[2] || "", data:split[1]})
          }else if(split[1] === "@e"){
            var killed = []
            for(var i=world.entities.length-1; i>=0; i--){
              killed.push(world.entities[i].type || "Entity")
              world.deleteEntity(0,false,i)
            }
            Messages.add("Killed: "+killed.join(", "))
          }else{
            Messages.add("Can't select with selector "+split[1])
          }
        }
      },
      {
        name: "ban",
        args: ["username"],
        info: "Bans a player. They cannot rejoin the world. Only bans them until multiplayer turns off",
        func: split => {
          if(win.ban){
            ban(split[1])
          }else{
            Messages.add("Error: can't ban.")
          }
        },
        noCheats:true
      },
      {
        name: "unban",
        args: ["username"],
        info: "Unbans a player.",
        func: split => {
          if(win.unban){
            unban(split[1])
          }else{
            Messages.add("Error: can't ban.")
          }
        },
        noCheats:true
      },
      {
        name: "time",
        args: ["n"],
        info: "n is the time to set to. 1000 is a day. n an also be: day, night",
        func: split => {
          var time
          if(split[1] === "day") time = -20
          else if(split[1] === "night") time = 480
          else time = parseInt(split[1]) || 0
          worldTime = time * Math.PId / 1000
        }
      },
      {
        name:"gameMode",
        args: ["mode"],
        info: "mode can be: creative, survival, spectator",
        func: split => {
          let m = split[1]
          p.spectator = false
          if(m === "creative") survival = false
          else if(m === "survival") survival = true
          else if(m === "spectator") p.spectator = p.flying = true
          else Messages.add("Game mode doesn't exsist: "+m)
        }
      },
      {
        name:"tp",
        args: ["to_who"],
        info: "Teleport to someone. \"to_who\" should be a username.",
        func: split => {
          if(hasPlayer(split[1])){
            var player = getPlayerByUsername(split[1])
            p.x = player.x
            p.y = player.y
            p.z = player.z
          }else{
            Messages.add("Player doesn't exsist: "+split[1])
          }
        }
      },
      {
        name:"online",
        args:[],
        noCheats: true,
        info: "Lists people that are playing on this world.",
        func: split => {
          if(!multiplayer){
            return Messages.add("You are not in a multiplayer world.")
          }
          send({type:"fetchUsers"})
        }
      }
    ]
    win.cmds = cmds
    function getCmd(name){
      for(var i=0; i<cmds.length; i++){
        if(cmds[i].name === name){
          return cmds[i]
        }
      }
    }
    
    function runCmd(str){
      str = str.replace("/", '')
      let split = str.split(" ")
      let name = split[0]
      if(name === "?"){
        if(split[1]){
          var cmd = getCmd(split[1])
          if(cmd){
            var str = "<b>/"+split[1]+"</b><br>"
            str += "Syntax: /"+cmd.name+" "
            if(cmd.args) str += cmd.args.join(" ")
            str += "<br>"
            if(cmd.info) str += "Description: "+cmd.info
            Messages.add(str)
          }else Messages.add("There is no information for /"+split[1])
        }else{
          if(cheats){
            var str = "List of commands:<br>"
            str += "Use <span style='color:lime;'>/? command_name</span> to get information about a command<br>"
            cmds.forEach(r => {
              str += "<span style='color:lightblue;'>/"+r.name+"</span> "
              if(r.args) str += r.args.join(" ")
              str += "<br>"
            })
            Messages.add(str)
          }else{
            var str = "List of available commands:<br>"
            str += "Use <span style='color:lime;'>/? command_name</span> to get information about a command<br>"
            cmds.forEach(r => {
              if(!r.noCheats) return
              str += "<span style='color:lightblue;'>/"+r.name+"</span> "
              if(r.args) str += r.args.join(" ")
              str += "<br>"
            })
            Messages.add(str)
          }
        }
      }else{
        var cmd = getCmd(name)
        if(cmd){
          if(!cheats && !cmd.noCheats){
            Messages.add("cThat command requires cheats")
            return
          }
          cmd.func(split)
        }else Messages.add("cError: no such command called f"+name)
      }
    }
    win.runCmd = runCmd
  }
  let Messages = {
    array: [],
    all: [],
    update:function(){
      if(this.array.length === 0){
        messages.innerHTML = ""
      }else messages.innerHTML = this.array.join("<br>")
    },
    showAll: function(){
      if(this.all.length === 0){
        messages.innerHTML = ""
      }else messages.innerHTML = this.all.join("<br>")
    },
    clear: function(){this.array = [];this.update()},
    add: function(msg){
      msg = this.format(msg)
      this.array.push(msg)
      this.all.push(msg)
      if(this.array.length > 5){
        this.array.shift()
      }
      this.update()
    },
    write: function(msg, from){
      this.add((from || username)+": "+msg)
      if(!from && multiplayer){
        send({type:"message", data:msg, username:username})
      }
    },
    showInput(){
      messageInput.classList.remove("hidden")
      messageInput.focus()
      messageInput.onkeypress = (e) => {
        if(e.key !== "Enter") return
        if(messageInput.value[0] === "/"){
            Messages.add(messageInput.value)
            runCmd(messageInput.value)
        }else{
          Messages.write(messageInput.value)
        }
        messageInput.classList.add("hidden")
        messageInput.value = ""
        canvas.focus()
      }
    },
    format(str){
      if(str.includes("")){
        var arr = str.split("")
        var res = arr[0]
        var spans = 0
        for(var i=1; i<arr.length; i++){
          var s = arr[i]
          var col = colors[s.substring(0,1)]
          s = s.substring(1)
          res += "<span style='color:"+col+";'>"+s
          spans ++
        }
        for(i=0; i<spans;i++) res += "</span>"
        return res
      }else return str
    }
  }
  window.Messages = Messages
  let title = ""
  let subtitle = ""
  let titleOpacity = 0
  let titleColor = "black"
  function showTitle(aTitle, aSubtitle, color){
    title = aTitle
    subtitle = aSubtitle
    titleOpacity = 140
    titleColor = color || "white"
  }
  win.showTitle = showTitle
  let sideMessageTime = 0,
      sideMessageTitle, sideMessageContent
  function sideMessage(title, content){
    sideMessageTime = 600
    sideMessageTitle = title
    sideMessageContent = content
  }
  win.sideMessage = sideMessage
  function die(){
    if(survival){
      for(var i=0; i<inventory.hotbar.length; i++){
        if(inventory.hotbar[i].id){
          for(var j=0; j<inventory.hotbar[i].amount; j++)world.addEntity(new Item(p.x,p.y,p.z,0,0,0,inventory.hotbar[i].id,true))
          inventory.hotbar[i] = 0
        }
      }
      for(var i=0; i<invLength; i++){
        if(invItems[i] && invItems[i].id){
          for(var j=0; j<invItems[i].amount; j++)world.addEntity(new Item(p.x,p.y,p.z,0,0,0,invItems[i].id, true))
          invItems[i].id = 0
        }
      }
    }
    changeScene("dead")
    releasePointer()
    p3.y = 0
    if(multiplayer) send({type:"die", id:achexUsername, message:dieMessage})
  }
  function damage(amount, why, nosound,type){
    p.health -= amount
    harmEffect = 40
    if(!nosound){
      switch(type){
        case "drown":
          drownHurtSound()
          break
        case "freeze":
          freezeHurtSound()
          break
        default:
          hitSound()
      }
    }
    dieMessage = why
    updateHUD = true
    if(multiplayer) send({type:"harmEffect", id:achexUsername})
  }
  win.damage = damage
	let Key = {}
	let modelView = win.modelView || new Float32Array(16)
	win.modelView = modelView
	let glCache
	let worlds, selectedWorld = 0
	let freezeFrame = 0
	let p
	let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector()
	let move = {
		x: 0,
		y: 0,
		z: 0,
		ang: Math.sqrt(0.5),
	}
	let p2 = {
		x: 0,
		y: 0,
		z: 0,
	}
  let p3 = { //precise positions for multiplayer
    x: 0,
    y: 0,
    z: 0,
    survival: false,
    username: ""
  }
  let controlMap = {}
  function setControl(name, key, shift = false, ctrl = false, alt = false){
    controlMap[name] = {
			key,
			shift,
			ctrl,
			alt,
			get pressed() {
				return Boolean(Key[this.key]
					&& (!this.shift || Key.ShiftLeft || Key.ShiftRight)
					&& (!this.ctrl || Key.ControlLeft || Key.ControlRight)
					&& (!this.alt || Key.AltLeft || Key.AltRight))
			},
			// Check to see if all of an event's data matches this key map
			event(e) {
				return Boolean(e.key === this.key
					&& (!this.shift || e.shiftKey)
					&& (!this.ctrl || e.ctrlKey)
					&& (!this.alt || e.altKey))
			}
		}
  }
  setControl("jump", " ")
	setControl("forward", "w")
	setControl("left", "a")
	setControl("backward", "s")
	setControl("right", "d")
	setControl("sprint", "q")
	setControl("inventory", "e")
	setControl("chat", "/")
	setControl("pause", "p")
	setControl("hyperBuilder", "h")
	setControl("superBreaker", "b")
	setControl("spectator", "l")
	setControl("zoom", "z")
	setControl("cycleBlockShapes", "enter")
	setControl("sneak", "shift")
	setControl("dropItem", "backspace")
	setControl("break", "leftMouse")
	setControl("place", "rightMouse")
	setControl("pick", "middleMouse")
  setControl("thirdPerson", "o")
	let place
  let liquid = false
  let powder = false
  let inWater = 0 //head is in liquid
  let tick = false
  let standingOn = 0 //block id you are standing on
  let lastTick = 0
  let lastLiquid = false
  let attackCooldown = 0, attackCooldownStart = 0, attackCooldownTime = 0 //for swords
  let harmEffect = 0
  //let healTime = 5000 // miliseconds between each heal
  let healEffect = 0 // health bar outline flash white
  let lastHeal = 0
  let lastBlockHarm = 0
  let lastLoseOxygen = 0
  let lastGetOxygen = 0
  let witherEffect = 0
  let witherDamage = 0
  let witherTime = 0
  let freezeEffect = 0
  let lastFreezeHealth = 0
  let loseHealthEffect = 0
  let portalEffect = 0
  win.lastStepSound = 0
  let eatSoundTimer = 0
	let inventory = {
		hotbar: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
		main: [],
		hotbarSlot: 0,
    showName:0,
		size: 40 * min(width, height) / 600,
    ts:(40 * min(width, height) / 600) / 16,
		holding: 0,
    space: invItems,
    crafting: [0,0,0,0,0,0,0,0,0],
    craftingStr: "",
    craftingRes: 0, //block id
    spreaded: [],
    spreadPlace: "", //inventory, crafting, etc
    spreadStart: -1,
    spreading: false,
    furnaceData: {
      x:0,y:0,z:0,
      data:null
    }
	}
  inventory.craftingStr = inventory.crafting.join(",")
  let furnaceData = inventory.furnaceData
  win.inventory = inventory
	//}
  for(var i=0; i<9; i++){
    inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
  }
  for(var i=0; i<9; i++){
    inventory.crafting[i] = {id:inventory.crafting[i],amount:64}
  }
  function setHotbar(arr){
    inventory.hotbar = arr
    for(var i=0; i<9; i++){
      inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
    }
  }

	function play() {
		canvas.onblur()
		p.lastBreak = Date.now()
		updateHUD = true
		use3d()
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		getPointer()
		fill(255, 255, 255)
		textSize(10)
		changeScene("play")
	}

	let gl
	let glExtensions
	function getPointer() {
    if(touchScreen) return
		if (canvas.requestPointerLock) {
			canvas.requestPointerLock()
		}
	}
	function releasePointer() {
		if (doc.exitPointerLock) {
			doc.exitPointerLock()
		}
	}

	let Block = {
		top: 0x4,
		bottom: 0x8,
		north: 0x20,
		south: 0x10,
		east: 0x2,
		west: 0x1,
	}
	let Sides = {
		top: 0,
		bottom: 1,
		north: 2,
		south: 3,
		east: 4,
		west: 5,
	}

	// GLSL Shader code (written in script tags at the top of the file)
	let vertexShaderSrc3D
	let fragmentShaderSrc3D
	let vertexShaderSrc2D
	let fragmentShaderSrc2D
  let vertexShaderSrcPanorama
	let fragmentShaderSrcPanorama
  let skyboxVertex
	let skyboxFragment
	let vertexShaderSrcEntity
	let fragmentShaderSrcEntity
  let vertexShaderSrcParticle
	let fragmentShaderSrcParticle
  function updateGLSL(){
    vertexShaderSrc3D = document.getElementById("blockVertexShader").text
    fragmentShaderSrc3D = document.getElementById("blockFragmentShader").text
    vertexShaderSrc2D = document.getElementById("2dVertexShader").text
    fragmentShaderSrc2D = document.getElementById("2dFragmentShader").text
    vertexShaderSrcPanorama = document.getElementById("panoramaVertexShader").text
    fragmentShaderSrcPanorama = document.getElementById("panoramaFragmentShader").text
    skyboxVertex = document.getElementById("skyboxVertexShader").text
    skyboxFragment = document.getElementById("skyboxFragmentShader").text
    vertexShaderSrcEntity = document.getElementById("entityVertexShader").text
    fragmentShaderSrcEntity = document.getElementById("entityFragmentShader").text
    vertexShaderSrcParticle = document.getElementById("particleVertexShader").text
    fragmentShaderSrcParticle = document.getElementById("particleFragmentShader").text
  }
  updateGLSL()
  win.updateGLSL = updateGLSL

	function createProgramObject(curContext, vetexShaderSource, fragmentShaderSource) {
		let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER)
		curContext.shaderSource(vertexShaderObject, vetexShaderSource)
		curContext.compileShader(vertexShaderObject)
		if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(vertexShaderObject)
		}

		let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER)
		curContext.shaderSource(fragmentShaderObject, fragmentShaderSource)
		curContext.compileShader(fragmentShaderObject)
		if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(fragmentShaderObject)
		}

		let programObject = curContext.createProgram()
		curContext.attachShader(programObject, vertexShaderObject)
		curContext.attachShader(programObject, fragmentShaderObject)
		curContext.linkProgram(programObject)
		if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
			throw "Error linking shaders."
		}

		return programObject
	}

	let program3D, program2D, skyboxProgram, programEntity, programParticle, programPanorama

	function objectify(x, y, z, width, height, textureX, textureY, texXFlip,texYFlip,rotateTex) {
		return {
			x: x,
			y: y,
			z: z,
			w: width,
			h: height,
			tx: textureX,
			ty: textureY,
      txf: texXFlip,
      rt:rotateTex
		}
	}
  function customFace(x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th){
    tw = tw || 16
    th = th || 16
    return {
      x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th,
      custom:true
    }
	}
  function generateItemShape(){
    var arr = []
    var bottom = [],
        top = [],
        east = [],
        west = []
    var i
    for(i=0; i<16; i++){
      bottom.push(objectify(0,i,7.5,16,1,0,(16-i)-1))
      top.push(objectify(0,i+1,8.5,16,1,0,16-i-1))
      east.push(objectify(i+1,16,7.5,1,16,(16-i)-1,0))
      west.push(objectify(i,16,8.5,1,16,(16-i)-1,0))
    }
    return [bottom,top,
            [objectify(16, 16, 8.5, 16, 16, 0, 0, true)],[objectify( 0, 16,  7.5, 16, 16, 0, 0)],
           east,west]
  }
  function layerShape(h){
    return [
      [objectify(0,0,0,16,16,0,0)],
      [objectify(0,h,16,16,16,0,0)],
      [objectify(16, h, 16, 16, h, 0, 16-h)],
      [objectify( 0, h,  0, 16, h, 0, 16-h)],
      [objectify(16, h,  0, 16, h, 0, 16-h)],
      [objectify( 0, h, 16, 16, h, 0, 16-h)]
    ]
  }
	let shapes = {
		/*
			[
				[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
				[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
				[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
				[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
				[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
				[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
			]
			*/
		cube: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
				[objectify(16, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
    rotate: {
			verts: [
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
				[objectify(16, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      rotate: true
		},
    _1PixLower:{
      verts: [
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 15, 16, 16, 16, 0, 0)], //top
				[objectify(16, 15, 16, 16, 15, 0, 1)], //north
				[objectify( 0, 15,  0, 16, 15, 0, 1)], //south
				[objectify(16, 15,  0, 16, 15, 0, 1)], //east
				[objectify( 0, 15, 16, 16, 15, 0, 1)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
		slab: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
				[objectify(16, 8, 16, 16, 8, 0, 0)], //north
				[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
				[objectify(16, 8,  0, 16, 8, 0, 0)], //east
				[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 1,
				south: 1,
				east: 1,
				west: 1
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
			flip: true,
			rotate: false
		},
		stair: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
				[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
				[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 3,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 10,
			varients: [],
			flip: true,
			rotate: true
		},
    cross: {
			verts: [
				[], //bottom
				[], //top
				[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0)], //north
				[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0)], //south
				[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0)], //east
				[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      hitbox: "cube"
		},
    sideCross: {
			verts: [
				[], //bottom
				[], //top
				[customFace(2,2,16, 14,14,16, 14,14,0, 2,2,0, 0,16,16,-16)], //north
				[customFace(14,2,16, 2,14,16, 2,14,0, 14,2,0, 0,16,16,-16)], //south
				[customFace(14,14,16, 2,2,16, 2,2,0, 14,14,0, 0,16,16,-16)], //east
				[customFace(2,14,16, 14,2,16, 14,2,0, 2,14,0, 0,16,16,-16)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      hitbox: "cube",
      rotate: true,
      hitbox: "cube"
		},
    bottomCross: {
			verts: [
				[], //bottom
				[], //top
				[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,16,16,-16)], //north
				[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,16,16,-16)], //south
				[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,16,16,-16)], //east
				[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,16,16,-16)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      hitbox: "cube"
		},
    tallCross: {
      verts: [
				[], //bottom
				[], //top
				[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
				[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
				[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
				[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
    door: {
			verts: [
				[objectify( 0,  0,  0, 16, 3, 0, 0)], //bottom
				[objectify( 0, 16, 3, 16, 3, 0, 0),objectify( 0, 32, 3, 16, 3, -16, 0)], //top
				[objectify(16, 16, 3, 16, 16, 0, 0),objectify(16, 32, 3, 16, 16, -16, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0),objectify( 0, 32,  0, 16, 16, -16, 0)], //south
				[objectify(16, 16,  0, 3, 16, 0, 0),objectify(16, 32,  0, 3, 16, -16, 0)], //east
				[objectify( 0, 16, 3, 3, 16, 0, 0),objectify( 0, 32, 3, 3, 16, -16, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    torch: {
			verts: [
				[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
				[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
				[objectify(9, 10, 9, 2, 10, 7, 6)], //north
				[objectify( 7, 10,  7, 2, 10, 7, 6)], //south
				[objectify(9, 10,  7, 2, 10, 7, 6)], //east
				[objectify( 7, 10, 9, 2, 10, 7, 6)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    wallTorch: {
      verts: [
				[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2)],
				[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2)],
				[customFace(9,14,13, 7,14,13, 7,4,17, 9,4,17, 7,6,2,10)], //north
				[customFace(7,13,11, 9,13,11, 9,3,15, 7,3,15, 7,6,2,10)], //south
				[customFace(9,13,11, 9,14,13, 9,4,17, 9,3,15, 7,6,2,10)], //east
				[customFace(7,14,13, 7,13,11, 7,3,15, 7,4,17, 7,6,2,10)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
    },
    lantern: {
			verts: [
				[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
				[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
				[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10)], //north
				[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10)], //south
				[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2)], //east
				[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    lanternHang: {
			verts: [
				[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
				[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
				[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10),objectify(9.5, 16, 8, 3, 3, 11, 2)], //north
				[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10),objectify(6.5, 16, 8, 3, 3, 11, 2)], //south
				[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2),objectify(8, 14, 6.5, 3, 4, 11, 1)], //east
				[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2),objectify(8, 14, 9.5, 3, 4, 11, 1)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    beacon: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 16, -96),objectify( 2, 0.001, 2, 12, 12, -32, 0)], //bottom
				[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify( 2, 3, 14, 12, 12, -16, 3)], //top
				[objectify(13, 13, 13, 10, 10, 3, 3),objectify( 16, 16,  16, 16, 16, -32, 0),objectify(14, 3, 14, 12, 3,  -16, 3)], //north
				[objectify( 3, 13,  3, 10, 10, 3, 3),objectify( 0,  16,  0,  16, 16, -32, 0),objectify(2,  3, 2,  12, 3,  -16, 3)], //south
				[objectify(13, 13,  3, 10, 10, 3, 3),objectify( 16, 16,  0,  16, 16, -32, 0),objectify(14, 3, 2,  12, 3,  -16, 3)], //east
				[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify(2,  3, 14, 12, 3,  -16, 3)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    cactus: {
			verts: [
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 15, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  1, 16, 16, 0, 0)], //south
				[objectify(15, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 1, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      hitbox: "cube"
		},
    pane: {
			verts: [
				[objectify( 0,  0,  7, 16, 2, 0, 7)], //bottom
				[objectify( 0, 16, 9, 16, 2, 0, 7)], //top
				[objectify(16, 16, 9, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
				[objectify(16, 16, 7, 2, 16, 7, 0)], //east
				[objectify(0, 16, 9, 2, 16, 7, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    portal: {
			verts: [
				[objectify(0, 0, 7, 16, 2, 0, 0)],
				[objectify(0, 16, 9, 16, 2, 0, 0)],
				[objectify(16, 16, 9, 16, 16, 0, 0)],
				[objectify(0, 16, 7, 16, 16, 0, 0)],
				[objectify(16, 16, 7, 2, 16, 0, 0)],
				[objectify(0, 16, 9, 2, 16, 0, 0)]
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    trapdoor: {
			verts: [
				[objectify(0, 0, 0, 16, 16, 0, 0)], //bottom
				[objectify(0, 3, 16, 16, 16, 0, 0)], //top
				[objectify(16, 3, 16, 16, 3, 0, 0)], //north
				[objectify(0, 3, 0, 16, 3, 0, 0)], //south
				[objectify(16, 3, 0, 16, 3, 0, 0)], //east
				[objectify(0, 3, 16, 16, 3, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true,
			flip: true
		},
		trapdoorOpen: {
			verts: [
				[objectify(0, 0, 13, 16, 3, 0, 0)], //bottom
				[objectify(0, 16, 16, 16, 3, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify(0, 16, 13, 16, 16, 0, 0)], //south
				[objectify(16, 16, 13, 3, 16, 0, 0)], //east
				[objectify(0, 16, 16, 3, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    wallFlat: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
				[objectify(0, 16, 16, 0, 0, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify(0, 16,  15, 16, 16, 0, 0)], //south
				[objectify(0, 0,  0, 0, 0, 0, 0)], //east
				[objectify(0, 0, 16, 0, 0, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    fence: {
			verts: [
				[objectify(6, 0, 6, 4, 4, 0, 1)], //bottom
				[objectify(6, 16, 10, 4, 4, 0, 1)], //top
				[objectify(10, 16, 10, 4, 16, 6, 0)], //north
				[objectify(6, 16, 6, 4, 16, 6, 0)], //south
				[objectify(10, 16, 6, 4, 16, 6, 0)], //east
				[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
		wallpost: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
		wall: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 16, 16, 6, 4, 5, 10)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 16, 16, 6, 16, 5, 0)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 16, 12, 4, 16, 12, 0)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 16, 16, 4, 16, 12, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
		wallu: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 13, 16, 6, 4, 5, 10)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 13, 16, 6, 13, 5, 3)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 13, 12, 4, 13, 12, 3)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 13, 16, 4, 13, 12, 3)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    fencq: {
			verts: [
				[objectify(6, 0, 6, 4, 4, 0, 1),objectify(10, 12, 7, 6, 2, 0, 2),objectify(10, 6, 7, 6, 2, 0, 2)], //bottom
				[objectify(6, 16, 10, 4, 4, 0, 1),objectify(10, 15, 9, 6, 2, 0, 2),objectify(10, 9, 9, 6, 2, 0, 2)], //top
				[objectify(10, 16, 10, 4, 16, 6, 0),objectify(16, 15, 9, 6, 3, 6, 0),objectify(16, 9, 9, 6, 3, 6, 0)], //north
				[objectify(6, 16, 6, 4, 16, 6, 0),objectify(10, 15, 7, 6, 3, 6, 0),objectify(10, 9, 7, 6, 3, 6, 0)], //south
				[objectify(10, 16, 6, 4, 16, 6, 0)], //east
				[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			rotate: true
		},
    fench: {
      verts:[
        [objectify(6,0,6,4,4,0,1),objectify(10,12,7,6,2,0,2),objectify(10,6,7,6,2,0,2),objectify(0,12,7,6,2,0,0),objectify(0,6,7,6,2,0,0)],
        [objectify(6,16,10,4,4,0,1),objectify(10,15,9,6,2,0,2),objectify(10,9,9,6,2,0,2),objectify(0,15,9,6,2,0,0),objectify(0,9,9,6,2,0,0)],
        [objectify(10,16,10,4,16,6,0),objectify(16,15,9,6,3,6,0),objectify(16,9,9,6,3,6,0),objectify(6,15,9,6,3,0,0),objectify(6,9,9,6,3,0,0)],
        [objectify(6,16,6,4,16,6,0),objectify(10,15,7,6,3,6,0),objectify(10,9,7,6,3,6,0),objectify(0,15,7,6,3,0,0),objectify(0,9,7,6,3,0,0)],
        [objectify(10,16,6,4,16,6,0)],
        [objectify(6,16,10,4,16,6,0)]
      ],
      cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			rotate: true
    },
		button: {
			verts: [
				[objectify(5, 6, 14, 6, 2, 5, 6)], //bottom
				[objectify(5, 10, 16, 6, 2, 5, 6)], //top
				[objectify(11, 10, 16, 6, 4, 5, 6)], //north
				[objectify(5, 10, 14, 6, 4, 5, 6)], //south
				[objectify(11, 10, 14, 2, 4, 5, 6)], //east
				[objectify(5, 10, 16, 2, 4, 5, 6)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
			flip: true,
			rotate: true
		},
    chain: {
			verts: [
				[objectify(8, 0, 8, 0.5, 0.5, 0, 0)], //bottom
				[objectify(8, 16, 8, 0.5, 0.5, 0, 0)], //top
				[objectify(9.5, 16, 8, 3, 16, 3, 0)], //north
				[objectify(6.5, 16, 8, 3, 16, 3, 0)], //south
				[objectify(8, 16, 6.5, 3, 16, 0, 0)], //east
				[objectify(8, 16, 9.5, 3, 16, 0, 0)] //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    pot: {
			verts: [
				[objectify(5, 0, 5, 6, 6, 5, 10)], //bottom
				[objectify(5, 6, 11, 6, 6, 5, 5), objectify(6, 4, 10, 4, 4, -16, 0)], //top
				[objectify(11, 6, 11, 6, 6, 5, 10), objectify(11, 6, 6, 6, 6, 5, 10)], //north
				[objectify(5, 6, 5, 6, 6, 5, 10), objectify(5, 6, 10, 6, 6, 5, 10)], //south
				[objectify(11, 6, 5, 6, 6, 5, 10), objectify(6, 6, 5, 6, 6, 5, 10)], //east
				[objectify(5, 6, 11, 6, 6, 5, 10), objectify(10, 6, 11, 6, 6, 5, 10)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    potCross: {
			verts: [
				[], //bottom
				[], //top
				[customFace(2,4,2, 14,4,14, 14,-12,14, 2,-12,2, 0,0)], //north
				[customFace(14,4,2, 2,4,14, 2,-12,14, 14,-12,2, 0,0)], //south
				[customFace(14,4,14, 2,4,2, 2,-12,2, 14,-12,14, 0,0)], //east
				[customFace(2,4,14, 14,4,2, 14,-12,2, 2,-12,14, 0,0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
    carpet: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 1, 16, 16, 16, 0, 0)], //top
				[objectify(16, 1, 16, 16, 1, 0, 0)], //north
				[objectify( 0, 1,  0, 16, 1, 0, 0)], //south
				[objectify(16, 1,  0, 16, 1, 0, 0)], //east
				[objectify( 0, 1, 16, 16, 1, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 1,
				south: 1,
				east: 1,
				west: 1
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: []
		},
    bed: {
			verts: [
				[objectify( 0, 3,  0, 16, 16, -16, 0),objectify( 0, 3,  16, 16, 16, -16, 0),
				objectify(0, 0, 0, 3,3,  38,0),
				objectify(13, 0, 29, 3,3,38,0),
				objectify(0, 0, 29, 3,3, 38,0),
				objectify(13, 0, 0, 3,3, 38,0)], //bottom
				[objectify( 0, 9, 32, 16, 16, 16, 0),objectify( 0, 9, 16, 16, 16, 0, 0)], //top
				[objectify(16, 9, 32, 16, 6, 80, 6),
				objectify(3, 3, 3, 3,3,  38,3),
				objectify(16, 3, 32, 3,3,32,3),
				objectify(3, 3, 32, 3,3, 35,3),
				objectify(16, 3, 3, 3,3, 41,3)], //north
				[objectify( 0, 9,  0, 16, 6, 80, 0),
				objectify(0, 3, 0, 3,3,  32,3),
				objectify(13, 3, 29, 3,3,38,3),
				objectify(0, 3, 29, 3,3, 41,3),
				objectify(13, 3, 0, 3,3, 35,3)], //south
				[objectify( 16, 9,  0, 16, 6, 48, 0),objectify( 16, 9,  16, 16, 6, 64, 0),
				objectify(3, 3, 0, 3,3,  41,3),
				objectify(16, 3, 29, 3,3,35,3),
				objectify(3, 3, 29, 3,3, 38,3),
				objectify(16, 3, 0, 3,3, 32,3)], //east
				[objectify( 0, 9, 32, 16, 6, 64, 6),objectify( 0, 9, 16, 16, 6, 48, 6),
				objectify(0, 3, 3, 3,3,  35,3),
				objectify(13, 3, 32, 3,3,41,3),
				objectify(0, 3, 32, 3,3, 32,3),
				objectify(13, 3, 3, 3,3, 38,3)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
      rotate: true
		},
    cactusPot: {
      verts: [
				[], //bottom
				[objectify( 6, 1, 10, 4,  4, 6, 6)], //top
				[objectify(10, 1, 10, 4, 11, 6, 0)], //north
				[objectify( 6, 1,  6, 4, 11, 6, 0)], //south
				[objectify(10, 1,  6, 4, 11, 6, 0)], //east
				[objectify( 6, 1, 10, 4, 11, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
    crop: {
			verts: [
        [objectify(0,0,0,0,0,0,0)],
        [objectify(0,0,0,0,0,0,0)],
        [objectify(16,16,4,16,16,0,0),objectify(16,16,12,16,16,0,0)],
        [objectify(0,16,12,16,16,0,0),objectify(0,16,4,16,16,0,0)],
        [objectify(4,16,0,16,16,0,0),objectify(12,16,0,16,16,0,0)],
        [objectify(12,16,16,16,16,0,0),objectify(4,16,16,16,16,0,0)]
      ],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: []
		},
    anvil: {
			verts: [
        [objectify(2,0,2,12,12,0,0),objectify(0,10,3,16,10,0,0)],
        [objectify(2,4,14,12,12,0,0),objectify(3,5,12,10,8,0,0),objectify(0,16,13,16,10,-16,3)],
        [objectify(14,4,14,12,4,0,0),objectify(16,16,13,16,6,0,0),objectify(13,5,12,10,1,0,0),objectify(12,10,11,8,5,0,0)],
        [objectify(2,4,2,12,4,0,0),objectify(0,16,3,16,6,0,0),objectify(3,5,4,10,1,0,0),objectify(4,10,5,8,5,0,0)],
        [objectify(14,4,2,12,4,0,0),objectify(16,16,3,10,6,0,0),objectify(13,5,4,8,1,0,0),objectify(12,10,5,6,5,0,0)],
        [objectify(2,4,14,12,4,0,0),objectify(0,16,13,10,6,0,0),objectify(3,5,12,8,1,0,0),objectify(4,10,11,6,5,0,0)]
      ],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 21,
			varients: [],
      rotate: true
		},
    liquidSurface: {
			verts: [
				[objectify( 0,    0,  0, 16,   16, 0, 0), objectify( 0, 14.5, 0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 14.5, 16, 16,   16, 0, 0)], //top
				[objectify(16, 14.5, 16, 16, 14.5, 0, 0)], //north
				[objectify( 0, 14.5,  0, 16, 14.5, 0, 0)], //south
				[objectify(16, 14.5,  0, 16, 14.5, 0, 0)], //east
				[objectify( 0, 14.5, 16, 16, 14.5, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
    sporeBlossom: {
      verts: [
        [objectify( 1, 15.9, 1, 14, 14, -15, 1)], //bottom
        [objectify( 1, 15.9, 15, 14, 14, -15, 1)], //top
        [customFace(0,15.9,8, 16,15.9,8, 16,11.1,-8, 0,11.1,-8, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,-8, 16,11.1,-8, 16,16,-16,-16)],
        [customFace(0,15.9,8, 16,15.9,8, 16,11.1,24, 0,11.1,24, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,24, 16,11.1,24, 16,16,-16,-16)], //southobjectify( 0, 16,  0, 16, 16, 0, 0)
        [customFace(8,15.9,0, 8,15.9,16, -8,11.1,16, -8,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, -8,11.1,0, -8,11.1,16, 16,16,-16,-16)],
        [customFace(8,15.9,0, 8,15.9,16, 24,11.1,16, 24,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, 24,11.1,0, 24,11.1,16, 16,16,-16,-16)]
      ],
      cull: {
        top: 0,
        bottom: 0,
        north: 0,
        south: 0,
        east: 0,
        west: 0
      },
		},
    azalea: {
			verts: [
				[objectify( 0,  8,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0),customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, -32,0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0),customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, -32,0)], //south
				[objectify(16, 16,  0, 16, 16, 0, 0),customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, -32,0)], //east
				[objectify( 0, 16, 16, 16, 16, 0, 0),customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, -32,0)]  //west
			],
			cull: {
				top: 3,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			}
		},
    azaleaPot: {
			verts: [
				[objectify( 4,  -7,  4, 8, 8, 4, 4)], //bottom
				[objectify( 4, -1, 12, 8, 8, 4, 4)], //top
				[objectify(12, -1, 12, 8, 11, 4, 5),customFace(4,-1,4, 12,-1,12, 12,-12,12, 4,-12,4, -12,5,8,11)], //north
				[objectify( 4, -1,  4, 8, 11, 4, 5),customFace(12,-1,4, 4,-1,12, 4,-12,12, 12,-12,4, -12,5,8,11)], //south
				[objectify(12, -1,  4, 8, 11, 4, 5),customFace(12,-1,12, 4,-1,4, 4,-12,4, 12,-12,12, -12,5,8,11)], //east
				[objectify( 4, -1, 12, 8, 11, 4, 5),customFace(4,-1,12, 12,-1,4, 12,-12,4, 4,-12,12, -12,5,8,11)]  //west
			],
			cull: {
				top: 3,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
    sunflower: {
			verts: [
				[customFace(0,34,7, 16,34,7, 16,18,11, 0,18,11, 0,0)], //bottom
				[customFace(16,34,7, 0,34,7, 0,18,11, 16,18,11, 0,0)], //top
				[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, -16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
				[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, -16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
				[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, -16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
				[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, -16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			}
		},
    cake:{
      verts: [
        [objectify(1,0,1,14,14,1,1)],
        [objectify(1,8,15,14,14,1,1)],
        [objectify(15,8,15,14,8,1,8)],
        [objectify(1,8,1,14,8,1,8)],
        [objectify(15,8,1,14,8,1,8)],
        [objectify(1,8,15,14,8,1,8)]
      ],
      cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			}
    },
    stonecutter:{
      verts:[
        [objectify(0,0,0,16,16,0,0)],
        [objectify(0,9,16,16,16,0,0)],
        [objectify(16,9,16,16,9,0,7),objectify(16,16,8,16,7,16,9)],
        [objectify(0,9,0,16,9,0,7),objectify(0,16,8,16,7,16,9)],
        [objectify(16,9,0,16,9,0,7)],
        [objectify(0,9,16,16,9,0,7)]
      ],
      cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			}
    },
    itemFrame:{
      verts: [
        [objectify(2,2,15,12,1,-16,0),objectify(3,13,15,10,1,-16,0)],
        [objectify(2,14,16,12,1,-16,0),objectify(3,3,16,10,1,-16,0)],
        [objectify(14,14,16,12,12,-16,0)],
        [objectify(3,13,15.5,10,10,3,3),objectify(2,14,15,11,1,-14,2),objectify(13,14,15,1,11,-3,2),objectify(3,3,15,11,1,-13,13),objectify(2,13,15,1,11,-14,3)],
        [objectify(14,14,15,1,12,-16,0),objectify(3,13,15,1,10,-16,0)],
        [objectify(2,14,16,1,12,-16,0),objectify(13,13,16,1,10,-16,0)]
      ],
      cull: {
				top: 0,
				bottom: 0,
				north: 3,
				south: 0,
				east: 0,
				west: 0
			},
      rotate:true
    },
    
    playerHand: {
      verts: [
				[objectify( 6,  6,  6, 4,  4, 0, 0)], //bottom
				[objectify( 6, 18, 10, 4,  4, 0, 0)], //top
				[objectify(10, 18, 10, 4, 12, 0, 0)], //north
				[objectify( 6, 18,  6, 4, 12, 0, 0)], //south
				[objectify(10, 18,  6, 4, 12, 0, 0)], //east
				[objectify( 6, 18, 10, 4, 12, 0, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
    item: {
      verts: generateItemShape(),
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null
    },
    cube2: {
      verts: [
        [objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0)],
        [objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)],
        [objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0)],
        [objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0)],
        [objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0)],
        [objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)]
      ],
      cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
    },
    cube3: {
      verts: [
        [objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0)],
        [objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)],
        [objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0)],
        [objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0)],
        [objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0)],
        [objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)]
      ],
      cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
    },
    cube4: {
      verts: [
        [objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0)],
        [objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)],
        [objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0)],
        [objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0)],
        [objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0)],
        [objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)]
      ],
      cull: {
        top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
      }
    },
    cow: {
      verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16,  8,  4,  8,  8,  0,  0)], //bottom
				[objectify( 0, 12, 16, 16, 16, 0, 0), objectify(16, 16, 12,  8,  8,  0,  0)], //top
				[objectify(16, 12, 16, 16, 12, 0, 4), objectify(24, 16, 12,  8,  8, 16,  0)], //north
				[objectify( 0, 12,  0, 16, 12, 0, 4), objectify(16, 16,  4,  8,  8, 16,  0)], //south
				[objectify(16, 12,  0, 16, 12, 0, 4), objectify(24, 16,  4,  8,  8, 16,  0)], //east
				[objectify( 0, 12, 16, 16, 12, 0, 4), objectify(16, 16, 12,  8,  8, 16,  0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 12,
    },
    blockParticle: {
      verts: [
				[], //bottom
				[], //top
				[objectify( 16, 16, 8, 16, 16, 0, 0)], //north
				[objectify(  0, 16, 8, 16, 16, 0, 0)], //south
				[], //east
				[]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			}
    },
	}
	win.shapes = shapes
  
  for(var shape = 0; shape < 8; shape ++){
    shapes["layer"+(shape+1)] = {
      verts: layerShape((shape+1)*2),
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			}
    }
  }
  
  //automatically set size
  for(var shape in shapes){
    shape = shapes[shape]
    let v = shape.verts
    let s = v[0].length + v[1].length + v[2].length + v[3].length + v[4].length + v[5].length
    shape.size = s
    shape.texVerts = []
    shape.varients = []
    shape.buffer = null
    if(typeof shape.hitbox === "string"){
      shape.hitbox = shapes[shape.hitbox]
    }
  }

	function compareArr(arr, out) {
		let minX = 1000
		let maxX = -1000
		let minY = 1000
		let maxY = -1000
		let minZ = 1000
		let maxZ = -1000
		let num = 0
		for (let i = 0; i < arr.length; i += 3) {
			num = arr[i]
			minX = minX > num ? num : minX
			maxX = maxX < num ? num : maxX
			num = arr[i + 1]
			minY = minY > num ? num : minY
			maxY = maxY < num ? num : maxY
			num = arr[i + 2]
			minZ = minZ > num ? num : minZ
			maxZ = maxZ < num ? num : maxZ
		}
		out[0] = minX
		out[1] = minY
		out[2] = minZ
		out[3] = maxX
		out[4] = maxY
		out[5] = maxZ
		return out
	}
  function arrayValues(a1,a2){
    if(a1.length !== a2.length) return false
    let minLen = a1.length
    for(var i=0; i<minLen; i++){
      if(a1[i] !== a2[i]){
        return false
      }
    }
    return true
  }

	function initShapes() {
		function mapCoords(rect, face) {
      if(rect.custom) return mapCustomCoords(rect)
			let x = rect.x
			let y = rect.y
			let z = rect.z
			let w = rect.w
			let h = rect.h
			let tx = rect.tx
			let ty = rect.ty
			let tex = [tx+w,ty, tx,ty, tx,ty+h, tx+w,ty+h]
      if(rect.txf){
        tex[0] = tx
        tex[2] = tx+w
        tex[4] = tx+w
        tex[6] = tx
      }
      if(rect.rt){//doesn't work
        tex.push(...tex.splice(0,2))
      }
			let pos = null
			switch(face) {
				case 0: // Bottom
					pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
					break
				case 1: // Top
					pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
					break
				case 2: // North
					pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
					break
				case 3: // South
					pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
					break
				case 4: // East
					pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
					break
				case 5: // West
					pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
					break
			}
			pos = pos.map(c => c / 16 - 0.5)
			let minmax = compareArr(pos, [])
			pos.max = minmax.splice(3, 3)
			pos.min = minmax
			tex = tex.map(c => c / 16 / 16)
			
			return {
				pos: pos,
				tex: tex
			}
		}
    function mapCustomCoords(coords){
      let {x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th} = coords
      let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
      let pos = [x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4]
      pos = pos.map(c => c / 16 - 0.5)
      let minmax = compareArr(pos, [])
      pos.max = minmax.splice(3, 3)
      pos.min = minmax
      tex = tex.map(c => c / 16 / 16)

      return {pos,tex}
		}
		
		// 90 degree clockwise rotation; returns a new shape object
		function rotate(shape, bit) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = face[k + 1]
						c[k + 2] = -face[k]
					}
					
					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
					if (i === 0) {
						// Bottom
						c.push(...c.splice(0, 3))
						tex[i][j].push(...tex[i][j].splice(0, 2))
					}
					if (i === 1) {
						// Top
						c.unshift(...c.splice(-3, 3))
						tex[i][j].unshift(...tex[i][j].splice(-2, 2))
					}

					let minmax = compareArr(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax
				}
			}
			let temp = tex[2] // North
			tex[2] = tex[5] // North = West
			tex[5] = tex[3] // West = South
			tex[3] = tex[4] // South = East
			tex[4] = temp // East = North

			temp = pos[2] // North
			pos[2] = pos[5] // North = West
			pos[5] = pos[3] // West = South
			pos[3] = pos[4] // South = East
			pos[4] = temp // East = North

			let cull2 = {
				top: cull.top,
				bottom: cull.bottom,
				north: cull.west,
				west: cull.south,
				south: cull.east,
				east: cull.north
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: true,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients,
        bit: bit,
        rotated: true,
        rotateTimes: (shape.rotateTimes || 0) + 1
			}
		}

		// Reflect over the y plane; returns a new shape object
		function flip(shape, bit) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j].slice().reverse()
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = -face[k + 1]
						c[k + 2] = face[k]
					}
					let minmax = compareArr(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax

					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
				}
			}
			let temp = pos[0] // Bottom
			pos[0] = pos[1] // Bottom = Top
			pos[1] = temp // Top = Bottom

			temp = tex[0] // Bottom
			tex[0] = tex[1] // Bottom = Top
			tex[1] = temp // Top = Bottom

			let cull2 = {
				top: cull.bottom,
				bottom: cull.top,
				north: (cull.north & 1) << 1 | (cull.north & 2) >> 1,
				west: (cull.west & 1) << 1 | (cull.west & 2) >> 1,
				south: (cull.south & 1) << 1 | (cull.south & 2) >> 1,
				east: (cull.east & 1) << 1 | (cull.east & 2) >> 1
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: shape.rotate,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients,
        bit: bit
			}
		}

		for (let shape in shapes) {
			let obj = shapes[shape]
			let verts = obj.verts
			
			// Populate the vertex coordinates
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				let texArr = []
				obj.texVerts.push(texArr)
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let mapped = mapCoords(face, i)
					side[j] = mapped.pos
					texArr.push(mapped.tex)
				}
			}

			if (obj.rotate) {
				let v = obj.varients
				let east = rotate(obj, 4<<10)
				let south = rotate(east, 2<<10)
				let west = rotate(south, 6<<10)
				v[0] = obj
				v[2] = south
				v[4] = east
				v[6] = west
			}
			if (obj.flip) {
				let v = obj.varients
				v[1] = flip(obj,1<<10)
				if (obj.rotate) {
					v[3] = flip(v[2], 3<<10)
					v[5] = flip(v[4], 5<<10)
					v[7] = flip(v[6], 7<<10)
				}
			}

			obj.buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts.flat(2)), gl.STATIC_DRAW)
		}

    function makeBlock(tex,shape,block){
      block.textures = tex
      block.shape = shape
      block.shadow = true
      block.transparent = false
      block.solid = true
    }
    
    function rotTex(tex,n){
      tex = tex.slice()
      if(n){
        for(var i=0; i<n; i++){
          let temp = tex[2] // North
          tex[2] = tex[5] // North = West
          tex[5] = tex[3] // West = South
          tex[3] = tex[4] // South = East
          tex[4] = temp // East = North
        }
      }else{
        let temp = tex[2] // North
        tex[2] = tex[5] // North = West
        tex[5] = tex[3] // West = South
        tex[3] = tex[4] // South = East
        tex[4] = temp // East = North
      }
      return tex
    }
    
    win.initBlockData = function(){
		for (let i = 0; i < BLOCK_COUNT; i++) {
			let baseBlock = blockData[i]
      for(var t=0; t<baseBlock.textures.length; t++){
        if(semiTransTextures.includes(baseBlock.textures[t])){
          baseBlock.semiTrans = true
          break
        }
      }
      
			let slabBlock = Object.create(baseBlock)
			let stairBlock = Object.create(baseBlock)
      let crossBlock = Object.create(baseBlock)
      let tallcrossBlock = Object.create(baseBlock)
      let doorBlock = Object.create(baseBlock)
      let torchBlock = Object.create(baseBlock)
      let lanternBlock = Object.create(baseBlock)
      let lanternHangBlock = Object.create(baseBlock)
      let beaconBlock = Object.create(baseBlock)
      let cactusBlock = Object.create(baseBlock)
      let paneBlock = Object.create(baseBlock)
      let portalBlock = Object.create(baseBlock)
      let trapdoorBlock = Object.create(baseBlock)
      let openTrapdoor = Object.create(baseBlock)
      let wallFlatBlock = Object.create(baseBlock)
      let fenceBlock = Object.create(baseBlock)
			let wallPostBlock = Object.create(baseBlock)
			let wallBlock = Object.create(baseBlock)
			let walluBlock = Object.create(baseBlock)
      let fencqBlock = Object.create(baseBlock)
			let buttonBlock = Object.create(baseBlock)
      let chainBlock = Object.create(baseBlock)
      let potBlock = Object.create(baseBlock)
      let potCrossBlock = Object.create(baseBlock)
      let carpetBlock = Object.create(baseBlock)
      baseBlock.shape = shapes.cube
			slabBlock.shape = shapes.slab
      slabBlock.transparent = true
			stairBlock.shape = shapes.stair
      stairBlock.transparent = true
      crossBlock.shape = shapes.cross
      tallcrossBlock.shape = shapes.tallCross
      doorBlock.shape = shapes.door
      doorBlock.solid = false
      torchBlock.shape = shapes.torch
      lanternBlock.shape = shapes.lantern
      lanternHangBlock.shape = shapes.lanternHang
      beaconBlock.shape = shapes.beacon
      cactusBlock.shape = shapes.cactus
      paneBlock.shape = shapes.pane
      portalBlock.shape = shapes.portal
      wallFlatBlock.shape = shapes.wallFlat
      trapdoorBlock.shape = shapes.trapdoor
      openTrapdoor.shape = shapes.trapdoorOpen
      fenceBlock.shape = shapes.fence
      fenceBlock.transparent = true
      wallPostBlock.shape = shapes.wallpost
      wallPostBlock.transparent = true
			wallBlock.shape = shapes.wall
			walluBlock.shape = shapes.wallu
      fencqBlock.shape = shapes.fencq
			buttonBlock.shape = shapes.button
      chainBlock.shape = shapes.chain
      potBlock.shape = shapes.pot
      potCrossBlock.shape = shapes.potCross
      carpetBlock.shape = shapes.carpet
      carpetBlock.shadow = false
      carpetBlock.transparent = true
      if(baseBlock.bed) baseBlock.shape = shapes.bed
      if(baseBlock.rotate) baseBlock.shape = shapes.rotate
      if(baseBlock.cactus) potCrossBlock.shape = shapes.cactusPot
      if(baseBlock.crop) baseBlock.shape = shapes.crop
      if(baseBlock.anvil) baseBlock.shape = shapes.anvil
      if(baseBlock.liquid) slabBlock.shape = shapes.liquidSurface
      if(baseBlock._1PixLower){baseBlock.shape = shapes._1PixLower; baseBlock.transparent = true}
      if(baseBlock.item) baseBlock.shape = shapes.item
      if(baseBlock.torch) slabBlock.shape = shapes.wallTorch
      if(baseBlock.sporeBlossom) baseBlock.shape = shapes.sporeBlossom
      if(baseBlock.azalea){
        baseBlock.shape = shapes.azalea
        potCrossBlock.shape = shapes.azaleaPot
        var t = baseBlock.potTex
        potCrossBlock.textures = [t[0],t[0],t[1],t[1],t[1],t[1]]
      }
      if(baseBlock.sunflower) baseBlock.shape = shapes.sunflower
      if(baseBlock.sideCross){baseBlock.shape = shapes.sideCross; slabBlock.shape = shapes.bottomCross}
      if(baseBlock.layers){
        torchBlock.shape = shapes.layer1
        torchBlock.solid = true
        torchBlock.shadow = false
        torchBlock.dropAmount = 1
        slabBlock.shape = shapes.layer2
        slabBlock.solid = true
        slabBlock.shadow = false
        slabBlock.dropAmount = 2
        stairBlock.shape = shapes.layer3
        stairBlock.solid = true
        stairBlock.shadow = false
        stairBlock.dropAmount = 3
        crossBlock.shape = shapes.layer4
        crossBlock.solid = true
        crossBlock.shadow = false
        crossBlock.dropAmount = 4
        tallcrossBlock.shape = shapes.layer5
        tallcrossBlock.solid = true
        tallcrossBlock.shadow = false
        tallcrossBlock.dropAmount = 5
        lanternBlock.shape = shapes.layer6
        lanternBlock.solid = true
        lanternBlock.shadow = false
        lanternBlock.dropAmount = 6
        lanternHangBlock.shape = shapes.layer7
        lanternHangBlock.solid = true
        lanternHangBlock.shadow = false
        lanternHangBlock.dropAmount = 7
        doorBlock.shape = shapes.layer8
        doorBlock.solid = true
        doorBlock.shadow = false
        doorBlock.dropAmount = 8
      }
      if(baseBlock.name === "grass"){
        crossBlock.shape = shapes.cube
        crossBlock.textures = ["dirt","grassTop","snowGrass","snowGrass","snowGrass","snowGrass"]
        crossBlock.solid = true
        crossBlock.transparent = false
        crossBlock.shadow = true
        tallcrossBlock.shape = shapes._1PixLower
        tallcrossBlock.textures = ["dirt","dirtPathTop","dirtPathSide","dirtPathSide","dirtPathSide","dirtPathSide"]
        tallcrossBlock.solid = true
        tallcrossBlock.transparent = true
        tallcrossBlock.shadow = true
      }
      if(baseBlock.name === "farmland"){
        slabBlock.textures = []
        copyArr(baseBlock.textures, slabBlock.textures)
        slabBlock.textures[1] = "farmlandMoist"
        slabBlock.shape = shapes._1PixLower
      }
      if(baseBlock.mushroomBlock){
        var cap = baseBlock.name
        var pore = "mushroomBlockInside"
        makeBlock(new Array(6).fill(pore), shapes.cube, slabBlock)
        makeBlock([pore,cap,pore,pore,pore,pore], shapes.cube, stairBlock)
        makeBlock([cap,pore,pore,pore,pore,pore], shapes.cube, crossBlock)
        makeBlock([cap,cap,pore,pore,pore,pore], shapes.cube, tallcrossBlock)
        makeBlock([pore,pore,cap,pore,pore,pore], shapes.rotate, doorBlock)
        makeBlock([pore,cap,cap,pore,pore,pore], shapes.rotate, paneBlock)
        makeBlock([cap,pore,cap,pore,pore,pore], shapes.rotate, portalBlock)
        makeBlock([cap,cap,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)
      }
      if(baseBlock.cake) baseBlock.shape = shapes.cake
      if(baseBlock.stonecutter) baseBlock.shape = shapes.stonecutter
      if(baseBlock.itemFrame) baseBlock.shape = shapes.itemFrame
			blockData[i | SLAB] = slabBlock
			blockData[i | STAIR] = stairBlock
      blockData[i | CROSS] = crossBlock
      blockData[i | TALLCROSS] = tallcrossBlock
      blockData[i | DOOR] = doorBlock
      blockData[i | TORCH] = torchBlock
      blockData[i | LANTERN] = lanternBlock
      blockData[i | LANTERNHANG] = lanternHangBlock
      if(baseBlock.beacon) blockData[i | BEACON] = beaconBlock
      if(baseBlock.cactus) blockData[i | CACTUS] = cactusBlock
      blockData[i | PANE] = paneBlock
      blockData[i | PORTAL] = portalBlock
      blockData[i | WALLFLAT] = wallFlatBlock
      blockData[i | TRAPDOOR] = trapdoorBlock
      blockData[i | TRAPDOOROPEN] = openTrapdoor
      blockData[i | FENCE] = fenceBlock
			blockData[i | WALLPOST] = wallPostBlock
			blockData[i | WALL] = wallBlock
			blockData[i | WALLU] = walluBlock
      blockData[i | FENCQ] = fencqBlock
			if(baseBlock.button) blockData[i | BUTTON] = buttonBlock
      if(baseBlock.chain) blockData[i | CHAIN] = chainBlock
      if(baseBlock.pot) blockData[i | POT] = potBlock
      blockData[i | POTCROSS] = potCrossBlock
      if(baseBlock.carpet) blockData[i | CARPET] = carpetBlock
      let v
      if(baseBlock.shape.rotate){
        let t = baseBlock.textures
        v = baseBlock.shape.varients
        for (let j = 0; j < v.length; j++) {
          if (v[j]) {
            let block = Object.create(baseBlock)
            block.shape = v[j]
            if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
            blockData[i | v[j].bit] = block
          }
        }
      }
			v = slabBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | SLAB | v[j].bit] = block
				}
			}
			v = stairBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | STAIR | v[j].bit] = block
				}
			}
      v = doorBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.solid = false
					blockData[i | DOOR | v[j].bit] = block
				}
			}
      v = paneBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
        let t = baseBlock.textures
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
					blockData[i | PANE | v[j].bit] = block
				}
			}
      v = portalBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | PORTAL | v[j].bit] = block
				}
			}
      v = wallFlatBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | WALLFLAT | v[j].bit] = block
				}
			}
      v = trapdoorBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | TRAPDOOR | v[j].bit] = block
				}
			}
      v = openTrapdoor.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | TRAPDOOROPEN | v[j].bit] = block
				}
			}
			v = wallBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | WALL | v[j].bit] = block
				}
			}
			v = walluBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | WALLU | v[j].bit] = block
				}
			}
      v = fencqBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | FENCQ | v[j].bit] = block
				}
			}
			v = buttonBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j] && blockData[i].button) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | BUTTON | v[j].bit] = block
				}
			}
		}
    }
	}
    
	let indexOrder;
	(function() {
		let arr = []
		for (let i = 0; i < 100000; i++) {
			arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4)
		}
		indexOrder = new Uint32Array(arr)
	})()

	let hexagonVerts
	let slabIconVerts
	let stairIconVerts
  let _2dIconVerts
  let fenceIconVerts
	let wallPostIconVerts
	let walluIconVerts
	let wallIconVerts
  let fencqIconVerts
	let buttonIconVerts
  let carpetIconVerts
  let trapdoorIconVerts
  let azaleaIconVerts
  let cactusIconVerts
  let snowIconVerts
	let blockIcons
  let blockIconError
	{
		let side = Math.sqrt(3) / 2
		let s = side
		let q = s / 2
    let p = s / 16
		hexagonVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])

		slabIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])

		stairIconVerts = [
			-s,0.5,0,0,1,         0,1,1,0,1,         q,0.75,1,0.5,1,    -q,0.25,0,0.5,1,    // top of the top step
			-q,-0.25,0,0,1,       q,0.25,1,0,1,      s,0,1,0.5,1,        0,-0.5,0,0.5,1,    // top of the bottom step
			-q,0.25,0,0,0.6,      q,0.75,1,0,0.6,    q,0.25,1,0.5,0.6,  -q,-0.25,0,0.5,0.6, // front of the top step
			0,-0.5,0,0,0.6,       s,0,1,0,0.6,       s,-0.5,1,0.5,0.6,   0,-1,0,0.5,0.6,    // front of the bottom step
			-s,0.5,0,0,0.8,      -q,0.25,0.5,0,0.8, -q,-0.75,0.5,1,0.8, -s,-0.5,0,1,0.8,    // side of the top step
			-q,-0.25,0.5,0.5,0.8, 0,-0.5,1,0.5,0.8,  0,-1,1,1,0.8,      -q,-0.75,0.5,1,0.8, // side of the bottom step
		]
    _2dIconVerts = [
      //-1,-1,0,0,1,          1,-1,1,0,1,        1,1,1,1,1          -1,1,0,1,1 //x, y, tx, ty, useless
      1,1,1,0,1,         1,-1,1,1,1,         -1,-1,0,1,1,    -1,1,0,0,1
    ]
    fenceIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		
		wallPostIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		
		wallIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		walluIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
    fencqIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		buttonIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])
    carpetIconVerts = new Float32Array([
			0, 1-(p*17), 1, side, 0.5-(p*17), 1, 0, -(p*17), 1, -side, 0.5-(p*17), 1,
			0, -(p*17), 1, side, 0.5-(p*17), 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5-(p*17), 1, 0, -(p*17), 1, 0, -1, 1, -side, -0.5, 1,
		])
    trapdoorIconVerts = new Float32Array([
			0, 1-(p*15), 1, side, 0.5-(p*15), 1, 0, -(p*15), 1, -side, 0.5-(p*15), 1,
			0, -(p*15), 1, side, 0.5-(p*15), 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5-(p*15), 1, 0, -(p*15), 1, 0, -1, 1, -side, -0.5, 1,
		])
    snowIconVerts = new Float32Array([
			0, 1-(p*16), 1, side, 0.5-(p*16), 1, 0, -(p*16), 1, -side, 0.5-(p*16), 1,
			0, -(p*16), 1, side, 0.5-(p*16), 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5-(p*15), 1, 0, -(p*16), 1, 0, -1, 1, -side, -0.5, 1,
		])
    cactusIconVerts = new Float32Array([
			0, 1-p, 1, side, 0.5-p, 1, 0, -p, 1, -side, 0.5-p, 1,
			-p, 0, 1, side-p, 0.5, 1, side-p, -0.5, 1, -p, -1, 1,
			-side+p, 0.5, 1, p, 0, 1, p, -1, 1, -side+p, -0.5, 1,
		])
	}
	function genIcons() {
		blockIcons = [null]
		blockIcons.lengths = []
		let texOrder = [ 1, 4, 3 ]
		let shadows = [ 1, 0.4, 0.7 ]
		let scale = 0.16 / height * inventory.size
    let prevTexture
    
    let data = []
    for (let j = 11; j >= 0; j--) {
      data.push(-hexagonVerts[j * 3 + 0] * scale)
      data.push(hexagonVerts[j * 3 + 1] * scale)
      data.push(0.1666666)
      data.push(textureCoords[textureMap.error][(j * 2 + 0) % 8])
      data.push(textureCoords[textureMap.error][(j * 2 + 1) % 8])
      data.push(shadows[floor(j / 4)])
    }
    let buffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
    blockIconError = buffer
    blockIconError.length = 6 * 3
    
		for (let i = 1; i < BLOCK_COUNT; i++) {
			let data = []
      let v, buffer
			let block = blockData[i]
      if(block.icon){
        block = blockData[blockIds[block.icon]]
      }
      if(block.iconTexture){
        prevTexture = block.textures
        block.textures = new Array(6).fill(block.iconTexture)
      }
      if(block.flatIcon){
        v = _2dIconVerts
        for (let j = 3; j >= 0; j--) {
          let tex = textureCoords[textureMap[block.textures[2]]]
          let tx = tex[0]
          let ty = tex[1]
          data.push(-v[j * 5 + 0] * scale)
          data.push(v[j * 5 + 1] * scale)
          data.push(0.1666666)
          data.push(tx + v[j * 5 + 2] / 16)
          data.push(ty + v[j * 5 + 3] / 16)
          data.push(1)
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6
        blockIcons[i | CROSS] = buffer
        blockIcons.lengths[i | CROSS] = 6
        blockIcons[i | TALLCROSS] = buffer
        blockIcons.lengths[i | TALLCROSS] = 6
        blockIcons[i | WALLFLAT] = buffer
        blockIcons.lengths[i | WALLFLAT] = 6
        blockIcons[i | TORCH] = buffer
        blockIcons.lengths[i | TORCH] = 6
        blockIcons[i | PANE] = buffer
        blockIcons.lengths[i | PANE] = 6
      }else if(block.carpet){
        v = carpetIconVerts
        for (let j = 11; j >= 0; j--) {
          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
          data.push(-v[j * 3 + 0] * scale)
          data.push(v[j * 3 + 1] * scale)
          data.push(0.1666666)
          data.push(tex[(j * 2 + 0) % 8])
          data.push(tex[(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6 * 3
        blockIcons[i | CARPET] = buffer
        blockIcons.lengths[i | CARPET] = 6 * 3
      }else if(block.trapdoor){
        v = trapdoorIconVerts
        for (let j = 11; j >= 0; j--) {
          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
          data.push(-v[j * 3 + 0] * scale)
          data.push(v[j * 3 + 1] * scale)
          data.push(0.1666666)
          data.push(tex[(j * 2 + 0) % 8])
          data.push(tex[(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6 * 3
        blockIcons[i | TRAPDOOR] = buffer
        blockIcons.lengths[i | TRAPDOOR] = 6 * 3
        blockIcons[i | TRAPDOOROPEN] = buffer
        blockIcons.lengths[i | TRAPDOOROPEN] = 6 * 3
      }else if(block.layers){
        v = snowIconVerts
        for (let j = 11; j >= 0; j--) {
          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
          data.push(-v[j * 3 + 0] * scale)
          data.push(v[j * 3 + 1] * scale)
          data.push(0.1666666)
          data.push(tex[(j * 2 + 0) % 8])
          data.push(tex[(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6 * 3
        blockIcons[i | LAYER1] = buffer
        blockIcons.lengths[i | LAYER1] = 6 * 3
        blockIcons[i | LAYER2] = buffer
        blockIcons.lengths[i | LAYER2] = 6 * 3
        blockIcons[i | LAYER3] = buffer
        blockIcons.lengths[i | LAYER3] = 6 * 3
        blockIcons[i | LAYER4] = buffer
        blockIcons.lengths[i | LAYER4] = 6 * 3
        blockIcons[i | LAYER5] = buffer
        blockIcons.lengths[i | LAYER5] = 6 * 3
        blockIcons[i | LAYER6] = buffer
        blockIcons.lengths[i | LAYER6] = 6 * 3
        blockIcons[i | LAYER7] = buffer
        blockIcons.lengths[i | LAYER7] = 6 * 3
        blockIcons[i | LAYER8] = buffer
        blockIcons.lengths[i | LAYER8] = 6 * 3
      }else if(block.cactus){
        v = cactusIconVerts
        for (let j = 11; j >= 0; j--) {
          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
          data.push(-v[j * 3 + 0] * scale)
          data.push(v[j * 3 + 1] * scale)
          data.push(0.1666666)
          data.push(tex[(j * 2 + 0) % 8])
          data.push(tex[(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6 * 3
        blockIcons[i | CACTUS] = buffer
        blockIcons.lengths[i | CACTUS] = 6 * 3
      }else{
        for (let j = 11; j >= 0; j--) {
          data.push(-hexagonVerts[j * 3 + 0] * scale)
          data.push(hexagonVerts[j * 3 + 1] * scale)
          data.push(0.1666666)
          data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 0) % 8])
          data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6 * 3
      }

			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]

				data.push(-slabIconVerts[j * 3 + 0] * scale)
				data.push(slabIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[floor(j / 4)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | SLAB] = buffer
			blockIcons.lengths[i | SLAB] = 6 * 3

			data = []
			v = stairIconVerts
			for (let j = 23; j >= 0; j--) {
				let num = floor(j / 8)
				let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
				let tx = tex[0]
				let ty = tex[1]
				data.push(-v[j * 5 + 0] * scale)
				data.push(v[j * 5 + 1] * scale)
				data.push(0.1666666)
				data.push(tx + v[j * 5 + 2] / 16)
				data.push(ty + v[j * 5 + 3] / 16)
				data.push(shadows[num])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | STAIR] = buffer
			blockIcons.lengths[i | STAIR] = 6 * 6
      
      data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-fenceIconVerts[j * 3 + 0] * scale)
				data.push(fenceIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | FENCE] = buffer
			blockIcons.lengths[i | FENCE] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-wallPostIconVerts[j * 3 + 0] * scale)
				data.push(wallPostIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALLPOST] = buffer
			blockIcons.lengths[i | WALLPOST] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-wallIconVerts[j * 3 + 0] * scale)
				data.push(wallIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALL] = buffer
			blockIcons.lengths[i | WALL] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-walluIconVerts[j * 3 + 0] * scale)
				data.push(walluIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALLU] = buffer
			blockIcons.lengths[i | WALLU] = 6 * 1
      
      data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-fencqIconVerts[j * 3 + 0] * scale)
				data.push(fencqIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | FENCQ] = buffer
			blockIcons.lengths[i | FENCQ] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-buttonIconVerts[j * 3 + 0] * scale)
				data.push(buttonIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | BUTTON] = buffer
			blockIcons.lengths[i | BUTTON] = 6 * 1
      
      if(block.iconTexture){
        block.textures = prevTexture
      }
		}
	}

	function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getUniformLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		gl.uniformMatrix4fv(vrLocation, transpose, matrix)
	}
	function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getAttribLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		if (vrLocation !== -1) {
			gl.enableVertexAttribArray(vrLocation)
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO)
			gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0)

		}
	}

  //panorama buffer
  let panoramaVertBuffer
  let panoramaTexBuffer
  
	//Generate buffers for every block face and store them
	let sideEdgeBuffers
	let indexBuffer

	function cross(v1, v2, result) {
		let x = v1.x,
			y = v1.y,
			z = v1.z,
			x2 = v2.x,
			y2 = v2.y,
			z2 = v2.z
		result.x = y * z2 - y2 * z
		result.y = z * x2 - z2 * x
		result.z = x * y2 - x2 * y
	}

	let matrix = new Float32Array(16); // A temperary matrix that may store random data.
	let projection = new Float32Array(16)
	let defaultModelView = new Float32Array([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
	class Matrix {
		constructor(arr) {
			this.elements = new Float32Array(arr || 16)
		}
		translate(x, y, z) {
			let a = this.elements
			a[3] += a[0] * x + a[1] * y + a[2] * z
			a[7] += a[4] * x + a[5] * y + a[6] * z
			a[11] += a[8] * x + a[9] * y + a[10] * z
			a[15] += a[12] * x + a[13] * y + a[14] * z
		}
		rotX(angle) {
			let elems = this.elements
			let c = cos(angle)
			let s = sin(angle)
			let t = elems[1]
			elems[1] = t * c + elems[2] * s
			elems[2] = t * -s + elems[2] * c
			t = elems[5]
			elems[5] = t * c + elems[6] * s
			elems[6] = t * -s + elems[6] * c
			t = elems[9]
			elems[9] = t * c + elems[10] * s
			elems[10] = t * -s + elems[10] * c
			t = elems[13]
			elems[13] = t * c + elems[14] * s
			elems[14] = t * -s + elems[14] * c
		}
		rotY(angle) {
			let c = cos(angle)
			let s = sin(angle)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[2] * -s
			elems[2] = t * s + elems[2] * c
			t = elems[4]
			elems[4] = t * c + elems[6] * -s
			elems[6] = t * s + elems[6] * c
			t = elems[8]
			elems[8] = t * c + elems[10] * -s
			elems[10] = t * s + elems[10] * c
			t = elems[12]
			elems[12] = t * c + elems[14] * -s
			elems[14] = t * s + elems[14] * c
		}
    rotZ(angle) {
			let c = cos(angle)
			let s = sin(angle)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[1] * s
			elems[1] = t * -s + elems[1] * c
			t = elems[4]
			elems[4] = t * c + elems[5] * s
			elems[5] = t * -s + elems[5] * c
			t = elems[8]
			elems[8] = t * c + elems[9] * s
			elems[9] = t * -s + elems[9] * c
			t = elems[12]
			elems[12] = t * c + elems[13] * s
			elems[13] = t * -s + elems[13] * c
		}
		scale(x, y, z) {
			let a = this.elements
			a[0] *= x;
			a[1] *= y;
			a[2] *= z;
			a[4] *= x;
			a[5] *= y;
			a[6] *= z;
			a[8] *= x;
			a[9] *= y;
			a[10] *= z;
			a[12] *= x;
			a[13] *= y;
			a[14] *= z;
		}
    unscale(x,y,z){
      let a = this.elements
			a[0] /= x;
			a[1] /= y;
			a[2] /= z;
			a[4] /= x;
			a[5] /= y;
			a[6] /= z;
			a[8] /= x;
			a[9] /= y;
			a[10] /= z;
			a[12] /= x;
			a[13] /= y;
			a[14] /= z;
    }
		identity() {
			let a = this.elements
			a[0] = 1
			a[1] = 0
			a[2] = 0
			a[3] = 0
			a[4] = 0
			a[5] = 1
			a[6] = 0
			a[7] = 0
			a[8] = 0
			a[9] = 0
			a[10] = 1
			a[11] = 0
			a[12] = 0
			a[13] = 0
			a[14] = 0
			a[15] = 1
		}
		// somebody optimize this
		// you just have to expand it
		mult(b) {
			const a = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		// same here
		postMult(a) {
			const b = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		transpose() {
			let matrix = this.elements
			let temp = matrix[4]
			matrix[4] = matrix[1]
			matrix[1] = temp

			temp = matrix[8]
			matrix[8] = matrix[2]
			matrix[2] = temp

			temp = matrix[6]
			matrix[6] = matrix[9]
			matrix[9] = temp

			temp = matrix[3]
			matrix[3] = matrix[12]
			matrix[12] = temp

			temp = matrix[7]
			matrix[7] = matrix[13]
			matrix[13] = temp

			temp = matrix[11]
			matrix[11] = matrix[14]
			matrix[14] = temp
		}
		copyArray(from) {
			let to = this.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}
		copyMatrix(from) {
			let to = this.elements
			from = from.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}
	}

	class Plane {
		constructor(nx, ny, nz) {
			this.set(nx, ny, nz)
		}
		set(nx, ny, nz) {
			// Pre-computed chunk offsets to reduce branching during culling
			this.dx = nx > 0 ? 16 : 0
			this.dy = ny > 0
			this.dz = nz > 0 ? 16 : 0

			// Normal vector for the plane
			this.nx = nx
			this.ny = ny
			this.nz = nz
		}
	}

	let defaultTransformation = new Matrix([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
	class Camera {
		constructor() {
			this.x = 0
			this.y = 0
			this.z = 0
			this.rx = 0; // Pitch
			this.ry = 0; // Yaw
      this.rz = 0
			this.currentFov = 0
			this.defaultFov = settings.fov
			this.targetFov = settings.fov
			this.step = 0
			this.lastStep = 0
			this.projection = new Float32Array(5)
			this.transformation = new Matrix()
			this.direction = { x: 1, y: 0, z: 0 }; // Normalized direction vector
			this.frustum = [] // The 5 planes of the viewing frustum (there's no far plane)
			for (let i = 0; i < 5; i++) {
				this.frustum.push(new Plane(1, 0, 0))
			}
		}
		FOV(fov, time) {
			if (fov === this.currentFov) return

			if (!fov) {
				let now = Date.now()
				fov = this.currentFov + this.step * (now - this.lastStep)
				this.lastStep = now
				if (Math.sign(this.targetFov - this.currentFov) !== Math.sign(this.targetFov - fov)) {
					fov = this.targetFov
				}
			}
			else if (time) {
				this.targetFov = fov
				this.step = (fov - this.currentFov) / time
				this.lastStep = Date.now()
				return
			} else {
				this.targetFov = fov
			}

			const tang = Math.tan(fov * Math.PI / 360)
			const scale = 1 / tang
			const near = 1
			const far = 1000000
			this.currentFov = fov; // Store the state of the projection matrix
			this.nearH = near * tang; // This is needed for frustum culling

			this.projection[0] = scale / width * height
			this.projection[1] = scale
			this.projection[2] = -far / (far - near)
			this.projection[3] = -1
			this.projection[4] = -far * near / (far - near)
		}
		transform() {
			this.transformation.copyMatrix(defaultTransformation)
      this.transformation.rotZ(this.rz)
			this.transformation.rotX(this.rx)
			this.transformation.rotY(this.ry)
			this.transformation.translate(-this.x, -this.y, -this.z)
		}
    resetMatrix() {
      this.transformation.copyMatrix(defaultTransformation)
    }
		getMatrix() {
			let proj = this.projection
			let view = this.transformation.elements
			matrix[0]  = proj[0] * view[0]
			matrix[1]  = proj[1] * view[4]
			matrix[2]  = proj[2] * view[8] + proj[3] * view[12]
			matrix[3]  = proj[4] * view[8]
			matrix[4]  = proj[0] * view[1]
			matrix[5]  = proj[1] * view[5]
			matrix[6]  = proj[2] * view[9] + proj[3] * view[13]
			matrix[7]  = proj[4] * view[9]
			matrix[8]  = proj[0] * view[2]
			matrix[9]  = proj[1] * view[6]
			matrix[10] = proj[2] * view[10] + proj[3] * view[14]
			matrix[11] = proj[4] * view[10]
			matrix[12] = proj[0] * view[3]
			matrix[13] = proj[1] * view[7]
			matrix[14] = proj[2] * view[11] + proj[3] * view[15]
			matrix[15] = proj[4] * view[11]
			return matrix
		}
		setDirection() {
			if (this.targetFov !== this.currentFov) {
				this.FOV()
			}
			this.direction.x = -sin(this.ry) * cos(this.rx)
			this.direction.y = sin(this.rx)
			this.direction.z = cos(this.ry) * cos(this.rx)
			this.computeFrustum()
		}
		computeFrustum() {
			let X = vec1
			let dir = this.direction
			X.x = dir.z
			X.y = 0
			X.z = -dir.x
			X.normalize()

			let Y = vec2
			Y.set(dir)
			Y.mult(-1)
			cross(Y, X, Y)

			//Near plane
			this.frustum[0].set(dir.x, dir.y, dir.z)

			let aux = vec3
			aux.set(Y)
			aux.mult(this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(aux, X, aux)
			this.frustum[1].set(aux.x, aux.y, aux.z)

			aux.set(Y)
			aux.mult(-this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(X, aux, aux)
			this.frustum[2].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(-this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(aux, Y, aux)
			this.frustum[3].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(Y, aux, aux)
			this.frustum[4].set(aux.x, aux.y, aux.z)
		}
		canSee(x, y, z, maxY) {
			x -= 0.5
			y -= 0.5
			z -= 0.5
			maxY += 0.5
			let px = 0, py = 0, pz = 0, plane = null
			let cx = p.x, cy = p.y, cz = p.z
			for (let i = 0; i < 5; i++) {
				plane = this.frustum[i]
				px = x + plane.dx
				py = plane.dy ? maxY : y
				pz = z + plane.dz
				if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
					return false
				}
			}
			return true
		}
	}

	function trans(matrix, x, y, z) {
		let a = matrix
		a[3] += a[0] * x + a[1] * y + a[2] * z
		a[7] += a[4] * x + a[5] * y + a[6] * z
		a[11] += a[8] * x + a[9] * y + a[10] * z
		a[15] += a[12] * x + a[13] * y + a[14] * z
	}
	function rotX(matrix, angle) {
		// This function is basically multiplying 2 4x4 matrices together,
		// but 1 of them has a bunch of 0's and 1's in it,
		// so I removed all terms that multiplied by 0, and just left off the 1's.
		// mat2 = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
		let elems = matrix
		let c = cos(angle)
		let s = sin(angle)
		let t = elems[1]
		elems[1] = t * c + elems[2] * s
		elems[2] = t * -s + elems[2] * c
		t = elems[5]
		elems[5] = t * c + elems[6] * s
		elems[6] = t * -s + elems[6] * c
		t = elems[9]
		elems[9] = t * c + elems[10] * s
		elems[10] = t * -s + elems[10] * c
		t = elems[13]
		elems[13] = t * c + elems[14] * s
		elems[14] = t * -s + elems[14] * c
	}
	function rotY(matrix, angle) {
	//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
		let c = cos(angle)
		let s = sin(angle)
		let elems = matrix
		let t = elems[0]
		elems[0] = t * c + elems[2] * -s
		elems[2] = t * s + elems[2] * c
		t = elems[4]
		elems[4] = t * c + elems[6] * -s
		elems[6] = t * s + elems[6] * c
		t = elems[8]
		elems[8] = t * c + elems[10] * -s
		elems[10] = t * s + elems[10] * c
		t = elems[12]
		elems[12] = t * c + elems[14] * -s
		elems[14] = t * s + elems[14] * c
	}
  function scale(a,x,y,z){
    a[0] *= x;
    a[1] *= y;
    a[2] *= z;
    a[4] *= x;
    a[5] *= y;
    a[6] *= z;
    a[8] *= x;
    a[9] *= y;
    a[10] *= z;
    a[12] *= x;
    a[13] *= y;
    a[14] *= z;
  }
	function transpose(matrix) {
		let temp = matrix[4]
		matrix[4] = matrix[1]
		matrix[1] = temp

		temp = matrix[8]
		matrix[8] = matrix[2]
		matrix[2] = temp

		temp = matrix[6]
		matrix[6] = matrix[9]
		matrix[9] = temp

		temp = matrix[3]
		matrix[3] = matrix[12]
		matrix[12] = temp

		temp = matrix[7]
		matrix[7] = matrix[13]
		matrix[13] = temp

		temp = matrix[11]
		matrix[11] = matrix[14]
		matrix[14] = temp
	}
	function matMult() {
	//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
		let proj = projection
		let view = modelView
		matrix[0] = proj[0] * view[0]
		matrix[1] = proj[0] * view[1]
		matrix[2] = proj[0] * view[2]
		matrix[3] = proj[0] * view[3]
		matrix[4] = proj[5] * view[4]
		matrix[5] = proj[5] * view[5]
		matrix[6] = proj[5] * view[6]
		matrix[7] = proj[5] * view[7]
		matrix[8] = proj[10] * view[8] + proj[11] * view[12]
		matrix[9] = proj[10] * view[9] + proj[11] * view[13]
		matrix[10] = proj[10] * view[10] + proj[11] * view[14]
		matrix[11] = proj[10] * view[11] + proj[11] * view[15]
		matrix[12] = proj[14] * view[8]
		matrix[13] = proj[14] * view[9]
		matrix[14] = proj[14] * view[10]
		matrix[15] = proj[14] * view[11]
	}
	function copyArr(a, b) {
		for (let i = 0; i < a.length; i++) {
			b[i] = a[i]
		}
	}
	function FOV(fov) {
		let tang = Math.tan(fov * 0.5 * Math.PI / 180)
		let scale = 1 / tang
		let near = 1
		let far = 1000000
		currentFov = fov

		projection[0] = scale / width * height
		projection[5] = scale
		projection[10] = -far / (far - near)
		projection[11] = -1
		projection[14] = -far * near / (far - near)
	}
	function initModelView(camera, x, y, z, rx, ry, s) {
		if (camera) {
			camera.transform()
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			copyArr(defaultModelView, modelView)
			rotX(modelView, rx)
			rotY(modelView, ry)
			trans(modelView, -x, -y, -z)
      if(s) scale(modelView,s,s,1)
			matMult()
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
	}
  win.initModelView = initModelView

	function timeString(millis) {
		if (millis > 300000000000 || !millis) {
			return "never"
		}
		const SECOND = 1000
		const MINUTE = SECOND * 60
		const HOUR = MINUTE * 60
		const DAY = HOUR * 24
		const YEAR = DAY * 365

		if (millis < MINUTE) {
			return "just now"
		}

		let years = floor(millis / YEAR)
		millis -= years * YEAR

		let days = floor(millis / DAY)
		millis -= days * DAY

		let hours = floor(millis / HOUR)
		millis -= hours * HOUR

		let minutes = floor(millis / MINUTE)

		if (years) {
			return `${years} year${years > 1 ? "s" : ""} and ${days} day${day !== 1 ? "s" : ""} ago`
		}
		if (days) {
			return `${days} day${days > 1 ? "s" : ""} and ${hours} hour${hours !== 1 ? "s" : ""} ago`
		}
		if (hours) {
			return `${hours} hour${hours > 1 ? "s" : ""} and ${minutes} minute${minutes !== 1 ? "s" : ""} ago`
		}
		return `${minutes} minute${minutes > 1 ? "s" : ""} ago`
	}
	function roundBits(number) {
		return ((number * 1000000 + 0.5) | 0) / 1000000
	}
	function rayTrace(x, y, z, shape) {
		let cf, cd = 1e9; //Closest face and distance
		let m; //Absolute distance to intersection point
		let ix, iy, iz; //Intersection coords
		let minX, minY, minZ, maxX, maxY, maxZ, min, max; //Bounds of face coordinates
		let east = p.direction.x < 0
		let top = p.direction.y < 0
		let north = p.direction.z < 0
		let verts = shape.verts
		let faces = verts[0]

		//Top and bottom faces

		if (top) {
			faces = verts[1]
		}
		if (p.direction.y) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				m = (y + face[1] - p.y) / p.direction.y
				ix = m * p.direction.x + p.x
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iz >= z + minZ && iz <= z + maxZ) {
					cd = m; //Ray crosses bottom face
					cf = top ? "top" : "bottom"
				}
			}
		}

		//West and East faces
		if (east) {
			faces = verts[4]
		} else {
			faces = verts[5]
		}
		if (p.direction.x) {
			for (let face of faces) {
				min = face.min
				minY = min[1]
				minZ = min[2]
				max = face.max
				maxY = max[1]
				maxZ = max[2]
				m = (x + face[0] - p.x) / p.direction.x
				iy = m * p.direction.y + p.y
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && iy >= y + minY && iy <= y + maxY && iz >= z + minZ && iz <= z + maxZ) {
					cd = m
					cf = east ? "east" : "west"
				}
			}
		}

		//South and North faces
		if (north) {
			faces = verts[2]
		} else {
			faces = verts[3]
		}
		if (p.direction.z) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				m = (z + face[2] - p.z) / p.direction.z
				ix = m * p.direction.x + p.x
				iy = m * p.direction.y + p.y
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iy >= y + minY && iy <= y + maxY) {
					cd = m
					cf = north ? "north" : "south"
				}
			}
		}
		return [ cd, cf ]
	}
  function entityRayTrace(x,y,z){
    for(var i=0; i<world.entities.length; i++){
      var ent = world.entities[i]
      var ex = ent.x, ey = ent.y, ez = ent.z
      var w2=ent.width/2, h2=ent.height/2, d2=ent.depth/2
      if(x>ex-w2 && x<ex+w2 && y>ey-h2 && y<ey+h2 && z>ez-d2 && z<ez+d2){
        return entHitbox.ent = ent
      }
    }
    if(multiplayer){
      for(var i in players){
        var ent = players[i]
        var ex = ent.x, ey = ent.y, ez = ent.z
        var w2=ent.width/2, h2=ent.height/2, d2=ent.depth/2
        if(x>ex-w2 && x<ex+w2 && y>ey-h2 && y<ey+h2 && z>ez-d2 && z<ez+d2){
          entHitbox.player = true
          return entHitbox.ent = ent
        }
      }
    }
  }
	function runRayTrace(x, y, z) {
		let block = world.getBlock(x, y, z)
		if (block && !(blockData[block].noHitbox && !(holding && blockData[holding].allHitbox))) {
			let shape = blockData[block].shape
      if(shape.hitbox) shape = shape.hitbox
			let rt = rayTrace(x, y, z, shape)

			if (rt[1] && rt[0] < hitBox.closest) {
				hitBox.closest = rt[0]
				hitBox.face = rt[1]
				hitBox.pos = [ x, y, z ]
				hitBox.shape = shape
        
        crack.pos = [x, y, z]
        crack.shape = shape
			}
		}
	}
	function lookingAt() {
		// Checks blocks in front of the player to see which one they're looking at
		hitBox.pos = null
		hitBox.closest = 1e9
    entHitbox.ent = null
    entHitbox.player = false

		if (p.spectator) {
			return
		}
		let blockState = world.getBlock(p2.x, p2.y, p2.z)
		if (blockState && !(blockData[blockState].noHitbox && !(holding && blockData[holding].allHitbox))) {
			hitBox.pos = [ p2.x, p2.y, p2.z ]
			hitBox.closest = 0
			hitBox.shape = blockData[blockState].shape
      if(hitBox.shape.hitbox) hitBox.shape = hitBox.shape.hitbox
      
      crack.pos = [p2.x, p2.y, p2.z]
      crack.shape = blockData[blockState].shape
			return
		}

		let pd = p.direction

		// Target block
		let tx = round(pd.x * reach + p.x)
		let ty = round(pd.y * reach + p.y)
		let tz = round(pd.z * reach + p.z)

		let minX = p2.x
		let maxX = 0
		let minY = p2.y
		let maxY = 0
		let minZ = p2.z
		let maxZ = 0

		for (let i = 0; i < reach + 1; i++) {
			if (i > reach) {
				i = reach
			}
			maxX = round(p.x + pd.x * i)
			maxY = round(p.y + pd.y * i)
			maxZ = round(p.z + pd.z * i)
			if (maxX === minX && maxY === minY && maxZ === minZ) {
				continue
			}
			if (minX !== maxX) {
				if (minY !== maxY) {
					if (minZ !== maxZ) {
						runRayTrace(maxX, maxY, maxZ)
					}
					runRayTrace(maxX, maxY, minZ)
				}
				if (minZ !== maxZ) {
					runRayTrace(maxX, minY, maxZ)
				}
				runRayTrace(maxX, minY, minZ)
			}
			if (minY !== maxY) {
				if (minZ !== maxZ) {
					runRayTrace(minX, maxY, maxZ)
				}
				runRayTrace(minX, maxY, minZ)
			}
			if (minZ !== maxZ) {
				runRayTrace(minX, minY, maxZ)
			}
			if (hitBox.pos) {
				return; //The ray has collided; it can't possibly find a closer collision now
			}
      var ex=maxX, ey=maxY, ez=maxZ
      for(var e=0; e<1; e+=0.1){
        ex += pd.x*0.1, ey += pd.y*0.1, ez += pd.z*0.1
        entityRayTrace(ex,ey,ez)
        if(entHitbox.ent){
          hitBox.pos = null
          return
        }
      }
			minZ = maxZ
			minY = maxY
			minX = maxX
		}
	}
  function calcThirdPerson(){
    return 4
  }
	let inBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.topH
		let ih = h + p.bottomH + p.topH
		let ix = x - w/2 - p.w
		let iw = w + p.w*2
		let iz = z - d/2 - p.w
		let id = d + p.w*2
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
	}
	let onBox = function(x, y, z, w, h, d) {
		let iy = roundBits(y - h/2 - p.topH)
		let ih = roundBits(h + p.bottomH + p.topH)
		let ix = roundBits(x - w/2 - p.w)
		let iw = roundBits(w + p.w*2)
		let iz = roundBits(z - d/2 - p.w)
		let id = roundBits(d + p.w*2)
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
	}
  let takeDamage
	function collided(x, y, z, vx, vy, vz, block) {
		if(p.spectator) {
			return false
		}
    
    let shape = blockData[block].shape
    if(shape.hitbox) shape = shape.hitbox
		let verts = shape.verts
    let blockObj = blockData[block]
		let px = roundBits(p.x - p.w - x)
		let py = roundBits(p.y - p.bottomH - y)
		let pz = roundBits(p.z - p.w - z)
		let pxx = roundBits(p.x + p.w - x)
		let pyy = roundBits(p.y + p.topH - y)
		let pzz = roundBits(p.z + p.w - z)
		let minX, minY, minZ, maxX, maxY, maxZ, min, max

		//Top and bottom faces
		let faces = verts[0]
		if (vy <= 0) {
			faces = verts[1]
		}
		if (!vx && !vz) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
					if (vy <= 0) {
						p.onGround = true
						p.y = round((face[1] + y + p.bottomH) * 10000) / 10000
						return false
					} else {
            //if(blockObj.damage > takeDamage){
              //takeDamage = blockObj.damage
            //}
						return true
					}
				}
			}
			return false
		}

		//West and East faces
		if (vx < 0) {
			faces = verts[4]
		} else if (vx > 0) {
			faces = verts[5]
		}
		if (vx) {
			let col = false
			for (let face of faces) {
				min = face.min
				minZ = min[2]
				minY = min[1]
				max = face.max
				maxZ = max[2]
				maxY = max[1]
				if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
					if (maxY - py > 0.5) {
						p.canStepX = false
					}
					col = true
          //if(blockObj.damage > takeDamage){
            //takeDamage = blockObj.damage
          //}
				}
			}
			return col
		}

		//South and North faces
		if (vz < 0) {
			faces = verts[2]
		} else if (vz > 0) {
			faces = verts[3]
		}
		if (vz) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
					if (maxY - py > 0.5) {
						p.canStepZ = false
					}
					col = true
          //if(blockObj.damage > takeDamage){
            //takeDamage = blockObj.damage
          //}
				}
			}
			return col
		}
	}
	let contacts = {
		array: [],
		size: 0,
		add: function(x, y, z, block) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
			}
			this.size++
		},
		clear: function() {
			this.size = 0
		},
	}
  let blocks = []
	let resolveContactsAndUpdatePosition = function(now) {
		let pminX = p2.x - 1
		let pmaxX = p2.x + 1
		let pminY = p2.y - 2
		let pmaxY = p2.y + 1
		let pminZ = p2.z - 1
		let pmaxZ = p2.z + 1
		let block = null
		let vel = p.velocity
    let blocksSize = 0
    
		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = world.getBlock(x, y, z)
					if (block && blockData[block].solid && !blockData[block].liquid) {
						contacts.add(x, y, z, block)
					}
          if (block) {
            if(blocks[blocksSize]){
              blocks[blocksSize][0] = x
              blocks[blocksSize][1] = y
              blocks[blocksSize][2] = z
              blocks[blocksSize][3] = block
            }else{
              blocks.push([x,y,z,block])
            }
            blocksSize ++
          }
				}
			}
		}

		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt

		p.previousX = p.x
		p.previousY = p.y
		p.previousZ = p.z

    var ontouch
    var x
    var y
    var z
    var damageBlock
    takeDamage = 0
    liquid = false
    powder = false
    //collisions for ontouch
    for (let i = 0; i < blocksSize; i++) {
			block = blocks[i]
      x = block[0]
      y = block[1]
      z = block[2]
      if(block[0] === p2.x && block[2] === p2.z && blockData[block[3]].ontouch){
        ontouch = blockData[block[3]].ontouch
      }
      if(blockData[block[3]].liquid) {
        liquid = true
      }
      if(!blockData[block[3]].solid && blockData[block[3]].powder){
        powder = true
      }
      let d = blockData[block[3]].damage
      if(d && d>takeDamage/* && collided(x,y,z,0,0,0,block[3])*/) {
        takeDamage = d
        damageBlock = blockData[block[3]]
      }
		}
    
		//Check collisions in the Y direction
		p.onGround = false
		p.canStepX = false
		p.canStepZ = false
		p.y += vel.y * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], 0, vel.y, 0, block[3])) {
				p.y = p.previousY
				vel.y = 0
				break
			}
		}
		if (p.y === p.previousY && !p.flying) {
			p.canStepX = true
			p.canStepZ = true
		}

		var sneakLock = false, sneakSafe = false
		if (p.sneaking) {
			for (let i = 0; i < contacts.size; i++) {
				block = contacts.array[i]
				if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
					sneakLock = true
					break
				}
			}
		}

		//Check collisions in the X direction
		p.x += vel.x * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], vel.x, 0, 0, block[3])) {
				if (p.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				p.x = p.previousX
				vel.x = 0
				break
			}
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true
			}
		}

		if (sneakLock && !sneakSafe) {
			p.x = p.previousX
			vel.x = 0
		}
		sneakSafe = false

		//Check collisions in the Z direction
		p.z += vel.z * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], 0, 0, vel.z, block[3])) {
				if (p.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				p.z = p.previousZ
				vel.z = 0
				break
			}
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true
			}
		}

		if (sneakLock && !sneakSafe) {
			p.z = p.previousZ
			vel.z = 0
		}
    
    //Minimun height: -40
    if(!survival && p.y <= -40){
      p.y = -40
      p.onGround = true
    }

		if (!p.flying) {
      if (liquid){
        //p.jumpSpeed = 0.135;
        p.gravityStength = -0.01;
        if (controlMap.jump.pressed){
          p.velocity.y += 0.025
        }
        if (controlMap.sneak.pressed){
          p.velocity.y -= 0.025
        }
        p.velocity.y *= 0.9
      }else{
        p.gravityStength = -0.032
      }
      if(powder){
        p.velocity.y *= 0.5
        if(controlMap.jump.pressed) p.velocity.y += 0.025
      }
			let drag = liquid ? 0.7 : (p.onGround ? 0.5 : 0.85)
      if(blockData[standingOn].slide) drag = blockData[standingOn].slide
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt
		} else {
			let drag = 0.9
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt
			p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y) * dt
			if (p.onGround && !p.spectator) {
				p.flying = false
			}
		}

		p.lastUpdate = performance.now()
		contacts.clear()
		lookingAt()
    
    if(takeDamage > 0 && now - lastBlockHarm > 500 && survival){
      lastBlockHarm = now
      dieMessage = damageBlock.dieMessage ? damageBlock.dieMessage() : (username+" died because of "+damageBlock.name+". You should avoid it next time.")
      damage(takeDamage, dieMessage)
    }
    
    if(ontouch){
      ontouch(x, y, z)
    }
	}
	let runGravity = function() {
		if (p.flying) {
			return
		}
		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt
		if(p.onGround) {
      let fall = p.lastY - p.y
      p.lastY = p.y
      var block = standingOn
      if(fall > 3 && survival && !liquid) {
        damage(Math.floor(fall-3), username+" fell from a high place. You fell "+Math.round(fall)+" blocks.", true)//Math.floor( (p.velocity.y * p.velocity.y * 8));
        if(fall > 6){
          playSound("damage.bigfall")
        }else playSound("damage.smallfall")
			}
      if(p.velocity.y < -0.1 && block){
        blockParticles(block, p.x,p.y-2,p.z,10)
        blockSound(block, "step")
      }
      if(blockData[block].bounciness && p.velocity.y < -0.2){
        p.velocity.y *= -blockData[block].bounciness
      }else{
        if(controlMap.jump.pressed) {
          p.velocity.y = p.jumpSpeed
          p.onGround = false
          if(survival){
            p.foodExhaustion += p.sprinting ? 0.2 : 0.05
          }
        } else {
          p.velocity.y = 0
        }
      }
		} else {
			p.velocity.y += p.gravityStength * dt
			if(p.velocity.y < -p.maxYVelocity) {
				p.velocity.y = -p.maxYVelocity
			}
		}
    if(liquid !== lastLiquid){
      lastLiquid = liquid
      if(liquid){
        playSound("liquid.splash")
      }else{
        //playSound("liquid.exit")
      }
    }
	}
  
  let defineWorld = function() {
		let tickStart = performance.now()
		world.tick()
		analytics.totalTickTime += performance.now() - tickStart
		let renderStart = performance.now()
    p2.x = round(p.x)
	  p2.y = round(p.y)
		p2.z = round(p.z)
    p3.x = p.x
    p3.y = p.y
    p3.z = p.z
    p3.ry = p.ry
    p3.survival = survival
    p3.username = username || ""
    p3.time = worldTime
    p3.harmEffect = harmEffect
    p3.crackPos = crack.pos
    p3.crack = crack.idx
    let prevX
    let prevY
    let prevZ
    let prevRotX
    let prevRotY
    if(p.thirdPerson){
      prevX = p.x
      prevY = p.y
      prevZ = p.z
      prevRotX = p.rx
      prevRotY = p.ry
      /*p.rx += Math.PI
      p.ry += Math.PI*/ //third person back, not front
      var d = calcThirdPerson()
      p.x -= p.direction.x*d
      p.y -= p.direction.y*d
      p.z -= p.direction.z*d
    }
		world.render()
    if(p.thirdPerson){
      p.x = prevX
      p.y = prevY
      p.z = prevZ
      p.rx = prevRotX
      p.ry = prevRotY
    }
		analytics.totalRenderTime += performance.now() - renderStart
	}
  
  let renderPlayer = function(){
    if(p.thirdPerson){
      p.character.render()
    }else{
      //p.hand.render()
    }
  }
  let updtPlayer = function(){
    p.character.x = p.x
    p.character.y = p.y-1
    p.character.z = p.z
    p.character.yaw = -p.ry
    
    p.character.update()
    
    //p.hand.update()
  }

	let controls = function() {
		move.x = 0
		move.z = 0
		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt

		if(controlMap.forward.pressed) move.z += p.speed
		if(controlMap.backward.pressed) move.z -= p.speed
		if(controlMap.left.pressed) move.x += p.speed
		if(controlMap.right.pressed) move.x -= p.speed
		if (p.flying) {
			if(controlMap.jump.pressed) p.velocity.y += 0.06 * dt
			if(controlMap.sneak.pressed) p.velocity.y -= 0.06 * dt
		}
		if(Key.arrowleft) p.ry -= 0.1 * dt
		if(Key.arrowright) p.ry += 0.1 * dt
		if(Key.arrowup) p.rx += 0.1 * dt
		if(Key.arrowdown) p.rx -= 0.1 * dt

		if (!p.sprinting && controlMap.sprint.pressed && !p.sneaking && controlMap.forward.pressed) {
			p.FOV(settings.fov + 10, 250)
			p.sprinting = true
		}

		if(p.sprinting && p.food > 6) {
			move.x *= p.sprintSpeed
			move.z *= p.sprintSpeed
      if(survival)p.foodExhaustion += (p.speed * p.sprintSpeed)*0.1
		}
		if(p.flying) {
			move.x *= p.flySpeed
			move.z *= p.flySpeed
		}
		if (!move.x && !move.z) {
			if (p.sprinting) {
				p.FOV(settings.fov, 100)
			}
			p.sprinting = false
		} else if(abs(move.x) > 0 && abs(move.z) > 0) {
			move.x *= move.ang
			move.z *= move.ang
		}

		//Update the velocity, rather than the position.
		let co = cos(p.ry)
		let si = sin(p.ry)
    let speedFactor = blockData[standingOn].speedFactor
		let friction = liquid ? 0.4 : (p.onGround ? 1 : 0.3)
    if(speedFactor){
      friction *= speedFactor
    }
		p.velocity.x += (co * move.x - si * move.z) * friction * dt
		p.velocity.z += (si * move.x + co * move.z) * friction * dt

		const TAU = Math.PI * 2
		const PI1_2 = Math.PI / 2
		while(p.ry > TAU) p.ry -= TAU
		while(p.ry < 0)   p.ry += TAU
		if(p.rx > PI1_2)  p.rx = PI1_2
		if(p.rx < -PI1_2) p.rx = -PI1_2

		p.setDirection()
	}

	function box2(sides, tex, shape) {
		if (blockFill && !shape) {
			let i = 0
			for (let side in Block) {
				if (sides & Block[side]) {
					vertexAttribPointer("aVertex", program3D, "aVertex", 3, sideEdgeBuffers[Sides[side]])
					vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0)
				}
				i++
			}
		}else if(shape){
			for (let i = 0; i < shape.size; i++) {
        vertexAttribPointer("aVertex", program3D, "aVertex", 3, shape.buffer)
	 		  vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
				gl.drawArrays(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0) //doesn't work
			}
    }
		if (blockOutlines) {
			vertexAttribPointer("aVertex", program3D, "aVertex", 3, hitBox.shape.buffer)
			vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox])
			for (let i = 0; i < hitBox.shape.size; i++) {
				gl.drawArrays(gl.LINE_LOOP, i * 4, 4)
			}
    }
	}
	function block2(x, y, z, t, camera) {
		if (camera) {
			camera.transformation.translate(x, y, z)
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			//copyArr(modelView, matrix)
			trans(modelView, x, y, z)
			matMult()
			trans(modelView, -x, -y, -z)
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
    box2(0xff, blockData[t].textures)
	}

	function changeWorldBlock(t, drop) {
		let pos = hitBox.pos
		if(pos && pos[1] >= 0 && pos[1] < maxHeight) {
			let shape = t && blockData[t].shape
			if (t && shape.rotate) {
				let pi = Math.PI / 4
				if (p.ry <= pi) {} // North; default
				else if (p.ry < 3 * pi) {
					t |= WEST
				} else if (p.ry < 5 * pi) {
					t |= SOUTH
				} else if (p.ry < 7 * pi) {
					t |= EAST
				}
			}

			if (t && shape.flip && hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y) % 1 < 0.5)) {
				t |= FLIP
			}

      var prevBlock = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
			world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t)
      if(drop){
        let block = prevBlock
        let theDrop = blockData[prevBlock].drop
        let amount = blockData[prevBlock].dropAmount
        var canDrop = handBreakable.includes(blockData[prevBlock].type)
        if(holding && breakTypes[blockData[prevBlock].type] && breakTypes[blockData[prevBlock].type].includes(blockData[holding].name)) canDrop = true
        if(!blockData[prevBlock].type) canDrop = true
        if(canDrop){
          if(amount.length === 2){
            amount = round(rand(amount[0], amount[1]))
          }
          if(holding && blockData[holding].shears && blockData[prevBlock].dropSelfWhenSheared){
            if(blockData[prevBlock].shearDropAmount){
              amount = blockData[prevBlock].shearDropAmount
            }
          }else{
            if(typeof theDrop === "function"){
              block = blockIds[theDrop()]
            }else if(Array.isArray(theDrop)){
              block = theDrop
            }else if(theDrop) block = blockIds[theDrop]
            else if(blockData[prevBlock].noDrop) block = 0
          }
          if(block && pos){
            if(Array.isArray(block)){//drop multiple items
              for(var b=0; b<block.length; b++){
                var bId = blockIds[block[b]]
                for(var i=0; i<amount; i++){
                  world.addEntity(new Item(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, 0, 0, bId, true))
                }
              }
            }else{
              for(var i=0; i<amount; i++){
                world.addEntity(new Item(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, 0, 0, block, true))
              }
            }
          }
        }
      }
			if (t) {
				p.lastPlace = Date.now()
			} else {
				p.lastBreak = Date.now()
        if(!prevBlock) return
        blockParticles(prevBlock,hitBox.pos[0],hitBox.pos[1],hitBox.pos[2],30)
        blockSound(prevBlock, "dig", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
        var breakType = blockData[prevBlock].type
        if(survival && holding && blockData[holding].pickaxe) {
          inventory.hotbar[inventory.hotbarSlot].durability --
          updateHUD = true
        }
        if(survival && holding && blockData[holding].sword) {
          inventory.hotbar[inventory.hotbarSlot].durability -= 2
          updateHUD = true
        }
        if(survival && holding && blockData[holding].shovel) {
          inventory.hotbar[inventory.hotbarSlot].durability -= 1
          updateHUD = true
        }
        if(survival && holding && blockData[holding].axe) {
          inventory.hotbar[inventory.hotbarSlot].durability -= 1
          updateHUD = true
        }
        if(survival && holding && blockData[holding].hoe && breakType !== "plant2") {
          inventory.hotbar[inventory.hotbarSlot].durability -= 1
          updateHUD = true
        }
			}
		}
	}
  function replaceItem(id){
    inventory.hotbar[inventory.hotbarSlot] && (inventory.hotbar[inventory.hotbarSlot].id = id)
    holding = inventory.hotbar[inventory.hotbarSlot].id
    updateHUD = true
  }
  function getPosition(){
    let pos = hitBox.pos, x = pos[0], y = pos[1], z = pos[2]
    let side = false
		switch(hitBox.face) {
			case "top":
				y += 1
				break
			case "bottom":
				y -= 1
				break
			case "south":
				z -= 1
        side = true
				break
			case "north":
				z += 1
        side = true
				break
			case "west":
				x -= 1
        side = true
				break
			case "east":
				x += 1
        side = true
				break
		}
    pos[0] = x
    pos[1] = y
    pos[2] = z
    return pos
  }
	function newWorldBlock() {
    let pos = hitBox.pos,x,y,z, face = hitBox.face
    if(pos) x = pos[0], y = pos[1], z = pos[2]
    let cblock = pos ? world.getBlock(x, y, z) : 0
    
    var pholding = holding
    if(holding && blockData[holding].useAs){
      var useAs = blockData[holding].useAs
      if(typeof useAs === "function"){
        useAs = useAs(x,y,z,cblock,face)
        if(blockIds[useAs]){
          holding = blockIds[useAs]
        }
      }else{
        holding = blockIds[useAs]
      }
    }
    
    if(cblock){
      if(hitBox.pos){
        let onclick = blockData[cblock].onclick
        if(onclick && !Key.shift){
          if(!onclick(x, y, z)){p.lastPlace = Date.now(); return} //if it doesn't return true
        }
      }
      
      if(holding && blockData[holding].shovel){
        if(cblock === blockIds.grass || cblock === blockIds.dirt || cblock === blockIds.rootedDirt || cblock === blockIds.mycelium || cblock === blockIds.podzol){
          world.setBlock(x,y,z,blockIds.grass | TALLCROSS)
          var h = inventory.hotbar[inventory.hotbarSlot]
          h.durability --
          return p.lastPlace = Date.now()
        }
      }
      if(holding && cblock && blockData[holding].axe){
        var name = blockData[cblock].name
        name = name[0].toUpperCase() + name.substring(1)
        name = "stripped"+name
        if(blockIds[name]){
          world.setBlock(x,y,z,blockIds[name])
          var h = inventory.hotbar[inventory.hotbarSlot]
          h.durability --
          return p.lastPlace = Date.now()
        }
      }
      if(holding && cblock && blockData[holding].hoe){
        if((blockData[cblock].name === "grass" || cblock === blockIds.dirt) && !world.getBlock(x,y+1,z)){
          world.setBlock(x,y,z,blockIds.farmland)
          var h = inventory.hotbar[inventory.hotbarSlot]
          h.durability --
          return p.lastPlace = Date.now()
        }
        if(cblock === blockIds.rootedDirt){
          world.setBlock(x,y,z,blockIds.dirt)
          var h = inventory.hotbar[inventory.hotbarSlot]
          h.durability --
          world.addEntity(new Item(x, y+0.5, z, 0, 0, 0, blockIds.hangingRoots, true))
          return p.lastPlace = Date.now()
        }
      }
      if(holding && cblock && blockData[holding].shears){
        if(cblock === blockIds.pumpkin){
          world.setBlock(x,y,z,blockIds.carvedPumpkin)
          var h = inventory.hotbar[inventory.hotbarSlot]
          h.durability --
          for(var n=0; n<4; n++)world.addEntity(new Item(x, y+0.5, z, 0, 0, 0, blockIds.pumpkinSeeds, true))
          return p.lastPlace = Date.now()
        }
      }
    }
    if(blockData[holding]){
      if(blockData[holding].useAnywhere ? true : hitBox.pos){
        let onuse = blockData[holding].onuse
        if(onuse){ //items like flint and steel can't be placed but lights stuff
          if(blockData[holding].minusOnUse){inventory.hotbar[inventory.hotbarSlot].amount --; updateHUD = true}
          if(!onuse(x,y,z, cblock, replaceItem)){p.lastPlace = Date.now(); return}
        }
      }
    }
		if(!hitBox.pos || !holding || blockData[holding].item || blockData[holding].edible) {
			return
		}
    let side = false
		switch(hitBox.face) {
			case "top":
				y += 1
				break
			case "bottom":
				y -= 1
				break
			case "south":
				z -= 1
        side = true
				break
			case "north":
				z += 1
        side = true
				break
			case "west":
				x -= 1
        side = true
				break
			case "east":
				x += 1
        side = true
				break
		}
    
    var hitboxBlock = world.getBlock(x, y, z)
    var blocking = blockData[holding].solid && inBox(x, y, z, 1, 1, 1)
    var canPlace = (!hitboxBlock) || (blockData[hitboxBlock].liquid)
		if (!blocking && canPlace) {
      var block = holding
      
			var prevBlockMode = blockMode;
      var under = world.getBlock(x,y-1,z)
      var onPot = !side && blockData[under] && blockData[under].pot
      if(blockData[holding].potCross && onPot){
        blockMode = POTCROSS
      }else if(blockData[holding].crossShape){
        if(onPot && blockIds[blockData[holding].name+"Pot"]){
          block = blockIds[blockData[holding].name+"Pot"]
          blockMode = POTCROSS
        }else{
          blockMode = CROSS
        }
      }
      if(blockData[holding].sideCross){
        if(side){
          blockMode = CUBE
        }else if(hitBox.face === "bottom"){
          blockMode = SLAB
        }else blockMode = CROSS
      }
      if(blockData[holding].tallcrossShape){
        blockMode = TALLCROSS
      }
      if(blockData[holding].door){
        blockMode = DOOR
      }
      if(blockData[holding].torch){
        blockMode = TORCH
        if(side) blockMode = SLAB
      }
      if(blockData[holding].lantern){
        if(world.getBlock(x,y+1,z)){
          blockMode = LANTERNHANG
        }else{
          blockMode = LANTERN
        }
      }
      if(blockData[holding].beacon){
        blockMode = BEACON
      }
      if(blockData[holding].cactus && blockMode !== POTCROSS){
        blockMode = CACTUS
      }
      if(blockData[holding].pane){
        blockMode = PANE
      }
      if(blockData[holding].portal){
        blockMode = PORTAL
      }
      if(blockData[holding].wallFlat){
        blockMode = WALLFLAT
      }
      if(blockData[holding].trapdoor){
        if(side){
          blockMode = TRAPDOOROPEN
        }else{
          blockMode = TRAPDOOR
        }
      }
      if(blockData[holding].chain){
        blockMode = CHAIN
      }
      if(blockData[holding].button){
        blockMode = BUTTON
      }
      if(blockData[holding].pot){
        blockMode = POT
      }
      if(blockData[holding].carpet){
        blockMode = CARPET
      }
      
      if(side && blockIds[blockData[block].name+"SW"]){
        block = blockIds[blockData[block].name+"SW"]
      }
      if(blockData[holding].layers){
        var b = world.getBlock(pos[0],pos[1],pos[2])
        let layer = 0
        if((b & LAYER1) === LAYER1) layer = 1
        if((b & LAYER2) === LAYER2) layer = 2
        if((b & LAYER3) === LAYER3) layer = 3
        if((b & LAYER4) === LAYER4) layer = 4
        if((b & LAYER5) === LAYER5) layer = 5
        if((b & LAYER6) === LAYER6) layer = 6
        if((b & LAYER7) === LAYER7) layer = 7
        if((b & LAYER8) === LAYER8) layer = 8
        if(((b & blockIds.snow) === blockIds.snow) && layer > 0 && layer < 8){
          x = pos[0], y = pos[1], z = pos[2]
          layer ++
          switch(layer){
            case 2:
              blockMode = LAYER2
              break
            case 3:
              blockMode = LAYER3
              break
            case 4:
              blockMode = LAYER4
              break
            case 5:
              blockMode = LAYER5
              break
            case 6:
              blockMode = LAYER6
              break
            case 7:
              blockMode = LAYER7
              break
            case 8:
              blockMode = LAYER8
              break
          }
        }else{
          blockMode = LAYER1
        }
      }
      
			pos[0] = x
			pos[1] = y
			pos[2] = z
      
			changeWorldBlock(block < isCube ? (block | blockMode) : block)
      blockMode = prevBlockMode;
      
      if(survival && inventory.hotbar[inventory.hotbarSlot]){
        inventory.hotbar[inventory.hotbarSlot].amount --;
        updateHUD = true
      }
      
      //play sound
      blockSound(block, "place", x,y,z)
		}
    holding = pholding
	}
    
  function entClick(){
    let ent = entHitbox.ent
    if(!ent) return
    var block = blockData[holding || 0]
    var holdObj = inventory.hotbar[inventory.hotbarSlot]
    var atime = block.attackTime
    var time = (Date.now() - p.lastBreak) / 1000 * 20
    var attackDamage = (block && block.attackDamage) || 0
    var damage, critical
    if(attackDamage){
      damage = atime ? (0.2 + ((time + 0.5) / atime) ** 2 * 0.8) : 1
      if(p.velocity.y < 0 && !p.onGround && !liquid && !p.flying && !p.sprinting && damage > 0.848) critical = true
      damage = max(min(damage, 1), 0.2) * attackDamage
      if(critical) damage *= 1.5
    }else damage = 1
    if(entHitbox.player){
      var pd = p.direction
      send({type:"hit", username:username, damage:damage, velx:pd.x/2, velz:pd.z/2}, ent.id)
    }else{
      if(ent.onhit){
        ent.onhit(damage)
        var pd = p.direction
        ent.velx += pd.x / 2
        ent.velz += pd.z / 2
      }
    }
    if(block.pickaxe){
      holdObj.durability -= 2
    }
    if(block.sword){
      holdObj.durability --
    }
    if(block.shovel){
      holdObj.durability -= 2
    }
    if(block.axe){
      holdObj.durability -= 2
    }
    if(block.pickaxe || block.sword || block.shovel || block.axe){
      attackCooldownStart = Date.now()
      attackCooldownTime = atime
    }
    console.log(damage)
    p.foodExhaustion += 0.1
    p.lastBreak = Date.now()
  }

  function cracks(){
    var now = Date.now()
    var block = hitBox.pos ? world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) : 0
    var touchBreak = pTouch.touching && pTouch.canDig && Date.now() - pTouch.touchStart > touchMoveLimit
    var breaking = ((controlMap.break.pressed && !Key.control) || touchBreak) && block && (crack.delayDone >= crack.delayBetween)
    if(!arrayValues(crack.prevPos, crack.pos)){
      crack.prevPos = crack.pos
      crack.soundTimer = 0
      crack.delayDone = 0
      crack.breakStart = now
    }
    if(breaking){
      var breakTime = blockData[block].breakTime
      var breakType = blockData[block].type
      if(holding && blockData[holding].shears && blockData[block].shearBreakTime){
        breakTime = blockData[block].shearBreakTime
      }
      if(holding && (blockData[holding].pickaxe || (blockData[holding].shovel && breakType === "ground") || (blockData[holding].axe && breakType === "wood") || (blockData[holding].hoe && breakType === "plant2"))){
        breakTime /= blockData[holding].mineSpeed
      }
      let prog = map(now, crack.breakStart,crack.breakStart+breakTime, 0,1)
      crack.idx = floor(prog * crack.length)
      crack.tex = crack[crack.idx]
      pTouch.digProg = prog
      crack.soundTimer ++
      if(crack.soundTimer > 15){
        crack.soundTimer -= 15
        blockSound(block, "breaking", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
      }
      if(crack.idx >= crack.length){
        changeWorldBlock(0, true)
        p.foodExhaustion += 0.005
      }
    }else{
      crack.idx = -1
      crack.delayDone ++
      crack.breakStart = now
      pTouch.digProg = 0
    }
    if(!controlMap.break.pressed){
      crack.delayDone = 0
    }
  }

	// Save the coords for a small sphere used to carve out caves
	let sphere;
	{
		let blocks = []
		let radius = 3.5
		let radsq = radius * radius
		for (let i = -radius; i <= radius; i++) {
			for (let j = -radius; j <= radius; j++) {
				for (let k = -radius; k <= radius; k++) {
					if (i*i + j*j + k*k < radsq) {
						blocks.push(i|0, j|0, k|0)
					}
				}
			}
		}
		sphere = new Int8Array(blocks)
	}

	function isCave(x, y, z) {
		// Generate a 3D rigid multifractal noise shell.
		// Then generate another one with different coordinates.
		// Overlay them on top of each other, and the overlapping parts should form a cave-like structure.
		// This is extremely slow, and requires generating 2 noise values for every single block in the world.
		// TODO: replace with a crawler system of some sort, that will never rely on a head position in un-generated chunks.
		let smooth = 0.02
		let caveSize = 0.0055
		let cave1 = abs(0.5 - caveNoise(x * smooth, y * smooth, z * smooth)) < caveSize
		let cave2 = abs(0.5 - caveNoise(y * smooth, z * smooth, x * smooth)) < caveSize
		return (cave1 && cave2)
	}
	function carveSphere(x, y, z) {
		if (y > 3) {
			for (let i = 0; i < sphere.length; i += 3) {
				world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true)
			}
		}
	}

	let renderedChunks = 0
	function getBlock(x, y, z, blocks) {
		return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)]
	}
	/**
	 * Returns a 1 if the face is exposed and should be drawn, or a 0 if the face is hidden
	 * 
	 * @param {number} x - The X coordinate of the block that may be covering a face
	 * @param {number} y - The Y coordinate of the block that may be covering a face
	 * @param {number} z - The Z coordinate of the block that may be covering a face
	 * @param {Collection} blocks - Some collection of blocks that can return the block at (x, y, z)
	 * @param {number} type - The blockstate of the block that's being considered for face culling
	 * @param {function} func - The function that can be called to return a block from the blocks collection
	*/
	function hideFace(x, y, z, blocks, type, func, sourceDir, dir, section) {
		let block = func.call(world, x, y, z, blocks)
		if (!block) {
			return 1
		}

		let data = blockData[block]
		let sourceData = blockData[type]

		let sourceRange = 3
		let hiderRange = 3
		if (func !== getBlock || screen === "loading") {
			// getBlock is only used during the optimize phase of worldGen
			sourceRange = sourceData.shape.cull[sourceDir]
			hiderRange = data.shape.cull[dir]
		}

		if ((sourceRange & hiderRange) !== sourceRange || sourceRange === 0 || block !== type && data.transparent || data.transparent && data.shadow) {
			return 1
		}
		return 0
	}
	let getShadows = {
		shade: [ 1, 0.85, 0.7, 0.6, 0.3 ],
		ret: [],
		blocks: [],
		top: function(x, y, z, block) { // Actually the bottom... How did these get flipped?
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x, y-1, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x, y-1, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y-1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y-1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y-1, z+1, block)].shadow

			ret[0] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.75
			ret[1] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.75
			ret[2] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.75
			ret[3] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.75
			return ret
		},
		bottom: function(x, y, z, block) { // Actually the top
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x, y+1, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y+1, z, block)].shadow
			blocks[4] = blockData[getBlock(x, y+1, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
			ret[2] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
			return ret
		},
		north: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[1] = blockData[getBlock(x, y-1, z+1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y, z+1, block)].shadow
			blocks[4] = blockData[getBlock(x, y, z+1, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y, z+1, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
			ret[1] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
			ret[2] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
			ret[3] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
			return ret
		},
		south: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x, y-1, z-1, block)].shadow
			blocks[4] = blockData[getBlock(x, y, z-1, block)].shadow
			blocks[5] = blockData[getBlock(x, y+1, z-1, block)].shadow
			blocks[6] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[7] = blockData[getBlock(x+1, y, z-1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z-1, block)].shadow

			ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
			return ret
		},
		east: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x+1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x+1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x+1, y, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x+1, y, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8
			return ret
		},
		west: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x-1, y, z, block)].shadow
			blocks[5] = blockData[getBlock(x-1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x-1, y, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x-1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8
			ret[3] = this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8
			return ret
		},
	}
	
	function average(l, a, b, c, d) {
		a = l[a]
		b = l[b]
		c = l[c]
		d = l[d]
		let count = 1
		let zero = 0
		let total = a
		if (b && abs(a-b) <= 2) {
			total += b
			count++
		} else zero++
		if (c && abs(a-c) <= 2) {
			total += c
			count++
		} else zero++
		if (d && abs(a-d) <= 2) {
			total += d
			count++
		} else zero++

		let mx = max(a, b, c, d)
		if (mx > 2) {
			return total / (count * 15)
		}
		if (mx > 1) {
			return zero ? total / (count * 15 + 15) : total / (count * 15)
		}
		return (total) / 60
	}
	let getLight = {
		blocks: [],
		top: function(x, y, z, block, ret, blockLight = 0, bright) { // Actually the bottom... How did these get flipped?
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

      if(bright){
        ret[0] = ret[1] = ret[2] = ret[3] = 1
      }else{
        ret[0] = average(blocks, 4, 0, 1, 3)
        ret[1] = average(blocks, 4, 1, 2, 5)
        ret[2] = average(blocks, 4, 5, 7, 8)
        ret[3] = average(blocks, 4, 3, 6, 7)
      }
			// debugger
			return ret
		},
		bottom: function(x, y, z, block, ret, blockLight = 0) { // Actually the top
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

      ret[0] = average(blocks, 4, 3, 6, 7)
      ret[1] = average(blocks, 4, 5, 7, 8)
      ret[2] = average(blocks, 4, 1, 2, 5)
      ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		north: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 3, 6, 7)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 1, 2, 5)
			return ret
		},
		south: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		east: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x+1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		west: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x-1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 1, 2, 5)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 3, 6, 7)
			return ret
		},
	}

	/*
	function interpolateShadows(shadows, x, y) {
		let sx = (shadows[1] - shadows[0]) * x + shadows[0]
		let sx2 = (shadows[3] - shadows[2]) * x + shadows[2]
		return (sx2 - sx) * y + sx
	}
	*/
  
class Generator {
    constructor() {
        this.seedSet = false;
        this.seed = 0;
        this.size = 600;
        this.diagonalNeighbors = true; //true if the corners are also adjacent
        
        this.grid = [];
        this.vertex = [];
        this.river = [];
        this.precip = [];
        this.biome = [];
        this.biomeBlend = [];
        
        this.highestPoint = [0,0];
        
        this.updates = [];
        this.stage = 0;
        this.changes = 0;
        this.rivers = 0;
        this.h = 0;
        this.X = 0;
    }
    GetVertex(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 0;}
        return this.vertex[x+y*this.size];
    }
    GetHeight(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 5;}
        return Math.round(
        (this.GetVertex(Math.floor(x), Math.floor(y))+
        this.GetVertex(Math.floor(x+0.5), Math.floor(y))+
        this.GetVertex(Math.floor(x), Math.floor(y+0.5))+
        this.GetVertex(Math.floor(x+0.5), Math.floor(y+0.5)))*0.5+5);
    };
    GetWater(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        if (this.GetBiome(x,y) === -15099421 || this.GetBiome(x,y) === -16479791) {return 1}
        return Math.sqrt(this.river[x+y*this.size]);
    }
    GetWaterDepth(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        var w = 0;
        for (let x2 = 0; x2 < 1; x2+=0.5) {
            for (let y2 = 0; y2 < 1; y2+=0.5) {
                w += this.GetWater(Math.floor(x+x2),Math.floor(y+y2));
            }
        }
        w = w/4.0;
        if (w > 0.25) {
            return 1;
        }   else {
            return 0;
        }
    }
    GetBiome(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return -16479791;}
        return this.biome[x+y*this.size];
    }
    GetBiomeType(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        return this.GetBiome(Math.floor(x),Math.floor(y));
    }
    GetNeighbors(x, y) {
        var n = [];
        if (x > 0) {
            n.push({x:x-1, y:y});
            if (this.diagonalNeighbors) {
            if (y > 0) {
                n.push({x:x-1, y:y-1});
            }
            if (y < this.size-1) {
                n.push({x:x-1, y:y+1});
            }}
        }
        if (x < this.size-1) {
            n.push({x:x+1, y:y});
            if (this.diagonalNeighbors) {
            if (y > 0) {
                n.push({x:x+1, y:y-1});
            }
            if (y < this.size-1) {
                n.push({x:x+1, y:y+1});
            }
            }
        }
        if (y > 0) {
            n.push({x:x, y:y-1});
        }
        if (y < this.size-1) {
            n.push({x:x, y:y+1});
        }
        return n;
    }
    GetDown(x, y) {
        var n = this.GetNeighbors(x, y);
        var l = this.size;
        var ld = [];
        for (var i in n) {
            if (this.vertex[n[i].x + n[i].y*this.size] <= l) {
                if (this.vertex[n[i].x + n[i].y*this.size] === l) {
                    ld.push(n[i]);
                }
                l = this.vertex[n[i].x + n[i].y*this.size];
                ld = [n[i]];
            }
        }
        if (l <= this.vertex[x + y*this.size]) {
            return ld[Math.floor(random(ld.length))];
        }
        return undefined;
    }
    SetSeed(seed) {
        this.seed = seed;
        this.seedSet = true;
        randomSeed(hash(seed, 2123155232) * 210000000)
    }
    Generate(start) {
        var end = start+16;
        var nS = 0.021;
        function sq(n) {return n*n}
        function color(r, g, b, a) {
            a = (a === undefined ? 255 : a);
            g = (g === undefined ? r : g);
            b = (b === undefined ? g : b);
            if (a > 127) {a = -256+a;}
            return b+g*256+r*65536+a*16777216;
        }
        if (this.stage === 0) { //landmass
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.grid[x +y*this.size] = 0;
                    this.vertex[x + y*this.size] = -1;
                    this.precip[x + y*this.size] = -1;
                    this.river[x + y*this.size] = 0;
                    var d = this.size/2-Math.sqrt(sq(x-this.size/2)+sq(y-this.size/2));
                    var islandMask = Math.sqrt(sq(this.size/2)-sq(d-this.size/2))*2/this.size;
                    var v = noise(x*nS, y*nS, this.seed);
                    if (v*islandMask > 0.3) {
                        this.grid[x+y*this.size] = 1;
                    }
                }
                this.X++;
            }
            if (this.X === this.size) {
                this.updates.push({type:"ocean", x:0, y:0});
            }
        }   else if (this.stage === 1) {    //Oceans
            while (this.updates.length > 0 && win.performance.now() < end) {
                var u = this.updates.shift();
                if (this.grid[u.x+u.y*this.size] === 0) {
                    this.grid[u.x+u.y*this.size] = 2;
                    var n = this.GetNeighbors(u.x, u.y);
                    for (var i = 0; i < n.length; i++) {
                        if (this.grid[n[i].x+n[i].y*this.size] === 0) {
                            this.updates.push({type:"ocean",x:n[i].x,y:n[i].y});
                        }
                    }
                }
            }
            if (this.updates.length === 0) {
                this.X = this.size;
            }
        }   else if (this.stage === 2) {    //altitude
            if (this.h === -1) {this.h = 0;}
            var doingLake = false;
            var I = 0;
            while (win.performance.now() < end && this.updates.length > 0 && I < this.updates.length) {
                if (this.updates[I].type === "lake") {
                    var u = this.updates.splice(I, 1)[0];
                    if (this.grid[u.x + u.y*this.size] === 0 && this.vertex[u.x+u.y*this.size] === -1) {
                        this.vertex[u.x + u.y*this.size] = u.a;
                        var n = this.GetNeighbors(u.x, u.y);
                        for (var i in n) {
                            if (this.grid[n[i].x+n[i].y*this.size] === 0 && this.vertex[n[i].x + n[i].y*this.size] === -1) {
                                this.updates.push({type:"lake",x:n[i].x,y:n[i].y,a:u.a});
                            }
                        }
                    }
                    I--;
                }
                I++;
            }
            while (this.X < this.size && win.performance.now() < end && !doingLake) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.vertex[x+y*this.size] === -1) {
                        if (this.grid[x+y*this.size] === 2) {
                            this.vertex[x+y*this.size] = this.h;
                            this.changes++;
                        }   else if (this.h > 0) {
                            var n = this.GetNeighbors(x, y);
                            var l = this.size;
                            var ld;
                            for (var i in n) {
                                var v = this.vertex[n[i].x + n[i].y*this.size];
                                if (v < l && v !== -1) {
                                    l = v;
                                    ld = n[i];
                                }
                            }
                            if (l !== this.size && l <= this.h) {
                                if (this.grid[x+y*this.size] === 0) {
                                    this.updates.push({type:"river",x:ld.x,y:ld.y});
                                    this.updates.push({type:"lake",x:x,y:y,a:l});
                                }   else {
                                    this.vertex[x+y*this.size] = l+1+(random() > 0.5 ? 1 : 0);
                                }
                                this.changes++;
                            }
                        }
                    }
                }
                this.X++;
            }
            if (this.X === this.size && this.h < this.size/3) {
                if (this.changes === 0) {
                    this.h++;
                }
                this.X = 0;
                this.changes = 0;
            }
        }   else if (this.stage === 3) {    //altitude readjustment
            
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.vertex[x+y*this.size] = (Math.pow(20, this.vertex[x+y*this.size]/this.size*3)-1)/(20-1)*this.size/3;
                    if (this.vertex[x+y*this.size] > this.vertex[this.highestPoint[0]+this.highestPoint[1]*this.size]) {
                        this.highestPoint[0] = x;
                        this.highestPoint[1] = y;
                    }
                }
                this.X++;
            }
            
        }   else if (this.stage === 4) {    //rivers
            if (this.rivers === 0) {
                var x, y;
                for (var i = 0; i < 200 && this.rivers < 100; i++) {
                    x = Math.floor(random(this.size));
                    y = Math.floor(random(this.size));
                    if (this.grid[x+y*this.size] === 1) {
                        this.updates.push({type:"river",x:x,y:y});
                        this.rivers++;
                    }
                }
            }   else {
                if (this.updates.length === 0) {
                    this.X = this.size;
                }
            }
            while(this.updates.length > 0 && win.performance.now() < end) {
                var u = this.updates[0];
                if (this.grid[u.x+u.y*this.size] === 1) {
                    this.river[u.x+u.y*this.size]++;
                    var d = this.GetDown(u.x, u.y);
                    if (d === undefined) {
                        this.updates.shift();
                    }   else {
                        this.updates[0].x = d.x; this.updates[0].y = d.y;
                    }
                }   else {
                    this.updates.shift();
                }
            }
        }   else if (this.stage === 5) {    //precipitation
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.precip[x + y*this.size] === -1) {
                        if (this.h === -1) {
                            if (this.grid[x + y*this.size] === 2) {
                                this.precip[x + y*this.size] = 5;
                                this.changes++;
                            }
                        }   else {
                            if (this.h <= 8) {
                                if (this.grid[x + y*this.size] === 0 || this.river[x+y*this.size] > 0) {
                                    this.precip[x + y*this.size] = 8;
                                    this.changes++;
                                }
                            }
                            var n = this.GetNeighbors(x, y);
                            var h = -1;
                            for (var i in n) {
                                if (this.precip[n[i].x + n[i].y*this.size] > h) {
                                    h = this.precip[n[i].x + n[i].y*this.size];
                                }
                            }
                            if (h > -1 && h >= this.h) {
                                this.precip[x+y*this.size] = Math.max(h - (random() < 0.5 ? 0.66 : 0.33), 0);
                                this.changes++;
                            }
                        }
                    }
                }
                this.X++;
            }
            if (this.X === this.size) {
                this.X = 0;
                if (this.h === -1) {
                    this.h = 10;
                }   else {
                    if (this.changes === 0) {
                        this.h--;
                    }
                    this.changes = 0;
                    if (this.h < 0) {
                        this.X = this.size;
                    }
                }
            }
        }   else if (this.stage === 6) {    //readjust precipitation
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.precip[x+y*this.size] = Math.floor(this.precip[x+y*this.size]/10*6);
                }
                this.X++;
            }
        }   else if (this.stage === 7) {    //temperature
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                }
                this.X++;
            }
        }   else if (this.stage === 8) {    //biomes
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    var c;
                    var h = Math.floor(this.vertex[x+y*this.size]/this.size*6*5);
                    switch (this.grid[x+y*this.size]) {
                        case 0: if (h > 2) {
                                c = color(157, 194, 201);
                            }   else {
                                c = color(25, 153, 227);
                            }   break;
                        case 1: if (this.river[x+y*this.size] > 0) {
                                    if (h > 2) {
                                    c = color(157, 194, 201);
                                }   else {
                                    c = color(25, 153, 227);
                                }
                            }   else {
                                switch (h) {
                                    case 0: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: c = color(10, 133, 72); break;
                                        case 3: case 2: c = color(10, 133, 23); break;
                                        case 1: c = color(179, 232, 35); break;
                                        case 0: c = color(209, 166, 58); break;
                                    } break;
                                    case 1: switch (this.precip[x+y*this.size]) {
                                        case 5: c = color(14, 156, 85); break;
                                        case 4: case 3: c = color(72, 133, 10); break;
                                        case 2: case 1: c = color(179, 232, 35); break;
                                        case 0: c = color(207, 195, 58); break;
                                    } break;
                                    case 2: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: c = color(121, 191, 95); break;
                                        case 3: case 2: c = color(155, 161, 135); break;
                                        case 1: case 0: c = color(207, 195, 58); break;
                                    } break;
                                    case 3: case 4: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: case 3: c = color(255); break;
                                        case 2: c = color(149, 189, 94); break;
                                        case 1: c = color(180); break;
                                        case 0: c = color(128);
                                    } break;
                                }
                            }
                            break;
                        case 2: c = color(4, 137, 209); break;
                    }
                    this.biome[x+y*this.size] = c;
                }
                this.X++;
            }
        }   else if (this.stage === 9) {    //add lava
            let ph = this.vertex[this.highestPoint[0] + this.highestPoint[1]*this.size]-5;
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.vertex[x + y*this.size] > ph) {
                        this.vertex[x + y*this.size] = ph-2;
                        this.biome[x + y*this.size] = -65536;
                    }
                }
                this.X++;
            }
        }
        if (this.X === this.size) {
            console.log(this.stage)
            this.X = 0;
            this.h = -1;
            this.stage++;
        }
    }
}

	class Section {
		constructor(x, y, z, size, chunk) {
			this.x = x
			this.y = y
			this.z = z
			this.size = size
			this.arraySize = size * size * size
			this.blocks = new Int32Array(this.arraySize)
			this.light = new Uint8Array(this.arraySize)
      this.tags = new Array(this.arraySize) //tags are like nbt in minecraft
			this.renderData = []
			this.renderLength = 0
			this.faces = 0
			this.hasVisibleBlocks = false
			this.chunk = chunk
			this.edited = false
			this.caves = !caves
			this.pallete = [0]
			this.palleteMap = {"0": 0}
			this.palleteSize = 0
		}
		getBlock(x, y, z) {
			let s = this.size
			return this.blocks[x * s * s + y * s + z]
		}
		setBlock(x, y, z, blockId) {
			let s = this.size
			this.blocks[x * s * s + y * s + z] = blockId
		}
		deleteBlock(x, y, z) {
			let s = this.size
			this.blocks[x * s * s + y * s + z] = 0
		}
		optimize() {
			let visible = false
			let pos = 0
			let xx = this.x
			let yy = this.y
			let zz = this.z
			let blockState = 0
			let palleteIndex = 0
			let index = 0
			let s = this.size
			let blocks = this.blocks
			this.hasVisibleBlocks = false
			this.renderLength = 0
			let localBlocks = world.getAdjacentSubchunks(xx, yy, zz)

			//Check all the blocks in the subchunk to see if they're visible.
			for (let i = 0; i < s; i++) {
				for (let j = 0; j < s; j++) {
					for (let k = 0; k < s; k++, index++) {
						blockState = blocks[index]

						if (this.palleteMap[blockState] === undefined) {
							this.palleteMap[blockState] = this.pallete.length
							palleteIndex = this.pallete.length
							this.pallete.push(blockState)
						} else {
							palleteIndex = this.palleteMap[blockState]
						}

						visible = blockState && (hideFace(i-1, j, k, localBlocks, blockState, getBlock, "west", "east")
						| hideFace(i+1, j, k, localBlocks, blockState, getBlock, "east", "west",this) << 1
						| hideFace(i, j-1, k, localBlocks, blockState, getBlock, "bottom", "top",this) << 2
						| hideFace(i, j+1, k, localBlocks, blockState, getBlock, "top", "bottom",this) << 3
						| hideFace(i, j, k-1, localBlocks, blockState, getBlock, "south", "north",this) << 4
						| hideFace(i, j, k+1, localBlocks, blockState, getBlock, "north", "south",this) << 5)
						if (visible) {
							pos = (i | j << 4 | k << 8) << 19
							this.renderData[this.renderLength++] = 1 << 31 | pos | visible << 13 | palleteIndex
							this.hasVisibleBlocks = true
						}
					}
				}
			}
		}
		updateBlock(x, y, z, world, leaveMe) {
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk)
			}
			let i = x
			let j = y
			let k = z
			let s = this.size
			x += this.x
			y += this.y
			z += this.z
			let blockState = this.blocks[i * s * s + j * s + k]
			let visible = blockState && (hideFace(x-1, y, z, 0, blockState, world.getBlock, "west", "east")
			| hideFace(x+1, y, z, 0, blockState, world.getBlock, "east", "west") << 1
			| hideFace(x, y-1, z, 0, blockState, world.getBlock, "bottom", "top") << 2
			| hideFace(x, y+1, z, 0, blockState, world.getBlock, "top", "bottom") << 3
			| hideFace(x, y, z-1, 0, blockState, world.getBlock, "south", "north") << 4
			| hideFace(x, y, z+1, 0, blockState, world.getBlock, "north", "south") << 5)
			let pos = (i | j << 4 | k << 8) << 19
			let index = -1

			// Find index of current block in this.renderData
			for (let i = 0; i < this.renderLength; i++) {
				if ((this.renderData[i] & 0x7ff80000) === pos) {
					index = i
					break
				}
			}

			// Update pallete
			if (this.palleteMap[blockState] === undefined) {
				this.palleteMap[blockState] = this.pallete.length
				this.pallete.push(blockState)
			}

			if (index < 0 && !visible) {
				// Wasn't visible before, isn't visible after.
				return
			}
			if (!visible) {
				// Was visible before, isn't visible after.
				this.renderData.splice(index, 1)
				this.renderLength--
				this.hasVisibleBlocks = !!this.renderLength
				return
			}
			if (visible && index < 0) {
				// Wasn't visible before, is visible after.
				index = this.renderLength++
				this.hasVisibleBlocks = true
			}
			this.renderData[index] = 1 << 31 | pos | visible << 13 | this.palleteMap[blockState]
      
      var block = world.getBlock(x,y,z)
      if(!leaveMe && blockData[block]) blockData[block].onupdate(x,y,z,block);
		}
		genMesh(barray, index) {
			if (!this.renderLength) {
				return index
			}
			let length = this.renderLength
			let rData = this.renderData
			let x = 0, y = 0, z = 0, loc = 0, data = 0,
				sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0,
				verts = null, texVerts = null, texShapeVerts = null,
				tx = 0, ty = 0
			let wx = this.x, wy = this.y, wz = this.z
			let blocks = world.getAdjacentSubchunks(wx, wy, wz)
			let lightChunks = world.getAdjacentSubchunks(wx, wy, wz, true)
			let block = null

			let shadows = null, slights = [0, 0, 0, 0], blights = [0, 0, 0, 0]
			let blockSides = Object.keys(Block)
			let side = ""
			let shapeVerts = null
			let shapeTexVerts = null
			let pallete = this.pallete
			// let intShad = interpolateShadows
			
			for (let i = 0; i < length; i++) {
				data = rData[i]
				block = blockData[pallete[data & 0x1fff]]
				tex = block.textures
				sides = data >> 13 & 0x3f
				loc = data >> 19 & 0xfff
				x = loc & 15
				y = loc >> 4 & 15
				z = loc >> 8 & 15

				x2 = x + this.x
				y2 = y + this.y
				z2 = z + this.z

				shapeVerts = block.shape.verts
				shapeTexVerts = block.shape.texVerts

				let texNum = 0
				for (let n = 0; n < 6; n++) {
					side = blockSides[n]
					if (sides & Block[side]) {
						shadows = getShadows[side](x, y, z, blocks)
						slights = getLight[side](x, y, z, lightChunks, slights, 0)
						blights = getLight[side](x, y, z, lightChunks, blights, 1) //top is actually bottom
						let directionalFaces = shapeVerts[Sides[side]]
						for (let facei = 0; facei < directionalFaces.length; facei++) {
							verts = directionalFaces[facei]
							texVerts = textureCoords[textureMap[tex[texNum]]]
							tx = texVerts[0]
							ty = texVerts[1]
							texShapeVerts = shapeTexVerts[n][facei]

							barray[index] = verts[0] + x2
							barray[index+1] = verts[1] + y2
							barray[index+2] = verts[2] + z2
							barray[index+3] = tx + texShapeVerts[0]
							barray[index+4] = ty + texShapeVerts[1]
							barray[index+5] = shadows[0]
							barray[index+6] = slights[0]
							barray[index+7] = blights[0]

							barray[index+8] = verts[3] + x2
							barray[index+9] = verts[4] + y2
							barray[index+10] = verts[5] + z2
							barray[index+11] = tx + texShapeVerts[2]
							barray[index+12] = ty + texShapeVerts[3]
							barray[index+13] = shadows[1]
							barray[index+14] = slights[1]
							barray[index+15] = blights[1]

							barray[index+16] = verts[6] + x2
							barray[index+17] = verts[7] + y2
							barray[index+18] = verts[8] + z2
							barray[index+19] = tx + texShapeVerts[4]
							barray[index+20] = ty + texShapeVerts[5]
							barray[index+21] = shadows[2]
							barray[index+22] = slights[2]
							barray[index+23] = blights[2]

							barray[index+24] = verts[9] + x2
							barray[index+25] = verts[10] + y2
							barray[index+26] = verts[11] + z2
							barray[index+27] = tx + texShapeVerts[6]
							barray[index+28] = ty + texShapeVerts[7]
							barray[index+29] = shadows[3]
							barray[index+30] = slights[3]
							barray[index+31] = blights[3]
							index += 32
						}
					}
					texNum++
				}
			}
			return index
		}
		carveCaves() {
			let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16
			for (let x = this.x, xx = 0; x < wx; x++, xx++) {
				for (let z = this.z, zz = 0; z < wz; z++, zz++) {
					wy = this.chunk.tops[zz * 16 + xx]
					for (let y = this.y; y < wy; y++) {
						if (isCave(x, y, z)) {
							carveSphere(x, y, z)
						}
					}
				}
			}
			this.caves = true
		}
		tick() {
			for (let i = 0; i < 3; i++) {
				let rnd = Math.random() * this.blocks.length | 0
				if ((this.blocks[rnd]) === blockIds.grass) {
					// Spread grass

					let x = (rnd >> 8) + this.x
					let y = (rnd >> 4 & 15) + this.y
					let z = (rnd & 15) + this.z
					if (!blockData[world.getBlock(x, y + 1, z)].transparent) {
						world.setBlock(x, y, z, blockIds.dirt, false)
						return
					}

					let rnd2 = Math.random() * 27 | 0
					let x2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - x2 - 1) / 3
					let y2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - y2 - 1) / 3
					z += rnd2 - 1
					x += x2
					y += y2

					if (world.getBlock(x, y, z) === blockIds.dirt && world.getBlock(x, y + 1, z) === blockIds.air) {
						world.setBlock(x, y, z, blockIds.grass, false)
					}
				} else if (this.blocks[rnd] === (blockIds.oakSapling | CROSS)){
          let i = (rnd >> 8) + this.x
					let j = (rnd >> 4 & 15) + this.y
					let k = (rnd & 15) + this.z
          blockData[blockIds.oakSapling].grow(i,j,k)
        }else if (this.blocks[rnd] === (blockIds.birchSapling | CROSS)){
          let i = (rnd >> 8) + this.x
					let j = (rnd >> 4 & 15) + this.y
					let k = (rnd & 15) + this.z
          blockData[blockIds.birchSapling].grow(i,j,k)
        }
			}
		}
		getLight(x, y, z, block = 0) {
			let s = this.size
			let i = x * s * s + y * s + z
			return (this.light[i] & 15 << (block * 4)) >> (block * 4)
		}
		setLight(x, y, z, level, block = 0) {
			let s = this.size
			let i = x * s * s + y * s + z
			this.light[i] = level << (block * 4) | (this.light[i] & 15 << (!block * 4))
		}
    getTags(x, y, z){
      let s = this.size
			return this.tags[x * s * s + y * s + z]
    }
    getTagByName(x, y, z, n){
      var t = this.getTags(x,y,z)
      return t && t[n]
    }
    setTags(x,y,z, data){
      let s = this.size
			this.tags[x * s * s + y * s + z] = data
    }
    setTagByName(x, y, z, n, data){
      let s = this.size
      var i = x * s * s + y * s + z
			var t = this.tags[i]
      if(!t){
        t = this.tags[i] = {}
      }
      t[n] = data
    }
	}
	let emptySection = new Section(0, 0, 0, 16)
	let fullSection = new Section(0, 0, 0, 16)
	fullSection.blocks.fill(blockIds.bedrock)
	emptySection.light.fill(15)

	class Chunk {
		constructor(x, z, type, world) {
			this.x = x
			this.z = z
			this.maxY = 0
			this.minY = 255
			this.sections = []
			this.cleanSections = []
			this.tops = new Uint8Array(16 * 16) // Store the heighest block at every (x,z) coordinate
      this.ceils = new Uint8Array(16 * 16) //for nether
			this.optimized = false
			this.generated = false; // Terrain
			this.populated = superflat === true // Trees and ores
			this.lit = false
			this.lazy = false
			this.edited = false
			this.loaded = false
      this.type = type || world.type
			// vao for this chunk
			this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			this.caves = !caves
      this.doubleRender = false
      this.world = world
		}
		getBlock(x, y, z) {
			let s = y >> 4
			return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0
		}
		setBlock(x, y, z, blockID, user) {
			if (!this.sections[y >> 4]) {
				do {
					this.sections.push(new Section(this.x, this.sections.length * 16, this.z, 16, this))
				} while (!this.sections[y >> 4])
			}
			if (user && !this.sections[y >> 4].edited) {
				this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
				this.sections[y >> 4].edited = true
				this.edited = true
			}
      if (blockData[blockID].semiTrans) {
        this.doubleRender = true
        if (!this.world.doubleRenderChunks.includes(this)) {
          this.world.doubleRenderChunks.push(this)
        }
      }
			this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
		}
    getTags(x, y, z){
      let s = y >> 4
			return this.sections.length > s ? this.sections[s].getTags(x, y & 15, z) : null
    }
    getTagByName(x,y,z,n){
      let s = y >> 4
			return this.sections.length > s ? this.sections[s].getTagByName(x, y & 15, z,n) : null
    }
    setTags(x,y,z,data){
      let s = y >> 4
			if(this.sections.length > s) this.sections[s].setTags(x, y & 15, z, data)
    }
    setTagByName(x,y,z,n,data){
      let s = y >> 4
			if(this.sections.length > s) this.sections[s].setTagByName(x, y & 15, z,n,data)
    }
		fillLight() {
			let max = this.sections.length * 16 - 1
			let blockSpread = []

			// Set virtical columns of light to level 15
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					let stop = false
					for (let y = max; y >= 0; y--) {
						let data = blockData[this.getBlock(x, y, z)]
						if (data.lightLevel) {
							if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
							blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
							this.setLight(x, y, z, data.lightLevel, 1)
						}
						if (!stop && !data.transparent) {
							this.tops[z * 16 + x] = y
							stop = true
						} else if (!stop) {
							this.setLight(x, y, z, 15, 0)
						}
					}
				}
			}

			// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
			let spread = []
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
						if (x === 15 || this.tops[z * 16 + x + 1] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (x === 0 || this.tops[z * 16 + x - 1] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (z === 15 || this.tops[(z + 1) * 16 + x] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (z === 0 || this.tops[(z - 1) * 16 + x] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						break
					}
				}
			}
			this.spreadLight(spread, 14)

			for (let i = blockSpread.length - 1; i > 0; i--) {
				let blocks = blockSpread[i]
				if (blocks && blocks.length) {
					this.spreadLight(blocks, i - 1, false, 1)
				}
			}

			this.lit = true
		}
		setLight(x, y, z, level, blockLight) {
			if(this.sections[y >> 4]) this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
		}
		getLight(x, y, z, blockLight = 0) {
			if (y >= this.sections.length * 16) return 15
      if(!this.sections[y >> 4]) return 0
			return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
		}
		trySpread(x, y, z, level, spread, blockLight, update = false) {
      if(y < 0) return
      
			if (world.getLight(x, y, z, blockLight) < level) {
				if (blockData[world.getBlock(x, y, z)].transparent) {
					world.setLight(x, y, z, level, blockLight)
					spread.push(x, y, z)
				}
			}
			if (update && (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15)) {
				let chunk = world.getChunk(x, z)
				if (chunk.buffer && !world.meshQueue.includes(chunk)) {
					world.meshQueue.push(chunk)
				}
			}
		}
		spreadLight(blocks, level, update = false, blockLight = 0) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
        if(y < 0) continue
				this.trySpread(x - 1, y, z, level, spread, blockLight, update)
				this.trySpread(x + 1, y, z, level, spread, blockLight, update)
				this.trySpread(x, y - 1, z, level, spread, blockLight, update)
				this.trySpread(x, y + 1, z, level, spread, blockLight, update)
				this.trySpread(x, y, z - 1, level, spread, blockLight, update)
				this.trySpread(x, y, z + 1, level, spread, blockLight, update)
			}
			if (level > 1 && spread.length) {
				this.spreadLight(spread, level - 1, update, blockLight)
			}
		}
		tryUnSpread(x, y, z, level, spread, respread, blockLight) {
      if(y < 0) return
      
			let light = world.getLight(x, y, z, blockLight)
			let trans = blockData[world.getBlock(x, y, z)].transparent
			if (light === level) {
				if (trans) {
					world.setLight(x, y, z, 0, blockLight)
					spread.push(x, y, z)
				}
			} else if (light > level) {
				respread[light].push(x, y, z)
			}
			if (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15) {
				let chunk = world.getChunk(x, z)
				if (chunk.buffer && !world.meshQueue.includes(chunk)) {
					world.meshQueue.push(chunk)
				}
			}
		}
		unSpreadLight(blocks, level, respread, blockLight) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
        if(y < 0) continue
				this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
			}
			if (level > 1 && spread.length) {
				this.unSpreadLight(spread, level - 1, respread, blockLight)
			}
		}
		reSpreadLight(respread, blockLight) {
			for (let i = respread.length - 1; i > 1; i--) {
				let blocks = respread[i]
				let level = i - 1
				let spread = respread[level]
				for (let j = 0; j < blocks.length; j += 3) {
					let x = blocks[j]
					let y = blocks[j+1]
					let z = blocks[j+2]
					this.trySpread(x - 1, y, z, level, spread, blockLight)
					this.trySpread(x + 1, y, z, level, spread, blockLight)
					this.trySpread(x, y - 1, z, level, spread, blockLight)
					this.trySpread(x, y + 1, z, level, spread, blockLight)
					this.trySpread(x, y, z - 1, level, spread, blockLight)
					this.trySpread(x, y, z + 1, level, spread, blockLight)
				}
			}
		}
		optimize() {
			for (let i = 0; i < this.sections.length; i++) {
				this.sections[i].optimize()
			}
			if (!world.meshQueue.includes(this)) {
				world.meshQueue.push(this)
			}
			this.optimized = true
		}
		render() {
			if (!this.buffer) {
				return
			}
			if (p.canSee(this.x, this.minY, this.z, this.maxY)) {
				renderedChunks++
				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
				gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
				glExtensions.vertex_array_object.bindVertexArrayOES(null)
			}
		}
		updateBlock(x, y, z, world, lazy, leaveMe) {
			if (this.buffer) {
				this.lazy = lazy
				if ((this.sections.length > y >> 4) && this.sections[y >> 4]) {
					this.sections[y >> 4].updateBlock(x, y & 15, z, world, leaveMe)
				}
			}
		}
		deleteBlock(x, y, z, user) {
			if (!this.sections[y >> 4]) {
				return
			}
			if (user && !this.sections[y >> 4].edited) {
				this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
				this.sections[y >> 4].edited = true
				this.edited = true
			}
			this.sections[y >> 4].deleteBlock(x, y & 15, z)
			this.minY = y < this.minY ? y : this.minY
			this.maxY = y > this.maxY ? y : this.maxY
		}
		carveCaves() {
			for (let i = 0; i < this.sections.length; i++) {
				if (!this.sections[i].caves) {
					this.sections[i].carveCaves()
					if (i + 1 >= this.sections.length) {
						this.caves = true
					}
					return
				}
			}
		}
		populate() {
      var flowers = [blockIds.flowerOftheValley, blockIds.poppy, blockIds.dandelion, 
                     blockIds.blueOrchid, blockIds.pinkTulip, blockIds.orangeTulip, blockIds.redTulip, blockIds.whiteTulip,
                     blockIds.azureBluet, blockIds.cornFlower, blockIds.purpleFlower, blockIds.witherRose,
                     blockIds.allium, blockIds.oxeyeDaisy,
                     blockIds.lilac, blockIds.roseBush, blockIds.peony,
                     blockIds.TallGrass, blockIds.DoubleTallGrass]
      
			randomSeed(hash(this.x, this.z) * 210000000)
			let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false, topsi = 0, tall = 0
      let trueX = this.x, trueY = this.y, trueZ = this.z
      let smoothness = generator.smooth, hilliness = generator.height
      let biomeSmooth = generator.biomeSmooth;
			let biome = 0
      let type = world.type

			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					wx = this.x + i
					wz = this.z + k

					ground = this.tops[k * 16 + i]
          biome = superflat ? 0 : noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
          var b
          if(superflat){b = "field"}else b = getBiome(biome)

          let nb = getNetherBiome(biome)
					if (trees && random() < 0.07 && type === "" && b === "field" && world.getBlock(i, ground, k) === blockIds.grass) {
            top = ground + floor(4.5 + random(2.5))
						rand = floor(random(4096))
						let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
            let leaf = blockIds.leaves
            let groundBlock = blockIds.dirt

						//Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, groundBlock)

						//Bottom leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 2, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 2, wz + z, leaf)
									}
								}
							}
						}

						//2nd layer leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 1, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 1, wz + z, leaf)
									}
								}
							}
						}

						//3rd layer leaves
						for (let x = -1; x <= 1; x++) {
							for (let z = -1; z <= 1; z++) {
								if (x || z) {
									if (x & z) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top, wz + z, leaf)
									}
								}
							}
						}

						//Top leaves
						world.spawnBlock(wx + 1, top + 1, wz, leaf)
						world.spawnBlock(wx, top + 1, wz - 1, leaf)
						world.spawnBlock(wx, top + 1, wz + 1, leaf)
						world.spawnBlock(wx - 1, top + 1, wz, leaf)
					}
          
          if(b === "snowyField" && trees && random() < 0.07 && type === "" && world.getBlock(i, ground, k)){
            top = ground + floor(4.5 + random(2.5))
						rand = floor(random(4096))
						let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
            let leaf = blockIds.leaves
            let groundBlock = blockIds.dirt
            let snow = blockIds.snow

						//Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, groundBlock)
            this.setBlock(i, top + 2, k, snow | LAYER2)
            
						//Top leaves
						world.spawnBlock(wx + 1, top + 1, wz, leaf)
						world.spawnBlock(wx, top + 1, wz - 1, leaf)
						world.spawnBlock(wx, top + 1, wz + 1, leaf)
						world.spawnBlock(wx - 1, top + 1, wz, leaf)
            world.spawnBlock(wx + 1, top + 2, wz, snow | LAYER1)
            world.spawnBlock(wx, top + 2, wz - 1, snow | LAYER1)
            world.spawnBlock(wx, top + 2, wz + 1, snow | LAYER1)
						world.spawnBlock(wx - 1, top + 2, wz, snow | LAYER1)

						//Bottom leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 2, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 2, wz + z, leaf)
									}
								}
							}
						}
            
						//3rd layer leaves
						for (let x = -1; x <= 1; x++) {
							for (let z = -1; z <= 1; z++) {
								if (x || z) {
									if (x & z) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top, wz + z, leaf)
                      if(rand & 2) world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER2)
                      else world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1)
										}
									} else {
										world.spawnBlock(wx + x, top, wz + z, leaf)
                    world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1)
									}
								}
							}
						}

						//2nd layer leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 1, wz + z, leaf)
                      if(rand & 2) world.spawnBlock(wx + x, top, wz + z, snow | LAYER2)
                      else world.spawnBlock(wx + x, top, wz + z, snow | LAYER1)
										}
									} else {
										world.spawnBlock(wx + x, top - 1, wz + z, leaf)
                    world.spawnBlock(wx + x, top, wz + z, snow | LAYER1)
									}
								}
							}
						}
            
            //get rid of snow underneath
						/*for (let x = -1; x <= 1; x++) {
							for (let z = -1; z <= 1; z++) {
								if(x || z){
                  var g = world.getTop(wx,wz)
                  if(g) world.setBlock(wx+i, g+1, wz+k, 0)
                }
							}
						}*/
            //
          }
          
          // Cactus
          if (random() < 0.01 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type !== "nether") {
            top = ground + Math.floor(2.5 + random(1.5));
            rand = Math.floor(random(4096));
            let tree = blockIds.cactus | CACTUS;

            //Center
            for (let j = ground + 1; j <= top; j++) {
              this.setBlock(i, j, k, tree);
            }
            this.setBlock(i, ground, k, blockIds.sand);
          }
          if (random() < 0.006 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type !== "nether") {
            let tree = blockIds.deadBush | CROSS;

            this.setBlock(i,ground+1,k, tree);
            this.setBlock(i, ground, k, blockIds.sand);
          }
          
          // Jungle trees
          if(trees && random() < 0.01 && type === "" && (b === "jungle" || b === "giantJungle") && world.getBlock(i, ground, k)){
            tall = floor(5 + random(5)) //5 to 10
            top = ground + tall
            let tree = blockIds.jungleLog
            let leaf = blockIds.leaves
            
            //Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, blockIds.dirt)
            
            //Bottom leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 2, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 2, wz + z, leaf)
									}
								}
							}
						}

						//2nd layer leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 1, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 1, wz + z, leaf)
									}
								}
							}
						}

						//3rd layer leaves
						for (let x = -1; x <= 1; x++) {
							for (let z = -1; z <= 1; z++) {
								if (x || z) {
									if (x & z) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top, wz + z, leaf)
									}
								}
							}
						}

						//Top leaves
						world.spawnBlock(wx + 1, top + 1, wz, leaf)
						world.spawnBlock(wx, top + 1, wz - 1, leaf)
						world.spawnBlock(wx, top + 1, wz + 1, leaf)
						world.spawnBlock(wx - 1, top + 1, wz, leaf)
          }//end jungle trees
          //Giant jungle trees
          if(trees && random() < 0.01 && type === "" && b === "giantJungle" && world.getBlock(i, ground, k)){
            tall = floor(10 + random(20)) //10 to 30
            top = ground + tall
            let tree = blockIds.jungleLog
            let leaf = blockIds.leaves
                  
            //Center
            for (let j = ground + 1; j < top; j++) {
              this.setBlock(i, j, k, tree)
              world.spawnBlock(wx + 1, j, wz, tree)
              world.spawnBlock(wx, j, wz + 1, tree)
              world.spawnBlock(wx+1, j, wz+1, tree)
            }
            this.setBlock(i, ground, k, blockIds.dirt)
            world.setBlock(wx + 1, ground, wz, blockIds.dirt)
            world.setBlock(wx, ground, wz + 1, blockIds.dirt)
            world.setBlock(wx+1, ground, wz+1, blockIds.dirt)

            //Messy part
            //leaves
            let w2 = 5 * 5
            let d2 = 5 * 5
            let h2 = 5 * 5
            for(var x=-4.5; x<4.5; x++){
              for(var y=2; y<4.5; y++){
                for(var z=-4.5; z<4.5; z++){
                  let n = x * x / w2 + y * y / h2 + z * z / d2
                  if (n < 1) {
                    world.spawnBlock(wx + x+1, top-4+y, wz + z+1, leaf)
                  }
                }
              }
            }

            //the diagonal branches
            w2 = 3 * 3
            d2 = 3 * 3
            h2 = 3 * 3
            for(y=ground+5; y<top; y += Math.floor(random(10))){
              let side = Math.floor(random(4))
              let mx=0,mz=0
              switch(side){
                case 0:
                  mx=1
                  break
                case 1:
                  mx=-1
                  break
                case 2:
                  mz=1
                  break
                case 3:
                  mz=-1
                  break
              }
              let x = mx === 1?2:mx, z = mz === 1?2:mz
              var rnd = Math.floor(random(4))+2
              //branch
              for(var by=0; by<rnd; by++){
                world.setBlock(wx+x, y+by, wz+z, tree)
                x += mx
                z += mz
              }
              x -= mx
              z -= mz
              by -= 1

              //leaves
              for(var lx=-3; lx<3; lx++){
                for(var ly=1; ly<3; ly++){
                  for(var lz=-3; lz<3; lz++){
                    let n = lx * lx / w2 + ly * ly / h2 + lz * lz / d2
                    if (n < 1) {
                      world.spawnBlock(wx+x + lx, y+by+ly, wz+z + lz, leaf)
                    }
                  }
                }
              }
              // m = move; l = leaf
            }
          }//end giant jungle trees; jungle bushes
          if(trees && random() < 0.007 && type === "" && (b === "jungle" || b === "giantJungle") && world.getBlock(i, ground, k)){
            let w2 = 3 * 3
            let d2 = 3 * 3
            let h2 = 3 * 3
            for(var x=-3; x<3; x++){
              for(var y=1; y<3; y++){
                for(var z=-3; z<3; z++){
                  let n = x * x / w2 + y * y / h2 + z * z / d2
                  if (n < 1) {
                    world.spawnBlock(wx+x, ground+y, wz+z, blockIds.leaves)
                  }
                }
              }
            }
            this.setBlock(i, ground+1, k, blockIds.jungleLog)
          }
          
          if (random() < 0.005 && type === "nether" && ground > 79 && nb !== 0){
            tall = floor(4.5 + random(2.5))
            if(floor(random(12)) === 1) tall *= 2
						top = ground + tall
						rand = floor(random(4096))
            let tree
            let leaf
            let groundBlock = blockIds.netherrack
            if(this.type === "nether"){
              if(nb === 1){
                tree = blockIds.warpedStem
                leaf = blockIds.warpedWartBlock
              }else if(nb === 2){
                tree = blockIds.crimsonStem
                leaf = blockIds.netherWartBlock
              }
            }
            
            //Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, groundBlock)
            
            //Shroomlight
            for(var l=0; l<3; l++) world.spawnBlock(wx + random(-2, 2), top + random(-1,1), wz + random(-2,2), blockIds.shroomlight)
            
            //Top leaves
            for(var x=-1; x<2; x++){
              for(var z=-1; z<2; z++){
                place = (x&1) && (z&1) ? rand & 1 : true
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top + 1, wz + z, leaf)
                }
              }
            }
            
            //layer 2 leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = (x===2 || x===-2) && (z===2 || z==-2) ? rand & 1 : true
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top, wz + z, leaf)
                }
              }
            }
            
            rand = floor(random(4096))
            //layer 1 leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = x===2 || x===-2 || z===2 || z==-2 ? !(rand & 1) : false
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top - 1, wz + z, leaf)
                }
              }
            }
            
            rand = floor(random(40964096))
            //drooping leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = x===2 || x===-2 || z===2 || z==-2
                rand >>>= 1
                if(place){
                  var h = rand & 4 && rand & 8 ? rand & 3 : 0
                  if(h){
                    world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
                    for(var y=0; y<h; y++){
                      world.spawnBlock(wx + x, top - 2 - y, wz + z, leaf)
                    }
                  }
                }
              }
            }
            
            if(nb === 2){
              rand = floor(random(40964096))
              //vines
              for(var x=-2; x<3; x++){
                for(var z=-2; z<3; z++){
                  place = x===2 || x===-2 || z===2 || z==-2
                  rand >>>= 1
                  if(place){
                    var h = (rand & 4 && rand & 8) ? (rand & (tall-2)) - 1 : 0
                    if(h){
                      world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
                      for(var y=0; y<h; y++){
                        world.spawnBlock(wx + x, top - 2 - y, wz + z, blockIds.weepingVinesPlant)
                      }
                      world.spawnBlock(wx + x, top - 2 - h, wz + z, blockIds.weepingVines)
                    }
                  }
                }
              }
            }
            
          }
          
          //flowers and vines
          if (random() < 0.05 && this.getBlock(i, ground, k) === blockIds.grass) {
            var flower = flowers[Math.round(random(flowers.length-1))]
            world.spawnBlock(wx, ground+1, wz, flower);
          }
          var block = this.getBlock(i, ground, k)
          if(random() < 0.05){
            if(block === blockIds.crimsonNylium){
              world.spawnBlock(wx, ground+1, wz, blockIds.crimsonRoots);
            }else if(block === blockIds.warpedNylium){
              world.spawnBlock(wx, ground+1, wz, blockIds.warpedRoots);
            }
          }
          
          //lava rivers
          if(random() < 0.005 && world.getBlock(i,ground,k) && this.type==="nether"){
            let it = 0
            let x=wx, y=ground, z=wz
            let dir=floor(random(0,8))
            for(; it<100; it++){
              let xp,zp
              switch(dir){
                case 0:
                  x+=1
                  zp=true
                  break
                case 1:
                  x+=1
                  z+=1
                  break
                case 2:
                  z+=1
                  xp=true
                  break
                case 3:
                  x-=1
                  z+=1
                  break
                case 4:
                  x-=1
                  zp=true
                  break
                case 5:
                  x-=1
                  z-=1
                  break
                case 6:
                  z-=1
                  xp=true
                  break
                case 7:
                  x+=1
                  z-=1
                  break
              }
              if(random() < 0.08){
                dir += round(random(-1,1))
              }
              let prev = world.getBlock(x,y,z)
              world.setBlock(x,y,z,blockIds.Lava)
              if(xp){
                world.setBlock(x+1,y,z,blockIds.Lava)
              }
              if(zp){
                world.setBlock(x,y,z+1,blockIds.Lava)
              }
              if(!prev && y>1){
                y--
                prev = world.getBlock(x,y,z)
                world.setBlock(x,y,z,blockIds.Lava)
                while(!prev && y>1){
                  y--
                  prev = world.getBlock(x,y,z)
                  world.setBlock(x,y,z,blockIds.Lava)
                }
              }
              if(world.getBlock(x,y-1,z) === blockIds.Lava) break
            }
          }

          if(this.type === "nether"){
            let l
            if(random() < 0.005){
              let r = random(12345123451234512345)*3
              let x=wx, y=this.ceils[k * 16 + i], z=wz
              let ri=floor(random(5,15))
              for(l=0; l<ri; l++){
                x += r&1 - 1; r >>>= 1
                y += r&3 - 2; r >>>= 1
                z += r&1 - 1; r >>>= 1
                world.spawnBlock(x,y,z, blockIds.glowstone)
              }
            }
            
            for(l=0; l<16; l++){
              let x = random(0, 16)
              let y = random(10, 177)
              let z = random(0, 16)
              if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
                world.setBlock(wx+x,y,wz+z, blockIds.netherQuartzOre)
              }
            }
            
            for(l=0; l<10; l++){
              let x = random(0, 16)
              let y = random(10, 177)
              let z = random(0, 16)
              if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
                world.setBlock(wx+x,y,wz+z, blockIds.netherGoldOre)
              }
            }
          }else{
            // Blocks of each per chunk in Minecraft
            // Coal: 185.5
            // Iron: 111.5
            // Gold: 10.4
            // Redstone: 29.1
            // Diamond: 3.7
            // Lapis: 4.1
            //there is also copper
            ground -= 4

            if (random() < 3.7 / 256) {
              let y = random() * 16 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre)
              }
            }

            if (random() < 111.5 / 256) {
              let y = random() * 64 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre)
              }
            }
            
            if (random() < 51 / 256) {
              let y = random() * 64 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.copperOre)
              }
            }

            if (random() < 185.5 / 256) {
              let y = random() * ground | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre)
              }
            }

            if (random() < 10.4 / 256) {
              let y = random() * 32 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre)
              }
            }

            if (random() < 29.1 / 256) {
              let y = random() * 16 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre)
              }
            }

            if (random() < 4.1 / 256) {
              let y = random() * 32 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre)
              }
            }
				  }
          
        }
			}

			this.populated = true
		}
		genMesh() {
			let start = performance.now()
			let barray = bigArray
			let index = 0
			for (let i = 0; i < this.sections.length; i++) {
				index = this.sections[i].genMesh(barray, index)
			}
			let arrayDone = performance.now()

			if (!this.buffer) {
				this.buffer = gl.createBuffer()
			}
			let data = barray.slice(0, index)

			let maxY = 0
			let minY = 255
			let y = 0
			for (let i = 1; i < data.length; i += 6) {
				y = data[i]
				maxY = max(maxY, y)
				minY = min(minY, y)
			}
			this.maxY = maxY
			this.minY = minY
			this.faces = data.length / 32
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
			gl.enableVertexAttribArray(glCache.aVertex)
			gl.enableVertexAttribArray(glCache.aTexture)
			gl.enableVertexAttribArray(glCache.aShadow)
			gl.enableVertexAttribArray(glCache.aSkylight)
			gl.enableVertexAttribArray(glCache.aBlocklight)
			gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 32, 0)
			gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 32, 12)
			gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 32, 20)
			gl.vertexAttribPointer(glCache.aSkylight, 1, gl.FLOAT, false, 32, 24)
			gl.vertexAttribPointer(glCache.aBlocklight, 1, gl.FLOAT, false, 32, 28)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			this.lazy = false
		}
		tick() {
			if (this.edited) {
				for (let i = 0; i < this.sections.length; i++) {
					if (this.sections[i].edited) {
						this.sections[i].tick()
					}
				}
			}
		}
		load() {
			let chunkX = this.x >> 4
			let chunkZ = this.z >> 4
			let load = null
			
			for (let i = 0; i < world.loadFrom.length; i++) {
				load = world.loadFrom[i]
				if (load.x === chunkX && load.z === chunkZ) {
					let y = load.y * 16
					for (let j in load.blocks) {
            if(blockData[load.blocks[j]]){ // if a block doesn't exsist, they won't be generated
						  world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j])
            }
					}
					world.loadFrom.splice(i--, 1)
				}
			}
			this.loaded = true
		}
	}

	class Contacts {
		constructor() {
			this.array = []
			this.size = 0
		}
		add(x, y, z, block) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
			}
			this.size++
		}
		clear() {
			this.size = 0
		}
	}

	class Entity {
		constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns, vao) {
			this.x = x
			this.y = y
			this.z = z
			this.previousX = x
			this.previousY = y
			this.previousZ = z
			this.canStepX = true
			this.canStepY = true
			this.pitch = pitch
			this.yaw = yaw
			this.velx = velx
			this.vely = vely
			this.velz = velz
			this.width = width
			this.height = height
			this.depth = depth
      this.offsetY = 0
      this.hidden = false
      this.harmEffect = 0
			this.contacts = new Contacts()
			this.lastUpdate = performance.now()
			this.onGround = false
      this.hasCollided = false
      this.gravityStength = -0.032
      this.standingOn = 0
			this.despawns = despawns
			this.spawn = this.lastUpdate
			this.canDespawn = false
      this.dieEffect = 0
      this.parts = {}
			this.faces = faces
      if(vao){
        this.vao = vao
      }else{
        this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
        const verticesBuffer = gl.createBuffer()
        const textureBuffer = gl.createBuffer()
        glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)

        gl.enableVertexAttribArray(glCache.aVertexEntity)
        gl.enableVertexAttribArray(glCache.aTextureEntity)
        glExtensions.vertex_array_object.bindVertexArrayOES(null)
      }
		}
    addPart(name,size,vao,x,y,z,w,h,d,rx,ry){
      this.parts[name] = {
        size,vao,
        x,y,z,w,h,d,rx,ry //all of these are relative to entity position
      }
    }
    renderPart(part, matrix){
			matrix.translate(part.x, part.y, part.z)
			matrix.rotX(part.rx)
			matrix.rotY(part.ry)
			matrix.scale(part.w, part.h, part.d)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, matrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(part.vao)
			gl.drawElements(gl.TRIANGLES, 6 * part.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			matrix.unscale(part.w, part.h, part.d)
			matrix.rotY(-part.ry)
			matrix.rotX(-part.rx)
      matrix.translate(-part.x, -part.y, -part.z)
    }
		updateVelocity(now) {
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt

      this.standingOn = world.getBlock(this.x, round(this.y-this.height-1), this.z)
      if (this.liquid){
        this.gravityStength = -0.01
        this.vely *= 0.9
      }else{
        this.gravityStength = -0.02
      }
      this.vely += this.gravityStength * dt
			if (this.vely < -1.5) {
				this.vely = -1.5
			}
			let drag = this.liquid ? 0.7 : (this.onGround ? 0.5 : 0.85)
      if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
			this.velz += (this.velz * 0.9 - this.velz) * dt
			this.velx += (this.velx * 0.9 - this.velx) * dt
			// this.vely += (this.vely * 0.9 - this.vely) * dt
		}
		collided(x, y, z, vx, vy, vz, block) {
			let verts = blockData[block].shape.verts
			let px = roundBits(this.x - this.width / 2 - x)
			let py = roundBits(this.y - this.height / 2 - y)
			let pz = roundBits(this.z - this.depth / 2 - z)
			let pxx = roundBits(this.x + this.width / 2 - x)
			let pyy = roundBits(this.y + this.height / 2 - y)
			let pzz = roundBits(this.z + this.depth / 2 - z)
			let minX, minY, minZ, maxX, maxY, maxZ, min, max

			//Top and bottom faces
			let faces = verts[0]
			if (vy <= 0) {
				faces = verts[1]
			}
			if (!vx && !vz) {
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minZ = min[2]
					max = face.max
					maxX = max[0]
					maxZ = max[2]
					if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
						if (vy <= 0) {
							this.onGround = true
							this.y = round((face[1] + y + this.height / 2) * 10000) / 10000
							this.vely = 0
							return false
						} else {
							return true
						}
					}
				}
				return false
			}

			//West and East faces
			if (vx < 0) {
				faces = verts[4]
			} else if (vx > 0) {
				faces = verts[5]
			}
			if (vx) {
				let col = false
				for (let face of faces) {
					min = face.min
					minZ = min[2]
					minY = min[1]
					max = face.max
					maxZ = max[2]
					maxY = max[1]
					if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
						if (maxY - py > 0.5) {
							this.canStepX = false
						}
						col = true
					}
				}
				return col
			}

			//South and North faces
			if (vz < 0) {
				faces = verts[2]
			} else if (vz > 0) {
				faces = verts[3]
			}
			if (vz) {
				let col = false
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minY = min[1]
					max = face.max
					maxX = max[0]
					maxY = max[1]
					if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
						if (maxY - py > 0.5) {
							this.canStepZ = false
						}
						col = true
					}
				}
				return col
			}
		}
		move(now) {
			let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null

      this.liquid = false
			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = world.getBlock(x, y, z)
						if (block && blockData[block].solid && !blockData[block].liquid) {
							this.contacts.add(x, y, z, block)
						}
            if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
              this.liquid = true
            }
					}
				}
			}
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt

			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z

			this.canStepX = false
			this.canStepY = false
			this.onGround = false
      this.hasCollided = false
			//Check collisions in the Y direction
			this.y += this.vely * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, this.vely, 0, block[3])) {
					this.y = this.previousY
					this.vely = 0
          this.hasCollided = true
					break
				}
			}

			if (this.y === this.previousY) {
				this.canStepX = true
				this.canStepZ = true
			}

			//Check collisions in the X direction
			this.x += this.velx * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], this.velx, 0, 0, block[3])) {
					if (this.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.x = this.previousX
					this.velx = 0
          this.hasCollided = true
					break
				}
			}

			//Check collisions in the Z direction
			this.z += this.velz * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, 0, this.velz, block[3])) {
					if (this.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.z = this.previousZ
					this.velz = 0
          this.hasCollided = true
					break
				}
			}
      
      if(this.onGround){
        this.hasCollided = true
      }

			this.lastUpdate = now
			this.contacts.clear()
		}
		update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
		}
		render() {
      if(this.hidden) return
      
			const offsetY = this.offsetY
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y + offsetY, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
      modelMatrix.rotX(this.dieEffect)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1)
			const skysLight = world.getLight(x, y, z, 0) * (skyLight / 15)
			const lightLevel = min(max(skysLight, blockLight) * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
      gl.uniform1f(glCache.harmEffectEntity, this.harmEffect || this.dieEffect)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      for(var part in this.parts){
        this.renderPart(this.parts[part], modelViewProjectionMatrix)
      }
		}
	}

	class Item extends Entity {
		constructor(x, y, z, velx, vely, velz, blockID, autoSetVel, amount) {
			const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
			super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      this.block = blockID
      this.type = "Item"
      //this.amount = amount || 1
      
      if(autoSetVel){
        this.velx = (Math.random()-0.5) * 0.2
        this.vely = Math.random() * 0.2
        this.velz = (Math.random()-0.5) * 0.2
      }
		}
    update() {
      if(this.amount <= 0){
        return this.canDespawn = true
      }
      
      let now = performance.now()
      this.yaw += 0.01;
      if(this.yaw > Math.PI*2){
        this.yaw -= Math.PI*2
      }
      
			this.updateVelocity(now)
		  this.move(now)
      
      let xDist = this.x - p.x
      let yDist = this.y - p.y
      let zDist = this.z - p.z
      let pickup = xDist > -1 && xDist < 1 && yDist > -1.5 && yDist < 1 && zDist > -1 && zDist < 1
      if(pickup){
        var dist = dist3(this.x, this.y, this.z, p.x, p.y, p.z)
        var dist2 = dist3(this.x, this.y, this.z, p.x, p.y-1, p.z)
        pickup = ((1 >= dist) && (dist >= -1)) || ((1 >= dist2) && (dist2 >= -1))
      }
      
      /*if(multiplayer ? host : true){
        let d = 3/4
        var updateShape
        for(var i=0; i<world.entities.length; i++){
          var e = world.entities[i]
          if(e.type === "Item" && e !== this){
            xDist = this.x - e.x
            yDist = this.y - e.y
            zDist = this.z - e.z
            let stack = xDist > -d && xDist < d && yDist > -d && yDist < d && zDist > -d && zDist < d
            if(stack){
              this.amount += e.amount
              e.amount = 0
              updateShape = true
            }
          }
        }
        if(updateShape) this.updateShape()
      }*/
      
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
        
			}
      if(pickup){
        /*var a = this.amount
        for(var i=0; i<a; i++){
          if(newInvItem(this.block)) this.amount --
          else break
        }
        if(this.amount === 0){
          this.canDespawn = true
          updateHUD = true
          playSound("entity.item.pickup")
        }else this.updateShape()*/
        if(newInvItem(this.block)){
          this.canDespawn = true
          if(this.block === blockIds.oakLog || this.block === blockIds.birchLog || this.block === blockIds.jungleLog){
            achievment("Getting Wood")
          }
          if(this.block === blockIds.diamond){
            achievment("DIAMONDS!")
          }
          updateHUD = true
          playSound("entity.item.pickup")
        }
      }
      
      this.offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
    }
    updateShape(){
      if(blockData[this.block].shape !== shapes.cube) return
      var shape
      if(this.amount === 1){
        shape = "cube"
      }else if(this.amount < 4){
        shape = "cube"+this.amount
      }else{
        shape = "cube4"
      }
      const block = blockData[this.block]
			const tex = block.textures
			shape = shapes[shape]
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity))
      texture = new Float32Array(texture),
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      this.faces = size
    }
	}
  win.Item = Item
  class BlockEntity extends Entity{
    constructor(blockID, x,y,z, solidOnGround, cacheBlocks){
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      super(x, y, z, 0, 0, 0, 0, 0, 0.996, 0.996, 0.996, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      this.block = blockID
      this.type = "BlockEntity"
      this.solidOnGround = solidOnGround
      this.cacheBlocks = cacheBlocks
      
      this.cached = {}
      if(cacheBlocks){
        this.cached[blockID] = this.vao
      }
    }
    changeBlock(blockID){
      if(this.cached[blockID]){
        this.vao = this.cached[blockID]
        return
      }
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture),
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      if(this.cacheBlocks){
        this.cached[blockID] = this.vao
      }
    }
    update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      if(this.onGround && this.solidOnGround){
        var x = round(this.x), y = round(this.y), z = round(this.z)
        var b = world.getBlock(x, y-1, z)
        if(blockData[b] && blockData[b].shape === shapes.cube){
          world.setBlock(x,y,z, this.block)
          blockSound(this.block, "land", x,y,z)
        }else{
          // non cube block breaks falling blocks
          world.addEntity(new Item(x,y,z, 0,0,0, this.block))
        }
        this.canDespawn = true
      }
		}
  }
  win.BlockEntity = BlockEntity
  
  class PrimedTNT extends BlockEntity{
    constructor(x,y,z){
      super(blockIds.tnt, x,y,z)
      this.type = "PrimedTNT"
      this.velx = (Math.random() * 0.1) - 0.05
      this.vely = Math.random() * 0.1
      this.velz = (Math.random() * 0.1) - 0.05
      var e = this
      var i = 0
      var int = setInterval(() => {
        e.changeBlock((i % 2) ? blockIds.tnt : blockIds.whiteConcrete)
        if(i >= 16){
          clearInterval(int)
          e.canDespawn = true
          explode(round(e.x),round(e.y),round(e.z),4)
        }
        i++
      },250)
    }
  }
  
  class EnderPearl extends BlockEntity{
    constructor(x,y,z,velx,vely,velz){
      super(blockIds.enderPearl, x,y,z)
      this.type = "EnderPearl"
      this.velx = velx
      this.vely = vely
      this.velz = velz
      this.from = achexUsername
      
      this.gravityStrength = -0.05
    }
    updateVelocity(now) {
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt

      this.vely += this.gravityStength * dt
			if (this.vely < -1.5) {
				this.vely = -1.5
			}
		}
    update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
      var fromMe = this.from === achexUsername
			if (fromMe && now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      if(fromMe && this.hasCollided){
        p.x = this.x
        p.y = this.y
        p.z = this.z
        this.canDespawn = true
      }
		}
  }
  
  class crackEntity extends Entity{
    constructor(tex, x,y,z){
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
			}
      super(x, y, z, 0, 0, 0, 0, 0, 1.01, 1.01, 1.01, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
      
      this.cached = {}
    }
    cacheTexture(tex){
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture)
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      this.cached[tex] = this.vao
    }
    changeTexture(tex){
      this.vao = this.cached[tex]
    }
    render(){
      const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const skysLight = world.getLight(x, y+1, z, 0) * (skyLight / 15)
			const lightLevel = min(skysLight * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  
  //character is seen in 3rd person mode
  class Character extends Entity{
    constructor(blockID){
      const block = blockData[blockID & 255]
			const tex = block.textures
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
			super(0, 0, 0, 0, 0, 0, 0, 0, 0.6, 1.7, 0.6, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
      
      this.cached = {}
      this.cached[blockID] = this.vao
      this.die = false
      
      //this.addPart("thing",this.faces,this.vao,1,0,0,1,1,1,0,0)
    }
    update(){
      this.offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
      if(this.harmEffect > 0){
        this.harmEffect --
      }
      if(this.die){
        this.dieEffect += 0.06
        if(this.dieEffect > Math.PI2){
          this.y = 0
          this.die = false
          this.dieEffect = 0
        }
      }
    }
    changeBlock(blockID){
      if(this.cached[blockID])return this.vao = this.cached[blockID]
      
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture),
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      this.cached[blockID] = this.vao
    }
  }
  window.Player = Character
  
  //world.entities.push(new Cow(p2.x, p2.y, p2.z))
  class Mob extends Entity{
    constructor(){
			super(...arguments)
      this.moveTime = 0
      this.spinTime = 0
      this.spin = 0
      this.dirx = 0
      this.dirz = 0
      this.health = 0
      this.lastY = this.y
    }
    AI(now){
      let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt
      if(this.moveTime > 0){
        this.moveTime --
        this.velx += this.dirx / 100
        this.velz += this.dirz / 100
      }else if(this.spinTime > 0){
        this.spinTime --
        this.yaw += this.spin
        if(this.yaw > Math.PI*2){
          this.yaw -= Math.PI*2
        }
        if(this.yaw < 0){
          this.yaw += Math.PI*2
        }
      }else if(Math.random()>0.8){
        if(Math.random() > 0.5){
          this.spinTime = Math.random()*60
          this.spin = (Math.random()>0.5 ? 0.05 : -0.05)
        }else{
          this.moveTime = Math.random()*60
          this.dirx = Math.cos(this.yaw)
          this.dirz = -Math.sin(this.yaw)
        }
      }
      if(this.moveTime > 0 && Math.random() > 0.5){
        var b = world.getBlock(round(this.x+this.dirx), this.y, round(this.z+this.dirz))
        if(this.onGround && blockData[b].solid && !blockData[b].liquid){
          this.vely = 0.3
        }
        if(blockData[b].liquid){
          this.vely += 0.05
        }
      }
    }
    update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
      
      //health and death & stuff
      if(this.onGround){
        let fall = this.lastY - this.y
        this.lastY = this.y
        if(fall > 3){
          let damage = Math.floor(fall-3)
          this.health -= damage
          this.harmEffect = 40
        }
      }
      if(this.harmEffect > 0){
        this.harmEffect --
      }
      if(this.health <= 0){
        this.health = -1
        this.dieEffect += 0.06
        if(this.dieEffect > Math.PI2){
          this.canDespawn = true
        }
      }
      
      this.AI(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
		}
    onhit(damage){
      this.health -= damage
      this.harmEffect = 40
    }
  }
  
  class Cow extends Mob{
    constructor(x,y,z){
      const tex = ["cow","cow","cowSide","cowSide","cowSide","cowSide"]
			const shape = shapes.cow
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < blockSides.length; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      
      this.type = "Cow"
      this.health = 10
    }
  }
  
  class Pig extends Mob{
    constructor(x,y,z){
      const tex = new Array(6).fill("pinkWool")
			const shape = shapes.cow
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < blockSides.length; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      super(x, y, z, 0, 0, 0, 0, 0, .9, .9, .9, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      
      this.type = "Pig"
      this.health = 10
    }
  }
  
  class Particle extends Entity{
		constructor() {
			super(...arguments)
		}
		updateVelocity(now) {
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt
			this.vely += -0.02 * dt
			if (this.vely < -1.5) {
				this.vely = -1.5
			}

      let drag = this.onGround ? 0 : 0.9
			this.velz += (this.velz * drag - this.velz) * dt
			this.velx += (this.velx * drag - this.velx) * dt
			// this.vely += (this.vely * 0.9 - this.vely) * dt
		}
		update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      //var magnitude = dist3(this.x,this.y,this.z,p.x,p.y,p.z)
      this.yaw = atan2(p.z - this.z, p.x-this.x)
      var adjacent = dist2(this.x,this.z,p.x,p.z)
      this.pitch = atan2(p.y - this.y, adjacent)
		}
		render() {
			const offsetY = this.offsetY
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y + offsetY, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1)
			const skysLight = world.getLight(x, y, z, 0) * (skyLight / 15)
			const lightLevel = min(max(skysLight, blockLight) * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerParticle, 0)
			gl.uniform1f(glCache.uLightLevelParticle, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
	}
  
  class BlockParticle extends Particle{
    constructor(tex, x,y,z){
      let s=4/16
      let bs = 3/16 //particle size
      let p=1/(16+4)
      let offX = random(p), offY = random(p)
      let velx = (Math.random()-0.5) * 0.3,
          vely = Math.random() * 0.2,
          velz = (Math.random()-0.5) * 0.3
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[Sides[side]]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap[tex]]
          let tx = texVerts[0] + offX
          let ty = texVerts[1] + offY
          let texShapeVerts = shapeTexVerts[n][facei]
          texture[index    ] = tx + (texShapeVerts[0]*s)
          texture[index + 1] = ty + (texShapeVerts[1]*s)
          texture[index + 2] = tx + (texShapeVerts[2]*s)
          texture[index + 3] = ty + (texShapeVerts[3]*s)
          texture[index + 4] = tx + (texShapeVerts[4]*s)
          texture[index + 5] = ty + (texShapeVerts[5]*s)
          texture[index + 6] = tx + (texShapeVerts[6]*s)
          texture[index + 7] = ty + (texShapeVerts[7]*s)
          index += 8
        }
      }
      super(x, y, z, 0, 0, velx, vely, velz, bs, bs, bs, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Math.random()*3000)
    }
  }
  win.BlockParticle = BlockParticle
  
  class ExplodeParticle extends Particle{//doesn't work
    constructor(x,y,z){
      var vao = explodeVaos[8]
      super(x, y, z, 0, 0, 0, 0, 0, 2, 2, 2, null, null, explodeVaos.size, explodeVaos.length*500, vao)
      this.index = 0
    }
    update(){
      let now = performance.now()
			if (now - this.spawn > this.despawns) {
				//this.canDespawn = true
			}
      this.index = Math.floor((now - this.spawn) / 500)
      //this.vao = explodeVaos[this.index]
    }
    render(){
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1)
			const skysLight = world.getLight(x, y, z, 0) * (skyLight / 15)
			const lightLevel = min(max(skysLight, blockLight) * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, explodeTexture)
			gl.uniform1i(glCache.uSamplerParticle, 3) //explode texture
			gl.uniform1f(glCache.uLightLevelParticle, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  win.ExplodeParticle = ExplodeParticle
  
  function initEntitys(){
    win.explodeVaos = explodeVaos
    explodeVaos.size = shapes.blockParticle.size
    const shape = shapes.blockParticle
    const shapeVerts = shape.verts
    const shapeTexVerts = shape.texVerts
    for(let y=0; y<4; y++){
      for(let x=0; x<4; x++){
        var texSize = 1/4
        let blockSides = Object.keys(Block)
        let texture = []
        let index = 0
        for (let n = 0; n < 6; n++) {
          let side = blockSides[n]
          let directionalFaces = shapeVerts[Sides[side]]
          for (let facei = 0; facei < directionalFaces.length; facei++) {
            let tx = x / 4
            let ty = y / 4
            let texShapeVerts = shapeTexVerts[n][facei]
            texture[index    ] = tx + texSize
            texture[index + 1] = ty
            texture[index + 2] = tx
            texture[index + 3] = ty
            texture[index + 4] = tx
            texture[index + 5] = ty + texSize
            texture[index + 6] = tx + texSize
            texture[index + 7] = ty + texSize
            index += 8
          }
        }
        var vao = glExtensions.vertex_array_object.createVertexArrayOES()
        const verticesBuffer = gl.createBuffer()
        const textureBuffer = gl.createBuffer()
        glExtensions.vertex_array_object.bindVertexArrayOES(vao)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
        gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)

        gl.enableVertexAttribArray(glCache.aVertexParticle)
        gl.enableVertexAttribArray(glCache.aTextureParticle)
        glExtensions.vertex_array_object.bindVertexArrayOES(null)
        explodeVaos.push(vao)
      }
    }
  }

	let analytics = {
		totalTickTime: 0,
		worstFrameTime: 0,
		totalRenderTime: 0,
		totalFrameTime: 0,
		lastUpdate: 0,
		frames: 1,
		displayedTickTime: "0",
		displayedRenderTime: "0",
		displayedFrameTime: "0",
		displayedwFrameTime: 0,
		fps: 0,
	}
	function chunkDist(c) {
		let dx = p.x - c.x
		let dz = p.z - c.z
		if (dx > 16) {
			dx -= 16
		} else if (dx > 0) {
			dx = 0
		}
		if (dz > 16) {
			dz -= 16
		} else if (dz > 0) {
			dz = 0
		}
		return Math.sqrt(dx * dx + dz * dz)
	}
	function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
		let dx1 = p.x - c1.x - 8
		let dy1 = p.z - c1.z - 8
		let dx2 = p.x - c2.x - 8
		let dy2 = p.z - c2.z - 8
		return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
	}
	function fillReqs(x, z) {
		// Chunks must all be loaded first.
		var done = true
		for (let i = x - 3; i <= x + 3; i++) {
			for (let j = z - 3; j <= z + 3; j++) {
				let chunk = world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
				if (!chunk.generated) {
					world.generateQueue.push(chunk)
					done = false
				}
				if (!chunk.populated && i >= x - 2 && i <= x + 2 && j >= z - 2 && j <= z + 2) {
					world.populateQueue.push(chunk)
					done = false
				}
				if (world.loadFrom.length && !chunk.loaded && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.loadQueue.push(chunk)
					done = false
				} else if (!world.loadFrom.length && !chunk.loaded) {
					chunk.loaded = true
				}
				if (!chunk.lit && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.lightingQueue.push(chunk)
					done = false
				}
			}
		}
		return done
	}
	function maxDist(x, z, x2, z2) {
		let ax = abs(x2 - x)
		let az = abs(z2 - z)
		return max(ax, az)
	}
	function renderFilter(chunk) {
		return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= settings.renderDistance
	}

	function debug(message) {
		let ellapsed = performance.now() - debug.start
		if (ellapsed > 30) {
			console.log(message, ellapsed.toFixed(2), "milliseconds")
		}
	}
  
  function login(){
    return new Promise((resolve, reject) => {
      var w = width / 2
      var h = height / 2
      var x = w - (w/2)
      var y = h - (h/2)
      var w = open("https://www.thingmaker.repl.co/website/login.html", "login","resizable=no,width="+w+",height="+h+",top="+y+",left="+x)
      function onmsg(event){
        if (event.source !== w) return;
        if (event.data.startsWith("logged:")){
          w.close()
          window.removeEventListener("message", onmsg);
          resolve(event.data.replace("logged:",''))
        }else if(event.data === "canceled"){
          w.close()
          window.removeEventListener("message", onmsg);
          reject()
        }
      }
      window.addEventListener("message", onmsg);
    })
  }

  var achexUsername = "player"+Date.now()
  win.username = ""
  async function loggedIn(){
    var logged = false;
    await fetch("https://server.thingmaker.repl.co/getuser", {credentials:"include"}).then(r => r.text()).then(r => logged=r)
    if(logged){
      username = logged
      return logged
    }else{
      if(confirm("Your not logged in. Head over to www.thingmaker.repl.co/login.html to login.\n\nPress OK to login,")){
        var logged
        await login().then(r => logged=r).catch(r => logged=r)
        if(logged){
          username = logged
          return logged
        }
      }
      return false
      changeScene("main menu")
    }
  }
  async function getWorlds(pingCallback){
    if(!navigator.onLine) return "offline"
    var logged = await loggedIn()
    if(!logged){
      return "notLoggedIn"
    }
    var worlds
    await fetch("https://server.thingmaker.repl.co/worlds").then(r => r.json()).then(r => worlds=r)
    if(pingCallback){
      fetch("https://server.thingmaker.repl.co/worldsPing").then(r => r.json()).then(pingCallback)
    }
    return worlds
  }
  var multiplayer = null
  var players = {}
  win.playersInv = {}
  function hasPlayer(username){
    for(var i in players){
      if(players[i].username === username) return true
    }
  }
  function getPlayerByUsername(username){
    for(var i in players){
      if(players[i].username === username) return players[i]
    }
  }
  /*const hub = "Minekhan"
  function sendHub(obj){
    let str = JSON.stringify({
      "toH": hub,
      "msg": JSON.stringify(obj)
    })
    multiplayer.send(str)
    return str
  }
  function sendUser(user, obj){
    let str = JSON.stringify({
      "to": user,
      "msg": JSON.stringify(obj)
    })
    multiplayer.send(str)
    return str
  }*/
  function send(msg, to){
    msg.FROM = achexUsername
    msg.USER = username
    if(to) msg.TO = to
    multiplayer.send(JSON.stringify(msg))
  }
  var host
  function initMultiplayer(target){
    if(multiplayer) return
    var ban = []
    host = false
    if(!target){
      target = world.id || 0
      host = true
    }
    players = {} //empty
    multiplayer = new WebSocket("wss://server.thingmaker.repl.co/ws?target="+target)
    multiplayer.onopen = e => {
			/*multiplayer.send(JSON.stringify({
        "auth": achexUsername,
        "passwd":"none"
      }))
      multiplayer.send(JSON.stringify({
        "joinHub":hub,
        "passwd":"none"
      }))*/
      send({
        "type":"connect",
        username: username,
        id: achexUsername
      })
      if(host){
        send({
          "type":"init",
          name: world.name
        })
      }
      send({
        "type":"getSave"
      })

      var invStuff = {}
      multiplayer.pos = setInterval(() => {
        if(world){
          invStuff.invItems = invItems
          invStuff.hotbar = inventory.hotbar
          send({type:"pos", data:p3, host:host, dimension: world.type, inv:invStuff})
          if(host){
            send({type:"entityPosAll", data: world.getEntities()})
          }
        }
      }, 500)
		}
		multiplayer.onmessage = msg => {
			let packet = JSON.parse(msg.data)
			var author = packet.FROM //should be the id
      var data = packet//.msg ? JSON.parse(packet.msg) : {}
      
      if(data.type === "ping"){
        send({
          type:"pong",
          data:Date.now()
        })
      }else if(data.type === "getSave" && host){
        if(ban.includes(data.USER)){
          send({
            type: "ban",
            data: data.USER
          }, author)
        }else{
          send({
            type:"loadSave",
            data:world.getSaveString(),
            nether:world.getNetherSaveString(),
            mod: world.mod,
            id: world.id || Date.now(),
            time: worldTime,
            dimension: world.type || "overworld",
            cheats:cheats,
            inv: playersInv[data.USER]
          }, author)
        }
      }else if(data.type === "loadSave"){
        dimensions = {
          overworld: new World(),
          nether: new World("nether")
        }
        world = dimensions.overworld

        world.id = data.id

        if (data.data) {
          try {
            world.loadSave(data.data)
          }catch(e) {
            alert("Unable to load save code")
            return
          }
        }
        if (data.nether) {
          let world = dimensions.nether
          try {
            world.loadSave(data.nether)
          }catch(e) {
            alert("Unable to load nether save code")
            return
          }
        }
        try{
          world.mod = data.mod
          mod = Object.constructor("return "+data.mod)()
        }catch(e){console.log("error loading mod: "+e)}
        if(survival){
          setHotbar([0,0,0,0,0,0,0,0,0])
        }
        world = dimensions[data.dimension || "overworld"]
        worldTime = data.time
        cheats = data.cheats
        if(data.inv){
          invItems = data.inv.invItems
          inventory.hotbar = data.inv.hotbar
        }
        changeScene("loading")
      }else if(data.type === "pos"){
        var pos = data.data
        if(!players[author]){
          players[author] = new Player(abs( (pos.username || "").hashCode()) % 80 + 1)
        }
        let thisplayer = players[author]
        thisplayer.x = pos.x
        thisplayer.y = pos.y - 1
        thisplayer.z = pos.z
        thisplayer.yaw = pos.ry
        thisplayer.dimension = data.dimension
        thisplayer.id = author
        thisplayer.survival = pos.survival
        thisplayer.harmEffect = pos.harmEffect
        if(thisplayer.username !== pos.username){
          thisplayer.username = pos.username
          thisplayer.changeBlock(abs((pos.username || "").hashCode()) % 80 + 1)
        }
        thisplayer.crackPos = pos.crackPos
        thisplayer.crack = pos.crack //crack number
        if(data.host){
          worldTime = pos.time
        }
        playersInv[data.USER] = data.inv
      }else if(data.type === "dc"){
        delete players[data.data]
      }else if(data.type === "setBlock"){
        let pos = data.data
        let world = dimensions[pos.dimension]
        let prevBlock = world.getBlock(pos.x, pos.y, pos.z)
        world.setBlock(pos.x, pos.y, pos.z, pos.block, false, false, true)
        if(pos.block){
          if(!prevBlock){
            blockSound(pos.block, "place", pos.x, pos.y, pos.z)
          }
        }else{
          blockSound(prevBlock, "dig", pos.x, pos.y, pos.z)
        }
      }else if(data.type === "entityPos"){
        let world = getWorld(data.dimension)
        world.posEntity(data)
      }else if(data.type === "entityPosAll"){
        var arr = data.data
        //if(arr.length !== world.entities.length) world.entities = []
        for(var i=0; i<arr.length; i++){
          let world = getWorld(arr[i].dimension)
          world.posEntity(arr[i])
        }
      }else if(data.type === "entityDelete"){
        world.deleteEntity(data.id, true)
      }else if(data.type === "achievment"){
        Messages.add(data.USER+" earned the achievment: "+data.data)
      }else if(data.type === "hit"){
        if(survival){
          damage(data.data || 1, data.username+" killed "+username)
          p.velocity.x += data.velx
          p.velocity.z += data.velz
        }
      }else if(data.type === "harmEffect"){
        players[data.id].harmEffect = 40
      }else if(data.type === "kill"){
        dieMessage = data.data
        die()
      }else if(data.type === "die"){
        players[data.id].die = true
        Messages.add(data.message)
      }else if(data.type === "message"){
        if(data.fromServer){
          Messages.add(data.data)
        }else{
          Messages.write(data.data, data.username)
        }
      }else if(data.type === "eval"){
        try{
          eval(data.data)
        }catch(e){
          console.error(e)
        }
      }else if(data.type === "error"){
        alert(data.data)
      }
		}

		multiplayer.onclose = () => {
			alert("Connection lost!")
      clearInterval(multiplayer.pos)
      multiplayer = null
		}
		multiplayer.onerror = () => {
      multiplayer.close()
    }
    
    win.ban = username => {
      if(!host) return alert("Only the host can ban")
      send({
        type: "ban",
        data: username
      })
      if(!ban.includes(username)) ban.push(username)
    }
    win.unban = username => {
      if(!host) return alert("Only the host can unban")
      if(ban.includes(username)) {
        var i = ban.indexOf(username)
        if(i === -1) return
        ban.splice(i,1)
      }
    }
  }
  
  function getNetherBiome(biome) {
    if(biome > 0.4 && biome < 0.5){
      return 1
    }else if(biome > 0.4){
      return 2
    }
    return 0
  }
  function getBiome(biome){
    if(biome > 0.6){
      return "snowyField"
    }else if(biome > 0.5){
      return "desert"
    }else if(biome > 0.4){
      return "field"
    }else if(biome > 0.36){
      return "jungle"
    }else if(biome > 0.3){
      return "giantJungle"
    }else{
      return "oakForest"
    }
  }
  function getDimension(){
    if(world.type === ""){
      return "overworld"
    }else return world.type
  }
  function getWorld(d){
    if(!d){
      d = "overworld"
    }
    return dimensions[d]
  }
  win.getWorld = getWorld

  let skyLight = 0
  let worldTime = 0 //current in-game time
	let fogDist = 16
	class World {
		constructor(type) {
			generatedChunks = 0
			fogDist = 16
			p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)

      this.type = type || ""
      this.spawnPoint = {
        x: 0,
        y: p.y,
        z: 0
      }

			//Initialize the world's arrays
			this.chunks = []
			this.loaded = []
			this.sortedChunks = []
      this.doubleRenderChunks = []
			this.offsetX = 0
			this.offsetZ = 0
			this.lwidth = 0
			this.chunkGenQueue = []
			this.populateQueue = []
			this.generateQueue = []
			this.lightingQueue = []
			this.loadQueue = []
			this.meshQueue = []
			this.loadFrom = []
			this.entities = []
      this.particles = []
			this.lastChunk = ","
      
      this.edited = false
      this.saveStr = null
		}
		genChunk(chunk) {
			let x = chunk.x >> 4
			let z = chunk.z >> 4
			let trueX = chunk.x
			let trueZ = chunk.z

			if (chunk.generated) {
				return false
			}
			let hide = !loadString
			let smoothness = generator.smooth
			let hilliness = generator.height
      let biomeSmooth = generator.biomeSmooth
      //{ for the nether terrain
      const biomeSize = 1//0.001 // smaller = bigger
			const flatness = 40 // bigger = flatter
			const overhang = 3 // bigger = more overhang; flatter = less overhang
			const bottom = 4 // Minimum height of the ground
			const hillSize = 0.006 // smaller = bigger; 0.005 to 0.01 seems the be a reasonable range
      //}
			let gen = 0, floatGen = 0
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
          floatGen = noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness + generator.extra
					gen = superflat === "island" && this.type === "" ? win.islandGenerator.GetHeight(x*16+i, z*16+k) : (superflat ? 4 : Math.round(floatGen))
          if(this.type === "nether" && superflat){
            gen = Math.round(floatGen)
          }
					chunk.tops[k * 16 + i] = gen
          if(this.type === "nether"){
            let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
            let b = getNetherBiome(biome)
            let block = blockIds.netherrack
            if(b === 1){
              block = blockIds.warpedNylium
            }else if(b === 2){
              block = blockIds.crimsonNylium
            }
            const smo = noise((trueX + i) * biomeSize, (trueZ + k) * biomeSize) * flatness + 40
            let top = 0
            let solid = true
            for (let j = 1; j < 128; j++) {
              if (noise((trueX + i)/smo, overhang*j/smo, (trueZ + k)/smo) - (j - bottom) * hillSize > 0) {
                chunk.setBlock(i, j, k, blockIds.netherrack)
                top = j
                solid = true
              } else if (solid) {
                chunk.setBlock(i, j - 1, k, block)
                /*if (chunk.getBlock(i, j - 2, k)) chunk.setBlock(i, j - 2, k, block)
                if (chunk.getBlock(i, j - 3, k)) chunk.setBlock(i, j - 3, k, block)
                if (chunk.getBlock(i, j - 4, k)) chunk.setBlock(i, j - 4, k, block)*/
                solid = false
              } else if(j < 80){
                chunk.setBlock(i, j-1, k, blockIds.Lava)
                if(chunk.getBlock(i, j - 2, k) === block) chunk.setBlock(i, j-2, k, blockIds.netherrack)
              }
            }

            chunk.tops[k * 16 + i] = top
            chunk.setBlock(i, 0, k, blockIds.bedrock)
            
            block = blockIds.netherrack
            for(let j=1; j<gen; j++){
              chunk.setBlock(i, maxHeight - 50 - j, k, block)
            }
            chunk.setBlock(i,maxHeight-50,k, blockIds.bedrock)
            chunk.ceils[k * 16 + i] = maxHeight - 50 - gen
          }else if (superflat === "island") {
            if (win.islandGenerator.GetWaterDepth(x*16+i, z*16+k) > 0) {
              chunk.setBlock(i, gen, k, blockIds.Water);
              chunk.setBlock(i, gen - 1, k, blockIds.Water)
              chunk.setBlock(i, gen - 2, k, blockIds.dirt)
              chunk.setBlock(i, gen - 3, k, blockIds.dirt)
            }   else {
              let biomeHere =win.islandGenerator.GetBiomeType(x*16+i, z*16+k);
              if (biomeHere === -3161286) {
                chunk.setBlock(i, gen, k, blockIds.sand)
                chunk.setBlock(i, gen - 1, k, blockIds.sand)
                chunk.setBlock(i, gen - 2, k, blockIds.sand)
                chunk.setBlock(i, gen - 3, k, blockIds.sand)
              }   else if (biomeHere === -1) {
                chunk.setBlock(i, gen, k, blockIds.whiteConcrete)
                chunk.setBlock(i, gen - 1, k, blockIds.whiteConcrete)
                chunk.setBlock(i, gen - 2, k, blockIds.stone)
                chunk.setBlock(i, gen - 3, k, blockIds.stone)
              }   else if (biomeHere === -4934476 || biomeHere === -8355712 || biomeHere === -6963874) {
                chunk.setBlock(i, gen, k, blockIds.stone)
                chunk.setBlock(i, gen - 1, k, blockIds.stone)
                chunk.setBlock(i, gen - 2, k, blockIds.stone)
                chunk.setBlock(i, gen - 3, k, blockIds.stone)
              } else if (biomeHere === -65536) {
                chunk.setBlock(i, gen, k, blockIds.Lava)
                chunk.setBlock(i, gen - 1, k, blockIds.stone)
                chunk.setBlock(i, gen - 2, k, blockIds.stone)
                chunk.setBlock(i, gen - 3, k, blockIds.stone)
              } else {
                chunk.setBlock(i, gen, k, blockIds.grass)
                chunk.setBlock(i, gen - 1, k, blockIds.dirt)
                chunk.setBlock(i, gen - 2, k, blockIds.dirt)
                chunk.setBlock(i, gen - 3, k, blockIds.dirt)
              }
            }
          } else if(superflat){
            chunk.tops[k * 16 + i] = gen;

            chunk.setBlock(i, gen, k, blockIds.grass);
            chunk.setBlock(i, gen - 1, k, blockIds.dirt);
            chunk.setBlock(i, gen - 2, k, blockIds.dirt);
            chunk.setBlock(i, gen - 3, k, blockIds.dirt);
          }else{
            let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth);
            var b = getBiome(biome)
            if(b === "desert"){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.sand);
              chunk.setBlock(i, gen - 1, k, blockIds.sand);
              chunk.setBlock(i, gen - 2, k, blockIds.sand);
              chunk.setBlock(i, gen - 3, k, blockIds.sand);
              if(gen<60) {
                    gen = 59;
                    chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
                    chunk.setBlock(i, gen, k, blockIds.Water);
                    chunk.setBlock(i, gen - 1, k, blockIds.Water);
                    chunk.setBlock(i, gen - 2, k, blockIds.gravel);
                    chunk.setBlock(i, gen - 3, k, blockIds.gravel);
              }
              if(gen>120){
                  chunk.setBlock(i, gen, k, blockIds.stone);
              }
              if(gen>140){
                  chunk.setBlock(i, gen, k, blockIds.sand);
              }
            }

            if(b === "field" || b === "oakForest"){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.grass);
              chunk.setBlock(i, gen - 1, k, blockIds.dirt);
              chunk.setBlock(i, gen - 2, k, blockIds.dirt);
              chunk.setBlock(i, gen - 3, k, blockIds.dirt);
              if(gen<60) {
                gen = 59;
                chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
                chunk.setBlock(i, gen, k, blockIds.Water);
                chunk.setBlock(i, gen - 1, k, blockIds.Water);
                chunk.setBlock(i, gen - 2, k, blockIds.gravel);
                chunk.setBlock(i, gen - 3, k, blockIds.gravel);
              }
            }
            if(b === "snowyField"){
              chunk.tops[k * 16 + i] = gen;

              if(gen >= 60){
                var h = ceil(((floatGen + 0.5) % 1) * 8)
                switch(h){//really smooth terrain!
                  case 1:
                    chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER1)
                    break
                  case 2:
                    chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER2)
                    break
                  case 3:
                    chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER3)
                    break
                  case 4:
                    chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER4)
                    break
                  case 5:
                    chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER5)
                    break
                  case 6:
                    chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER6)
                    break
                  case 7:
                    chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER7)
                    break
                  case 8:
                    chunk.setBlock(i, gen + 1, k, blockIds.snowBlock)
                    break
                }
                chunk.setBlock(i, gen, k, blockIds.grass | CROSS);
                chunk.setBlock(i, gen - 1, k, blockIds.dirt);
                chunk.setBlock(i, gen - 2, k, blockIds.dirt);
                chunk.setBlock(i, gen - 3, k, blockIds.dirt);
              }
              if(gen<60) {
                gen = 59;
                chunk.setBlock(i, gen+1, k, blockIds.ice);
                chunk.setBlock(i, gen, k, blockIds.ice);
                chunk.setBlock(i, gen - 1, k, blockIds.Water);
                chunk.setBlock(i, gen - 2, k, blockIds.gravel);
                chunk.setBlock(i, gen - 3, k, blockIds.gravel);
              }
            }
            
            if(b === "jungle" || b === "giantJungle"){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.mossBlock);
              chunk.setBlock(i, gen - 1, k, blockIds.dirt);
              chunk.setBlock(i, gen - 2, k, blockIds.dirt);
              chunk.setBlock(i, gen - 3, k, blockIds.dirt);
              
              if(gen<60) {
                chunk.setBlock(i, 60, k, blockIds.Water | SLAB);
                for(var y=59; y>=gen; y--){
                  chunk.setBlock(i, y, k, blockIds.Water);
                }
                chunk.setBlock(i, gen, k, blockIds.gravel);
                chunk.setBlock(i, gen - 1, k, blockIds.gravel);
              }
            }
          }
          if(this.type !== "nether"){
            for (let j = 1; j < gen - 3; j++) {
              chunk.setBlock(i, j, k, blockIds.stone)
            }
            chunk.setBlock(i, 0, k, blockIds.bedrock)
          }
				}
			}
			chunk.generated = true
		}
		getAdjacentSubchunks(x, y, z, lights) {
			let minChunkX = x - 16 >> 4
			let maxChunkX = x + 16 >> 4
			let minChunkY = y - 16 >> 4
			let maxChunkY = y + 16 >> 4
			let minChunkZ = z - 16 >> 4
			let maxChunkZ = z + 16 >> 4
			let section = null
			let ret = []
			for (x = minChunkX; x <= maxChunkX; x++) {
				for (let y = minChunkY; y <= maxChunkY; y++) {
					for (z = minChunkZ; z <= maxChunkZ; z++) {
						if (y < 0) {
							ret.push(lights ? emptySection.light : emptySection.blocks)
						} else if (this.chunks[x] && this.chunks[x][z]) {
							section = this.chunks[x][z].sections[y] || emptySection
							ret.push(lights ? section.light : section.blocks)
						} else {
							ret.push(lights ? emptySection.light : emptySection.blocks)
						}
					}
				}
			}
			return ret
		}
		updateBlock(x, y, z, lazy, leaveMe) {
			let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
			if (chunk && chunk.buffer) {
				chunk.updateBlock(x & 15, y, z & 15, this, lazy, leaveMe)
			}
		}
		getChunk(x, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			return this.loaded[X * this.lwidth + Z]
		}
		getWorldBlock(x, y, z) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return blockIds.air
			}
			return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15)
		}
		getBlock(x, y, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (y > maxHeight) {
				return blockIds.air
			} else if (y < 0) {
				return blockIds.air
			} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
				return this.getWorldBlock(x, y, z)
			}
			return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15)
		}
		setBlock(x, y, z, blockID, lazy, leaveSelf, remote) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return
			}
      if(y < 0) return
			let chunk = this.chunks[x >> 4][z >> 4]
      
			let xm = x & 15
			let zm = z & 15
			if (blockID) {
				chunk.setBlock(xm, y, zm, blockID, !lazy)
				let data = blockData[blockID]
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, true, data.lightLevel)
				}
			} else {
				let data = blockData[chunk.getBlock(xm, y, zm)]
				chunk.deleteBlock(xm, y, zm, !lazy)
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, false, data.lightLevel)
				}
			}
      chunk.setTags(xm, y, zm, null)

			if (lazy) {
				return
			}
      
      if(multiplayer && !remote){
        send({type:"setBlock", data:{x:x, y:y, z:z, block:blockID, dimension:getDimension()}})
      }

			//Update the 6 adjacent blocks and 1 changed block
			if (xm && xm !== 15 && zm && zm !== 15) {
				chunk.updateBlock(xm - 1, y, zm, this, lazy)
				chunk.updateBlock(xm + 1, y, zm, this, lazy)
				chunk.updateBlock(xm, y - 1, zm, this, lazy)
				chunk.updateBlock(xm, y + 1, zm, this, lazy)
				chunk.updateBlock(xm, y, zm - 1, this, lazy)
				chunk.updateBlock(xm, y, zm + 1, this, lazy)
			}
			else {
				this.updateBlock(x - 1, y, z, lazy)
				this.updateBlock(x + 1, y, z, lazy)
				this.updateBlock(x, y - 1, z, lazy)
				this.updateBlock(x, y + 1, z, lazy)
				this.updateBlock(x, y, z - 1, lazy)
				this.updateBlock(x, y, z + 1, lazy)
			}

			chunk.updateBlock(xm, y, zm, this, lazy, leaveSelf)

			// Update the corner chunks so shadows in adjacent chunks update correctly
			if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy); }
			if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy); }
			if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy); }
			if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy); }
      
      this.edited = true
		}
    getWorldTags(x, y, z) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return
			}
			return this.chunks[x >> 4][z >> 4].getTags(x & 15, y, z & 15)
		}
    getTags(x,y,z){
      let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (y > maxHeight) {
				return
			} else if (y < 0) {
				return
			} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
				return this.getWorldTags(x, y, z)
			}
			return this.loaded[X * this.lwidth + Z].getTags(x & 15, y, z & 15)
    }
    getTagByName(x,y,z,n){
      var t = this.getTags(x,y,z)
      return t && t[n]
    }
    setTags(x,y,z,data){
      if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return
			}
      if(y < 0) return
			let chunk = this.chunks[x >> 4][z >> 4]
      
			let xm = x & 15
			let zm = z & 15
      chunk.setTags(xm, y, zm, data)
    }
    setTagByName(x,y,z,n,data){
      if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return
			}
      if(y < 0) return
			let chunk = this.chunks[x >> 4][z >> 4]
      
			let xm = x & 15
			let zm = z & 15
      chunk.setTagByName(xm, y, zm, n,data)
    }
		getLight(x, y, z, blockLight = 0) {
      if(y < 0) return 0
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
        return this.chunks[x >> 4][z >> 4].getLight(x & 15, y, z & 15, blockLight)
			}
			return this.loaded[X * this.lwidth + Z].getLight(x & 15, y, z & 15, blockLight)
		}
		setLight(x, y, z, level, block) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			return this.loaded[X * this.lwidth + Z].setLight(x & 15, y, z & 15, level, block)
		}
		updateLight(x, y, z, place, blockLight = 0) {
			let chunk = this.getChunk(x, z)
			let cx = x & 15
			let cz = z & 15
			let center = chunk.getLight(cx, y, cz, 0)
			let blight = chunk.getLight(cx, y, cz, 1)
			let up = this.getLight(x, y+1, z)
			let down = this.getLight(x, y-1, z)
			let north = this.getLight(x, y, z+1)
			let south = this.getLight(x, y, z-1)
			let east = this.getLight(x+1, y, z)
			let west = this.getLight(x-1, y, z)

			let spread = []
			if (!place) { // Block was removed; increase light levels
				if ((up & 15) === 15) {
					for (let i = y; i > 0; i--) {
						if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 15)
							spread.push(x, i, z)
						} else {
							break
						}
					}
					chunk.spreadLight(spread, 14, true)
				} else {
					center = max(up, down, north, south, east, west)
					if (center > 0) center -= 1
					this.setLight(x, y, z, center)
					if (center > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, center - 1, true)
					}
				}

				// Block light levels
				if (!blockLight || blockLight < blight) {
					spread.length = 0
					up = this.getLight(x, y+1, z, 1)
					down = this.getLight(x, y-1, z, 1)
					north = this.getLight(x, y, z+1, 1)
					south = this.getLight(x, y, z-1, 1)
					east = this.getLight(x+1, y, z, 1)
					west = this.getLight(x-1, y, z, 1)
					blight = max(up, down, north, south, east, west)
					if (blight > 0) blight -= 1
					this.setLight(x, y, z, blight, 1)
					if (blight > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, blight - 1, true, 1)
					}
				}
			}
			else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
				let respread = []
				for (let i = 0; i <= center + 1; i++) respread[i] = []
				chunk.setLight(cx, y, cz, 0, 0)
				chunk.setLight(cx, y, cz, 0, 1)
				spread.push(x, y, z)

				// Sky light
				if (center === 15) {
					for (let i = y-1; i > 0; i--) {
						if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 0)
							spread.push(x, i, z)
						} else {
							break
						}
					}
				}
				chunk.unSpreadLight(spread, center - 1, respread)
				chunk.reSpreadLight(respread)

				// Block light
				if (blight) {
					respread.length = 0
					for (let i = 0; i <= 15/*blight + 1*/; i++) respread[i] = []
					spread.length = 0
					spread.push(x, y, z)
					chunk.unSpreadLight(spread, blight - 1, respread, 1)
					chunk.reSpreadLight(respread, 1)
				}
			}
			if (place && blockLight) { // Light block was placed
				this.setLight(x, y, z, blockLight, 1)
				spread.length = 0
				spread.push(x, y, z)
				chunk.spreadLight(spread, blockLight - 1, true, 1)

			} else if (!place && blockLight) { // Light block was removed
				this.setLight(x, y, z, 0, 1)
				spread.push(x, y, z)
				let respread = []
				for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
				chunk.unSpreadLight(spread, blockLight - 1, respread, 1)
				chunk.reSpreadLight(respread, 1)
			}
		}
		spawnBlock(x, y, z, blockID) {
			//Sets a block anywhere without causing block updates around it. Only to be used in world gen.
      
      if(blockData[blockID].crossShape) blockID |= CROSS
      if(blockData[blockID].tallcrossShape) blockID |= TALLCROSS
      if(blockData[blockID].cactus) blockID |= CACTUS
      
			let chunkX = x >> 4
			let chunkZ = z >> 4
			if (!this.chunks[chunkX]) {
				this.chunks[chunkX] = []
			}
			let chunk = this.chunks[chunkX][chunkZ]
			if (!chunk) {
				chunk = new Chunk(chunkX * 16, chunkZ * 16,this.type, this)
				this.chunks[chunkX][chunkZ] = chunk
			}
			if (chunk.buffer) {
				//Only used if spawning a block post-gen
				this.setBlock(x, y, z, blockID, true)
			} else if (!chunk.getBlock(x & 15, y, z & 15)) {
				chunk.setBlock(x & 15, y, z & 15, blockID)
			}
		}
    getEntity(id){
      for(var i=0; i<this.entities.length; i++){
        if(this.entities[i].id === id){
          return i
        }
      }
    }
    addEntity(ent, remote){
      if(!ent.id)ent.id = Date.now()
      if(multiplayer && !remote){
        //host controls entities
        send({type:"entityPos", id:ent.id, entType:ent.type, pos:{x:ent.x, y:ent.y, z:ent.z, yaw:ent.yaw, pitch:ent.pitch, block:ent.block, velx:ent.velx, vely:ent.vely, velz:ent.velz, amount:ent.amount, solidOnGround:ent.solidOnGround}, dimension:this.type})
        this.entities.push(ent)
      }else{
        this.entities.push(ent)
      }
    }
    deleteEntity(id, remote, i){
      i = (i || i===0) ? i : this.getEntity(id)
      if(!(i || i===0)) return
      var ent = this.entities[i]
      if(multiplayer && !remote){
        send({type:"entityDelete", id:ent.id})
      }
      this.entities.splice(i, 1)
    }
    posEntity(d){ //for multiplayer.onmessage only
      let p = d.pos
      var i = this.getEntity(d.id)
      var ent
      if(i || i===0){
        ent = this.entities[i]
      }else{
        switch(d.entType){
          case "Item":
            ent = new Item(0, 0, 0, 0, 0, 0, p.block, false, p.amount)
            break
          case "BlockEntity":
            ent = new BlockEntity(p.block, 0,0,0, p.solidOnGround)
            break
          case "PrimedTNT":
            ent = new PrimedTNT(0,0,0)
            break
          case "Cow":
            ent = new Cow(0,0,0)
            break
          case "Pig":
            ent = new Pig(0,0,0)
            break
          default:
            break
        }
        if(!ent) return
        ent.id = d.id
        this.addEntity(ent, true)
      }
      if(!ent) return
      ent.x = p.x
      ent.y = p.y
      ent.z = p.z
      ent.yaw = p.yaw
      ent.pitch = p.pitch
      ent.velx = p.velx
      ent.vely = p.vely
      ent.velz = p.velz
    }
    getEntities(){
      if(this.entities.length === 0) return this.entities.length //its an empty array, so no problems
      return this.entities.map(ent => {
        return {
          id:ent.id,
          entType:ent.type,
          pos: {x:ent.x, y:ent.y, z:ent.z, yaw:ent.yaw, pitch:ent.pitch, block:ent.block, velx:ent.velx, vely:ent.vely, velz:ent.velz, amount:ent.amount,solidOnGround:ent.solidOnGround},
          dimension:this.type
        }
      })
    }
		tick() {
			let tickStart = performance.now()
			let maxChunkX = (p.x >> 4) + settings.renderDistance
			let maxChunkZ = (p.z >> 4) + settings.renderDistance
			let chunk = maxChunkX + "," + maxChunkZ
			if (chunk !== this.lastChunk) {
				this.lastChunk = chunk
				this.loadChunks()
				this.chunkGenQueue.sort(sortChunks)
			}
      
      worldTime += 0.0005

			if (controlMap.break.pressed && !Key.control && p.lastBreak < Date.now() - 250 && screen === "play" && !survival && !entHitbox.ent) { // survival breaking isn't instant
				changeWorldBlock(0)
			}
			if ((controlMap.place.pressed || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250 && !p.autoBuild) {
				newWorldBlock()
			}
			if (controlMap.break.pressed && p.autoBreak && !Key.control) {
				changeWorldBlock(0)
			}
      if ((controlMap.place.pressed || Key.leftMouse && Key.control) && p.autoBuild) {
				newWorldBlock()
			}

			for (let i = 0; i < this.sortedChunks.length; i++) {
				this.sortedChunks[i].tick()
			}

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.update()
				if (entity.canDespawn || (entity.y <= -64)) {
					this.deleteEntity(0, false, i)
				}
			}
      for (let i = this.particles.length - 1; i >= 0; i--) {
				const particle = this.particles[i]
				particle.update()
				if (particle.canDespawn || (particle.y <= -64)) {
					this.particles.splice(i,1)
				}
			}
      updtPlayer()
      if(multiplayer){
        for(let i in players){
          players[i].update()
        }
      }

			do {
				let doneWork = false
				debug.start = performance.now()
				if (this.meshQueue.length) {
					// Update all chunk meshes.
					let len = this.meshQueue.length - 1
					do {
						this.meshQueue.pop().genMesh()
					} while(this.meshQueue.length)
					doneWork = true
					debug("Meshes")
				}

				if (this.generateQueue.length && !doneWork) {
					let chunk = this.generateQueue.pop()
					this.genChunk(chunk)
					doneWork = true
				}
				if (this.populateQueue.length && !doneWork) {
					let chunk = this.populateQueue[this.populateQueue.length - 1]
					if (!chunk.caves) {
						chunk.carveCaves()
						debug("Carve caves")
					} else if (!chunk.populated) {
						chunk.populate()
						this.populateQueue.pop()
					}
					doneWork = true
				}

				if (this.loadQueue.length && !doneWork) {
					this.loadQueue.pop().load()
					doneWork = true
					if (!this.loadQueue.length) {
						return
					}
				}
				if (this.lightingQueue.length && !doneWork) {
					this.lightingQueue.pop().fillLight()
					doneWork = true
				}

				if (this.chunkGenQueue.length && !doneWork) {
					let chunk = this.chunkGenQueue[0]
					if (!fillReqs(chunk.x >> 4, chunk.z >> 4)) {}
					else if (!chunk.optimized) {
						chunk.optimize(this)
						debug("Optimize")
					} else if (!chunk.buffer) {
						chunk.genMesh()
						debug("Initial mesh")
					} else {
						this.chunkGenQueue.shift()
						generatedChunks++
					}
					doneWork = true
				}
				if (!doneWork) {
					break
				}
			} while(performance.now() - tickStart < 5)
		}
		render() {
      gl.useProgram(program3D);
			initModelView(p)
      if(this.type === "nether"){
        skyLight = 0
        if(inWater === 1) gl.clearColor(0,0,255,1)
        else if(inWater === 2) gl.clearColor(255,0,0,1)
        else gl.clearColor(0, 0, 0, 1)
			  gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
      }else{
			  skyLight = min(max(abs(worldTime % (Math.PId*1.2) - Math.PI) / Math.PI - 0.04, 0.1), 1)
        if(inWater === 1) gl.clearColor(0,0,255,1)
        else if(inWater === 2) gl.clearColor(255,0,0,1)
        else gl.clearColor(sky[0] * skyLight, sky[1] * skyLight, sky[2] * skyLight, 1)
			  gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
        //skybox render
        if(inWater === 0){
          /*gl.useProgram(skyboxProgram);
          gl.uniform1f(glCache.skyboxTime, worldTime);
          gl.depthFunc(gl.ALWAYS);
          gl.disable(gl.CULL_FACE);
          skybox.render();
          gl.depthFunc(gl.LESS);
          gl.enable(gl.CULL_FACE)*/
        }
      }
      
      gl.useProgram(program3D);
			renderedChunks = 0

			let dist = (settings.renderDistance) * 16
			if (this.chunkGenQueue.length) {
				this.chunkGenQueue.sort(sortChunks)
				let chunk = this.chunkGenQueue[0]
				dist = min(dist, chunkDist(chunk))
			}
			if (dist !== fogDist) {
				if (fogDist < dist - 0.1) fogDist += (dist - fogDist) / 120
				else if (fogDist > dist + 0.1) fogDist += (dist - fogDist) / 30
				else fogDist = dist
			}
			gl.uniform3f(glCache.uPos, p.x, p.y, p.z)
			gl.uniform1f(glCache.uDist, fogDist)
			// this is interesting because uTime is not actually based on time
			// if you are going to change this to use actual time change line 4487 as well
			// since it depends on it
			gl.uniform1f(glCache.uTime, skyLight)
      if(inWater) gl.uniform3f(glCache.skyColor, 0, 0, 255)
      else gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])
      gl.uniform1i(glCache.inWater, inWater)

			let c = this.sortedChunks
			for (let chunk of c) {
				chunk.render()
			}
      if (this.doubleRenderChunks.length) {
				gl.depthMask(false)
				gl.uniform1i(glCache.uTrans, 1)
				for (let chunk of this.doubleRenderChunks) {
					chunk.render()
				}
				gl.uniform1i(glCache.uTrans, 0)
				gl.depthMask(true)
			}

			gl.uniform3f(glCache.uPos, 0, 0, 0)
      gl.uniform1i(glCache.inWater, 0)

			gl.useProgram(programEntity)

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.render()
			}
      if(multiplayer){
        for(let i in players){
          let player = players[i]
          if(player.dimension === world.type){
            player.render()
            if(player.crack > -1 && player.survival){
              let pos = player.crackPos
              crack.entity.x = pos[0]
              crack.entity.y = pos[1]
              crack.entity.z = pos[2]
              crack.entity.changeTexture(crack[player.crack])
              crack.entity.render()
            }
          }
        }
      }
      renderPlayer()

      if(crack.idx > -1 && survival){
        crack.entity.x = crack.pos[0]
        crack.entity.y = crack.pos[1]
        crack.entity.z = crack.pos[2]
        crack.entity.changeTexture(crack.tex)
        crack.entity.render()
      }
      
      gl.useProgram(programParticle)
      for (let i = this.particles.length - 1; i >= 0; i--) {
				const particle = this.particles[i]
				particle.render()
			}
      
      gl.useProgram(program3D)
			if(hitBox.pos) {
				blockOutlines = true
				blockFill = false
				block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, p)
				blockOutlines = false
				blockFill = true
			}
		}
		loadChunks() {
			let renderDistance = settings.renderDistance + 3
			let cx = p.x >> 4
			let cz = p.z >> 4
			p.cx = cx
			p.cz = cz
			let minChunkX = cx - renderDistance
			let maxChunkX = cx + renderDistance
			let minChunkZ = cz - renderDistance
			let maxChunkZ = cz + renderDistance

			this.offsetX = -minChunkX
			this.offsetZ = -minChunkZ
			this.lwidth = renderDistance * 2 + 1
			this.chunkGenQueue.length = 0
			this.lightingQueue.length = 0
			this.populateQueue.length = 0
			this.generateQueue.length = 0

			if (this.loaded.length > this.lwidth * this.lwidth) {
				this.loaded.length = this.lwidth * this.lwidth
			}

			let i = 0
			for (let x = minChunkX; x <= maxChunkX; x++) {
				for (let z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk
					if (!this.chunks[x]) {
						this.chunks[x] = []
					}
					if (!this.chunks[x][z]) {
						chunk = new Chunk(x * 16, z * 16,this.type,this)
						if (maxDist(cx, cz, x, z) <= settings.renderDistance) {
							this.chunkGenQueue.push(chunk)
						}
						this.chunks[x][z] = chunk
					}
					chunk = this.chunks[x][z]
					if (!chunk.buffer && !this.chunkGenQueue.includes(chunk) && maxDist(cx, cz, x, z) <= settings.renderDistance) {
						this.chunkGenQueue.push(chunk)
					}
					this.loaded[i++] = chunk
				}
			}
      this.sortedChunks.length = 0
			this.doubleRenderChunks.length = 0
			for (let chunk of this.loaded) {
				if (renderFilter(chunk)) {
					this.sortedChunks.push(chunk)
				}
				if (chunk.doubleRender) {
					this.doubleRenderChunks.push(chunk)
				}
			}
			this.sortedChunks = this.loaded.filter(renderFilter)
			this.sortedChunks.sort(sortChunks)
		}
    getTop(x,z){
      let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
        return this.chunks[x >> 4][z >> 4].tops[(z&15) * 16 + (x&15)]
			}
    }
    getThisSaveString(){
      let world = this
      
      let edited = []
			for (let x in this.chunks) {
				for (let z in this.chunks[x]) {
					let chunk = this.chunks[x][z]
					if (chunk.edited) {
						for (let y = 0; y < chunk.sections.length; y++) {
							if (chunk.sections[y].edited) {
								edited.push([ chunk.sections[y], chunk.cleanSections[y] ])
							}
						}
					}
				}
			}

			let pallete = {}
			for (let chunks of edited) {
				let changes = false
				chunks[0].blocks.forEach((id, i) => {
					if (id !== chunks[1][i]) {
						pallete[id] = true
						changes = true
					}
				})
				if (!changes) {
					chunks[0].edited = false
				}
			}

			let blocks = Object.keys(pallete).map(n => Number(n))
			pallete = {}
			blocks.forEach((block, index) => pallete[block] = index)

			let rnd = round
			let options = p.flying | (superflat==="island" ? 2 : superflat) << 1 | p.spectator << 3 | caves << 4 | trees << 5 | survival << 6

			let str = world.name + ";" + worldSeed.toString(36) + ";"
				+ rnd(p.x).toString(36) + "," + rnd(p.y).toString(36) + "," + rnd(p.z).toString(36) + ","
				+ (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + "," + options.toString(36) + ";"
				+ (this.version || version) + ";"
				+ blocks.map(b => b.toString(36)).join(",") + ";"

			for (let i = 0; i < edited.length; i++) {
				if (!edited[i][0].edited) {
					continue
				}
				let real = edited[i][0]
				let blocks = real.blocks
				let original = edited[i][1]
				str += (real.x / 16).toString(36) + "," + (real.y / 16).toString(36) + "," + (real.z / 16).toString(36) + ","
				for (let j = 0; j < original.length; j++) {
					if (blocks[j] !== original[j]) {
						str += (pallete[blocks[j]] << 12 | j).toString(36) + ","
					}
				}
				str = str.substr(0, str.length - 1); //Remove trailing comma
				str += ";"
			}
			if (str.match(/;$/)) str = str.substr(0, str.length - 1)
      
			return str
    }
		getSaveString() {
      let world = this
      if(this.type !== "") world = dimensions.overworld //save overworld
      
      if(!world.edited && world.saveStr) return world.saveStr
			return world.getThisSaveString()
		}
    getNetherSaveString(){
      let world = this
      if(this.type !== "nether") world = dimensions.nether //save nether
      
      if(!world.edited && world.saveStr) return world.saveStr
			return world.getThisSaveString()
    }
    getInv(){
      let str = ""
      let arr = []
      for(let i=0; i<inventory.hotbar.length; i++){
        if(inventory.hotbar[i]){
          arr.push(inventory.hotbar[i].id)
          arr.push(inventory.hotbar[i].amount)
        }else{
          arr.push(0)
          arr.push(0)
        }
      }
      str += arr.join(",") + "|"
      arr = []
      for(i=0; i<invItems.length; i++){
        if(invItems[i]){
          arr.push(invItems[i].id)
          arr.push(invItems[i].amount)
        }else{
          arr.push(0)
          arr.push(0)
        }
      }
      str += arr.join(",") + "|"
      arr = []
      for(let i=0; i<inventory.hotbar.length; i++){
        if(inventory.hotbar[i]){
          arr.push(inventory.hotbar[i].durability || 0)
        }else{
          arr.push(0)
        }
      }
      str += arr.join(",") + "|"
      arr = []
      for(i=0; i<invItems.length; i++){
        if(invItems[i]){
          arr.push(invItems[i].durability || 0)
        }else{
          arr.push(0)
        }
      }
      return str
    }
    getSurvivStr(){
      //survival stuff like player health
      let str = ""
      str += p.health + ","
      str += witherEffect + ","
      str += witherTime + ","
      str += witherDamage + ","
      str += world.spawnPoint.x + "," + world.spawnPoint.y + "," + world.spawnPoint.z + ","
      str += p.food + "," + p.foodSaturation + "," + p.foodExhaustion + ","
      str += p.oxygen + ","
      str += worldTime + ","
      str += (cheats ? "1" : "0")+","
      str += freezeEffect
      return str
    }
		loadSave(str) {
      this.saveStr = str
      
			let data = str.split(";")
			if (!str.includes("Alpha")) {
				return this.loadOldSave(str)
			}

			this.name = data.shift()
			setSeed(parseInt(data.shift(), 36))

			let playerData = data.shift().split(",")
      if(this.type === ""){
        p.x = parseInt(playerData[0], 36)
        p.y = parseInt(playerData[1], 36)
        p.z = parseInt(playerData[2], 36)
        p.rx = parseInt(playerData[3], 36) / 100
        p.ry = parseInt(playerData[4], 36) / 100
      }
			let options = parseInt(playerData[5], 36)
      let v = data[0].replace("Alpha ","")
      if(this.type === ""){
        let extra = verMoreThan(v, "1.0.3") || v === "1.0.3"
        p.flying = options & 1
        p.spectator = options >> 2 & 1
        superflat = options >> 1 & 3
        if(superflat === 0){superflat = false}
        if(superflat === 1){superflat = true}
        if(superflat === 2){superflat = "island"}
        caves = options >> (3+extra) & 1
        trees = options >> (4+extra) & 1
        survival = (options >> (5+extra) & 1) ? true : false
      }

			let version = data.shift()
			this.version = version

			// if (version.split(" ")[1].split(".").join("") < 70) {
			// 	alert("This save code is for an older version. 0.7.0 or later is needed")
			// }

			let pallete = data.shift().split(",").map(n => parseInt(n, 36))
			this.loadFrom = []

			for (let i = 0; data.length; i++) {
				let blocks = data.shift().split(",")
				this.loadFrom.push({
					x: parseInt(blocks.shift(), 36),
					y: parseInt(blocks.shift(), 36),
					z: parseInt(blocks.shift(), 36),
					blocks: [],
				})
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36)
					let index = block & 0xffffff
					let pid = block >> 12
					this.loadFrom[i].blocks[index] = pallete[pid]
				}
			}
		}
    loadInv(str){
      let arr = str.split("|")
      let inv = arr[1].split(",")
      let hotb = arr[0].split(",")
      
      let len = inventory.hotbar.length
      inventory.hotbar = []
      for(let i=0; i<len*2; i+=2){
        if(hotb[i]){
          inventory.hotbar.push({
            id: parseInt(hotb[i]),
            amount: parseInt(hotb[i+1])
          })
        }else inventory.hotbar.push(0)
      }
      invItems = []
      for(let i=0; i<inv.length; i+=2){
        invItems.push({
          id: parseInt(inv[i]),
          amount: parseInt(inv[i+1])
        })
      }
      try{
        inv = arr[3].split(",")
        hotb = arr[2].split(",")
        for(let i=0; i<len*2; i++){
          hotb[i] = parseInt(hotb[i]) || 0
          if(hotb[i]){
            inventory.hotbar[i].durability = hotb[i]
          }
        }
        for(let i=0; i<inv.length; i++){
          inv[i] = parseInt(inv[i]) || 0
          if(inv[i]){
            invItems[i].durability = inv[i]
          }
        }
      }catch{}
    }
    loadSurvivStr(str){
      let arr = str.split(",")
      p.health = parseInt(arr[0])
      witherEffect = parseInt(arr[1])
      witherTime = parseInt(arr[2])
      witherDamage = parseInt(arr[3])
      world.spawnPoint.x = parseInt(arr[4]) || 0
      world.spawnPoint.y = parseInt(arr[5]) || 0
      world.spawnPoint.z = parseInt(arr[6]) || 0
      p.food = parseInt(arr[7]); if(isNaN(p.food)) p.food = 20
      p.foodSaturation = parseFloat(arr[8]) || 0, p.foodExhaustion = parseFloat(arr[9]) || 0
      p.oxygen = parseInt(arr[10]); if(!p.oxygen) p.oxygen = 20
      worldTime = parseFloat(arr[11]) || 0
      cheats = arr[12] ? arr[12] === "1" : !survival
      freezeEffect = parseInt(arr[13])
    }
		loadOldSave(str) {
			let data = str.split(";");
			setSeed(parseInt(data.shift(), 36))
			this.id = Date.now()
			this.name = "Old World " + (Math.random() * 1000 | 0)
			let playerData = data.shift().split(",");
			p.x = parseInt(playerData[0], 36);
			p.y = parseInt(playerData[1], 36);
			p.z = parseInt(playerData[2], 36);
			p.rx = parseInt(playerData[3], 36) / 100;
			p.ry = parseInt(playerData[4], 36) / 100;
			let editCount = parseInt(data.shift(), 36);

			this.loadFrom = [];

			let coords = data.shift().split(",").map(function(n) {
				return parseInt(n, 36);
			});
			for (let j = 0; j < coords.length; j += 3) {
				this.loadFrom.push({
					x: coords[j],
					y: coords[j + 1],
					z: coords[j + 2],
					blocks: [],
				})
			}

			for (let i = 0; data.length > 0; i++) {
				let blocks = data.shift().split(",");
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36);
					let index = block >> 8;
					let id = block & 0x7f | (block & 0x80) << 1;
					this.loadFrom[i].blocks[index] = id;
				}
			}
		}
	}
  win.World = World

	// Mouse sensitivity variable, used for the settings buttons and in the "mmoved" function
	let mouseS = 300

	class Slider {
		constructor(x, y, w, h, scenes, label, min, max, settingName, callback) {
			this.x = x
			this.y = y
			this.h = h
			this.w = Math.max(w, 350)
			this.name = settingName
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.label = label
			this.min = min
			this.max = max
			this.sliding = false
			this.callback = callback
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let current = (settings[this.name] - this.min) / (this.max - this.min)

			// Outline
			ctx.beginPath()
			strokeWeight(2)
			stroke(0)
			fill(85)
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			ctx.stroke()
			ctx.fill()

			// Slider bar
			let value = round(settings[this.name])
			ctx.beginPath()
			fill(130)
			let x = this.x - (this.w - 10) / 2 + (this.w - 10) * current - 5
			ctx.fillRect(x, this.y - this.h / 2, 10, this.h)

			//Label
			fill(255, 255, 255)
			textSize(13)
			ctx.textAlign = 'center'
			text(`${this.label}: ${value}`, this.x, this.y + this.h / 8)
		}
		click() {
			if (!mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2) {
				let current = (mouseX - this.x + this.w / 2) / this.w
				if (current < 0) current = 0
				if (current > 1) current = 1
				this.sliding = true
				settings[this.name] = current * (this.max - this.min) + this.min
				this.callback(current * (this.max - this.min) + this.min)
				this.draw()
			}
		}
		drag() {
			if (!this.sliding || !this.scenes.includes(screen)) {
				return false
			}

			let current = (mouseX - this.x + this.w / 2) / this.w
			if (current < 0) current = 0
			if (current > 1) current = 1
			settings[this.name] = current * (this.max - this.min) + this.min
			this.callback(current * (this.max - this.min) + this.min)
		}
		release() {
			this.sliding = false
		}

		static draw() {
			for (let slider of Slider.all) {
				slider.draw()
			}
		}
		static click() {
			for (let slider of Slider.all) {
				slider.click()
			}
		}
		static release() {
			for (let slider of Slider.all) {
				slider.release()
			}
		}
		static drag() {
			if (mouseDown) {
				for (let slider of Slider.all) {
					slider.drag()
				}
			}
		}
		static add(x, y, w, h, scenes, label, min, max, defaut, callback) {
			Slider.all.push(new Slider(x, y, w, h, scenes, label, min, max, defaut, callback))
		}
	}
	Slider.all = []
	class Button {
		constructor(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			this.x = x
			this.y = y
			this.h = h
			this.w = w
			this.index = 0
			this.disabled = disabled || (() => false)
			this.hoverText = !hoverText || typeof hoverText === "string" ? (() => hoverText) : hoverText
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.labels = Array.isArray(labels) ? labels : [labels]
			this.callback = callback
		}

		mouseIsOver() {
			return mouseX >= this.x - this.w / 2 && mouseX <= this.x + this.w / 2 && mouseY >= this.y - this.h / 2 && mouseY <= this.y + this.h / 2
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let hovering = this.mouseIsOver()
			let disabled = this.disabled()
			let hoverText = this.hoverText()

			// Outline
			ctx.beginPath()
			
			strokeWeight(6)
      stroke(80)
			if (disabled) {
				fill(60)
				stroke(20)
			} else {
				if (hovering) {
    				cursor(HAND)
    				fill(100, 120, 200)
    				stroke(100,80,160)
    		}else{
    		    fill(120)
    		}
			}
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			
			ctx.stroke()
			ctx.fill()
			
			ctx.beginPath()
			stroke(200)
			if (hovering && !disabled)stroke(200, 200, 255);
			if(disabled)stroke(130);
			strokeWeight(3.5)
			if(disabled){
			    ctx.moveTo(this.x + (this.w / 2) + 2, this.y - this.h / 2-2)
    			ctx.lineTo(this.x + (this.w / 2) + 2, this.y + (this.h / 2)+1)
    			ctx.lineTo(this.x - this.w / 2 - 1, this.y + (this.h / 2)+1)
			}else{
    			ctx.moveTo(this.x - this.w / 2 - 2, this.y + (this.h / 2)-2)
    			ctx.lineTo(this.x - this.w / 2 - 2, this.y - this.h / 2-2)
    			ctx.lineTo(this.x + (this.w / 2)+1, this.y - this.h / 2-2)
			}
			ctx.stroke()

            stroke(0)
            strokeWeight(1)
            ctx.strokeRect(this.x-this.w/2-4, this.y-this.h/2-4, this.w+8, this.h+8)

			//Label
			textSize(13)
			ctx.textAlign = 'center'
			fill(0)
			text(this.labels[this.index], this.x +2, this.y + this.h / 8 +2)
			disabled ? fill(255) : (hovering ? fill(255,255,0) : fill(255) )
			text(this.labels[this.index], this.x, this.y + this.h / 8)
			
			if (hovering && hoverText) {
				hoverbox.innerText = hoverText
				hoverbox.classList.remove("hidden")
				if (mouseY < height / 2) {
					hoverbox.style.bottom = ""
					hoverbox.style.top = mouseY + 10 + "px"
				} else {
					hoverbox.style.top = ""
					hoverbox.style.bottom = height - mouseY + 10 + "px"
				}
				if (mouseX < width / 2) {
					hoverbox.style.right = ""
					hoverbox.style.left = mouseX + 10 + "px"
				} else {
					hoverbox.style.left = ""
					hoverbox.style.right = width - mouseX + 10 + "px"
				}
			}
		}
		click() {
			if (this.disabled() || !mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (this.mouseIsOver()) {
				this.index = (this.index + 1) % this.labels.length
				this.callback(this.labels[this.index])
				return true
			}
		}

		static draw() {
			hoverbox.classList.add("hidden")
			for (let button of Button.all) {
				button.draw()
			}
		}
		static click() {
			for (let button of Button.all) {
				if (button.click()) {
					Button.draw()
          playSound("click")
					break
				}
			}
		}
		static add(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			Button.all.push(new Button(x, y, w, h, labels, scenes, callback, disabled, hoverText))
		}
	}
	Button.all = []

	var initEverything
	function initButtons() {
		Button.all = []
		Slider.all = []
		const nothing = () => false
		const always = () => true

		// Main menu buttons
		Button.add(width / 2, height / 2 - 40, 400, 40, "Singleplayer", "main menu", r => changeScene("loadsave menu"))
		Button.add(width / 2, height / 2 + 15, 400, 40, "Multiplayer", "main menu", r => {
      changeScene("multiplayer menu")
    }, null, "If you want multiplayer, why don't you head over to willard.fun/minekhan?")
    Button.add(width / 2, height / 2 + 70, 400, 40, "Marketplace", "main menu", r => changeScene("marketplace"))
		Button.add(width / 2 - 105, height / 2 + 160, 190, 40, "Options", "main menu", r => changeScene("options"))
    Button.add(width / 2 + 105, height / 2 + 160, 190, 40, "Quit", "main menu", r => {
      if(window.opener !== null || window.history.length === 1){
        close()
      }else{
        location.href = "https://thingmaker.us.eu.org"
      }
    })
    Button.add(width / 2 - 235, height / 2 + 160, 40, 40, "?", "main menu", r => changeScene("help"))

		// Creation menu buttons
		Button.add(width / 2, 135, 300, 40, ["World Type: Normal", "World Type: Superflat", "World Type: Island"], "creation menu", r => {superflat = r === "World Type: Superflat"; if(r==="World Type: Island")superflat="island"})
		Button.add(width / 2, 185, 300, 40, ["Trees: On", "Trees: Off"], "creation menu", r => trees = r === "Trees: On", function() {
			if (superflat === true) {
				this.index = 1
				trees = false
			}
			return superflat === true
		})
		Button.add(width / 2, 235, 300, 40, ["Caves: On", "Caves: Off"], "creation menu", r => caves = r === "Caves: On", function() {
			if (superflat === true) {
				this.index = 1
				caves = false
			}
			return superflat === true
		})
		Button.add(width / 2, 285, 300, 40, ["Game Mode: Creative", "Game Mode: Survival"], "creation menu", r => survival = r === "Game Mode: Survival")
		Button.add(width / 2, 335, 300, 40, "Difficulty: Peaceful", "creation menu", nothing, always, "Coming soon\n\nPlease stop asking for mobs. Adding them will take a very long time. I know a lot of people want them, so just be patient.")
		Button.add(width / 2, height - 90, 300, 40, "Create New World", "creation menu", r => {
      dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			world.id = Date.now()
			let name = boxCenterTop.value || "World"
			let number = ""
			while(true) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				} else {
					name = name + number
					break
				}
			}
			world.name = name.replace(/;/g, "\u037e")
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)
      cheats = !survival

      if(survival) setHotbar([0,0,0,0,0,0,0,0,0])
			changeScene("loading")
		})
		Button.add(width / 2, height - 40, 300, 40, "Cancel", "creation menu", r => changeScene(previousScreen))

		// Loadsave menu buttons
		const selected = () => !selectedWorld || !worlds[selectedWorld]
		let w4 = min(width / 4 - 10, 220)
		let x4 = w4 / 2 + 5
		let w2 = min(width / 2 - 10, 450)
		let x2 = w2 / 2 + 5
		let mid = width / 2
		Button.add(mid - 3 * x4, height - 30, w4, 40, "Edit", "loadsave menu", r => changeScene("editworld"), () => (selected() || !worlds[selectedWorld].edited))
		Button.add(mid - x4, height - 30, w4, 40, "Delete", "loadsave menu", r => {
			if (worlds[selectedWorld] && confirm(`Are you sure you want to delete ${worlds[selectedWorld].name}?`)) {
				deleteFromDB(selectedWorld)
				window.worlds.removeChild(document.getElementById(selectedWorld))
				delete worlds[selectedWorld]
				selectedWorld = 0
			}
		}, () => (selected() || !worlds[selectedWorld].edited), "Delete the world forever.")
		Button.add(mid + x4, height - 30, w4, 40, "Export", "loadsave menu", r => {
			boxCenterTop.value = worlds[selectedWorld].code
		}, selected, "Export the save code into the text box above for copy/paste.")
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "loadsave menu", r => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "loadsave menu", r => {
      var ver
      if(worlds[selectedWorld]){
        ver = worlds[selectedWorld].version.replace("Alpha ","")
      }else{
        ver = boxCenterTop.value.split(";")[3].replace("Aplha ","")
      }
      if(!verMoreThan(ver, "1.0.2")){
        changeScene("broken world")
        return
      }
      
			playSelectedWorld()
		}, () => !(!selectedWorld && boxCenterTop.value) && !worlds[selectedWorld])
		Button.add(mid + x2, height - 75, w2, 40, "Create New World", "loadsave menu", r => changeScene("creation menu"))
    
    //broken world buttons
    Button.add(mid, height / 2 + 50, w2, 40, "Cancel", "broken world", r => {changeScene("loadsave menu")})
    Button.add(mid, height / 2 + 105, w2, 40, "Load anyways", "broken world", r => {
      try{
        playSelectedWorld()
      }catch(e){
        alert(e)
      }
    })

    // Edit world menu
		Button.add(mid, height / 2, w2, 40, "Save", "editworld", r => {
			let w = worlds[selectedWorld]
			w.name = boxCenterTop.value.replace(/;/g, "\u037e")
			let split = w.code.split(";")
			split[0] = w.name
			w.code = split.join(";")
      w.thumbnail = window.url.value
      saveToDB(w.id, w).then(success => {
				initWorldsMenu()
				changeScene("loadsave menu")
			}).catch(e => console.error(e))
		})
		Button.add(mid, height / 2 + 50, w2, 40, "Back", "editworld", r => changeScene(previousScreen))
    
    // Multiplayer buttons
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "multiplayer menu", r => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "multiplayer menu", async() => {
      changeScene("multiplayer connecting")
      initMultiplayer(servers[selectedWorld].id)
      multiplayer.addEventListener("close", function(){
        changeScene("multiplayer menu")
      })
    }, () => !servers[selectedWorld])
    
    //multiplayer connecting buttons
    Button.add(mid, height / 2 + 40, w2, 40, "Cancel", "multiplayer connecting", r => {multiplayer.close();changeScene("multiplayer menu")})

    //play buttons
    if(touchScreen){
      Button.add(mid-14, 14, 20,20, "/", "play", Messages.showInput)
      Button.add(mid+14, 14, 20,20, "", "play", r => changeScene("pause"))
    }

		// Pause buttons
		Button.add(width / 2, 225, 300, 40, "Resume", "pause", play)
		Button.add(width / 2, 275, 300, 40, "Options", "pause", r => changeScene("options"))
		Button.add(width / 2, 325, 300, 40, "Save", "pause", save, nothing, () => `Save the world to your computer/browser. Doesn't work in incognito.\n\nLast saved ${timeString(Date.now() - world.edited)}.`)
		Button.add(width / 2, 375, 300, 40, "Get Save Code", "pause", r => {
			savebox.classList.remove("hidden")
			saveDirections.classList.remove("hidden")
			savebox.value = world.getSaveString()
		})
		Button.add(width / 2, 425, 300, 40, "Exit Without Saving", "pause", r => {
			savebox.value = world.getSaveString()
			initWorldsMenu()
      if(multiplayer) multiplayer.close()
			changeScene("main menu")
		})
    Button.add(width / 2, 475, 300, 40, "Enable multiplayer", "pause", async r => {
      var logged
      await loggedIn().then(r => logged = r)
      if(logged){
			  initMultiplayer()
      }
		}, () => multiplayer)
    
    // You Died buttons
    Button.add(width / 2, 225, 300, 40, "Respawn", "dead", r => {
      respawn()
      updateHUD = true
      play()
    })
		
		// Options buttons
		Button.add(width / 2, 430, width / 3, 40, ["Reach distance: "+normReach, "Reach distance: "+bigReach], "options", r => {
      if(r === "Reach distance: "+normReach){
        reach = normReach
      }else reach = bigReach
    })
    Button.add(width / 2, 500, width / 3, 40, ["Sound: On", "Sound: Off"], "options", r => soundOn = r === "Sound: On")
    Button.add(width / 2, 570/*640*/, width / 3, 40, "Back", "options", r => changeScene(previousScreen))
    
    //Help buttons
    Button.add(60, 30, 80, 30, "Back", "help", r => changeScene(previousScreen))
    
    // Marketplace buttons
    Button.add(60, 40, 80, 30, "Back", "marketplace", r => changeScene(previousScreen))
		Button.add(mid - x2, height - 75, w2, 40, "Download", "marketplace", saveFromMarketplace, () => !marketplace[selectedWorld])
    
		// Comingsoon menu buttons
		Button.add(width / 2, 395, width / 3, 40, "Back", "comingsoon menu", r => changeScene(previousScreen))

		// Settings Sliders
		Slider.add(width/2, 245, width / 3, 40, "options", "Render Distance", 1, 32, "renderDistance", val => settings.renderDistance = round(val))
		Slider.add(width/2, 305, width / 3, 40, "options", "FOV", 30, 110, "fov", val => {
			p.FOV(val)
			if (world) {
				p.setDirection()
				world.render()
			}
		})
		Slider.add(width/2, 365, width / 3, 40, "options", "Mouse Sensitivity", 30, 400, "mouseSense", val => settings.mouseSense = val)
	}
	function initTextures() {
		let textureSize = 256
    let textureH = 1024
		let scale = 1 / (textureSize/16)
    let scaleH = 1 / (textureSize/16)
		let texturePixels = new Uint8Array(textureSize * textureH * 4)
		textureMap = {}
		textureCoords = []

		setPixel = function(textureNum, x, y, r, g, b, a) {
			let texX = textureNum & 15
			let texY = textureNum >> 4
			let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4
			texturePixels[offset] = r
			texturePixels[offset + 1] = g
			texturePixels[offset + 2] = b
			texturePixels[offset + 3] = a !== undefined ? a : 255
		}
		getPixels = function(str) {
			// var w = parseInt(str.substr(0, 2), 36)
			// var h = parseInt(str.substr(2, 2), 36)
			var colors = []
			var pixels = []
			var dCount = 0
			for (;str[4 + dCount] === "0"; dCount++) {}
			var ccount = parseInt(str.substr(4+dCount, dCount+1), 36)
			for (var i = 0; i < ccount; i++) {
				var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36)
				colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ])
			}
			for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
				let num = parseInt(str[i], 36)
				pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3])
			}
			return pixels
		};
    
    textureUpdated()

		{
      //get amount of textures
      var t = 0
      for(var i in textures) t++
      t = Math.ceil(t / 16) * 16
      
			// Specify the texture coords for each index
			const s = scale, sh = scaleH
			for (let i = 0; i < t; i++) {
				let texX = i & 15
				let texY = i >> 4
				let offsetX = texX * s
				let offsetY = texY * sh
				textureCoords.push(new Float32Array([ offsetX, offsetY, offsetX + s, offsetY, offsetX + s, offsetY + sh, offsetX, offsetY + sh ]))
			}

			// Set all of the textures into 1 big tiled texture
			let n = 0
			for (let i in textures) {
				if (typeof textures[i] === "function") {
					textures[i](n)
				} else if (typeof textures[i] === "string") {
					let pix = getPixels(textures[i])
          let semiTrans
					for (let j = 0; j < pix.length; j += 4) {
						setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3])
            let a = pix[j+3]
            if(a !== 0 && a !== 255){
              semiTrans = true
            }
					}
          if(semiTrans)semiTransTextures.push(i)
				}
				textureMap[i] = n
				n++
			}

			//Set the hitbox texture to 1 pixel
			let arr = new Float32Array(192)
			for (let i = 0; i < 192; i += 2) {
				arr[i] = textureCoords[textureMap.hitbox][0] + 0.01
				arr[i + 1] = textureCoords[textureMap.hitbox][1] + 0.01
			}
			textureCoords[textureMap.hitbox] = arr
		}

		// Big texture with everything in it
		textureAtlas = gl.createTexture()
		gl.activeTexture(gl.TEXTURE0)
		gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureH, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		gl.uniform1i(glCache.uSampler, 0)

		// Dirt texture for the background
		let dirtPixels = new Uint8Array(getPixels(textures.dirt))
		dirtTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE1)
		gl.bindTexture(gl.TEXTURE_2D, dirtTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, dirtPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    // Netherrack texture for the background
		let netherPixels = new Uint8Array(getPixels(textures.netherrack))
		netherTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE2)
		gl.bindTexture(gl.TEXTURE_2D, netherTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, netherPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    let explodePixels = new Uint8Array([255,0,0,1])
    explodeTexture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE3)
		gl.bindTexture(gl.TEXTURE_2D, explodeTexture)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, explodePixels)
		images.explode.addEventListener("load", function(){
      gl.activeTexture(gl.TEXTURE3)
      gl.bindTexture(gl.TEXTURE_2D, explodeTexture)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.explode)
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    })
    
    let panoramaPixels = new Uint8Array([255,0,0,1])
    panoramaTexture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE4)
		gl.bindTexture(gl.TEXTURE_2D, panoramaTexture)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, panoramaPixels)
		images.panorama.addEventListener("load", function(){
      gl.activeTexture(gl.TEXTURE4)
      gl.bindTexture(gl.TEXTURE_2D, panoramaTexture)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.panorama)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
      gl.useProgram(programPanorama)
      gl.uniform1f(glCache.textureWPanorama, images.panorama.width)
      gl.uniform1f(glCache.textureHPanorama, images.panorama.height)
      mainBGW = images.panorama.width
    })

		genIcons()
	}
	function drawIcon(x, y, id, obj) {
		id = id < isCube ? (id | blockMode) : id
		let X =  x / (3 * height) - 0.1666 * width / height
		let Y = y / (3 * height) - 0.1666
    let scale = 1
    if(obj && obj.animation){
      scale = obj.animation
    }
    let semiTrans
    if(blockData[id].semiTrans) semiTrans = true
    
		initModelView(null, X, Y, 0, 0, 0, scale)

		let buffer = blockIcons[id]
    let length = blockIcons.lengths[id]
    if(!blockIcons[id]){
      buffer = blockIconError
      length = blockIconError.length
    }
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
		gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 24, 0)
		gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 24, 12)
		gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 24, 20)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
		gl.drawElements(gl.TRIANGLES, length, gl.UNSIGNED_INT, 0)
    if(semiTrans){
      gl.uniform1i(glCache.uTrans, 1)
      gl.drawElements(gl.TRIANGLES, length, gl.UNSIGNED_INT, 0)
      gl.uniform1i(glCache.uTrans, 0)
    }
    
    if(!obj) return
    
    let s = inventory.size
    let s2 = s/2
    let ts = inventory.ts
    if(obj.durability){
      let percent = obj.durability / blockData[id].durability
      if(percent !== 1){
        let ww = (s-(ts*2))
        let w = ww*percent
        let color = percent > 0.6666 ? "#af5" : (percent > 0.3333 ? "#fa0" : "#f55")
        let dx = x-s2+ts
        let dy = y+s2-(ts*3)
        let prevFill = ctx2.fillStyle
        ctx2.fillStyle = "#333"
        ctx2.fillRect(dx,dy,ww,ts*2)
        ctx2.fillStyle = color
        ctx2.fillRect(dx,dy,w,ts)
        ctx2.fillStyle = prevFill
      }
    }
	}

	function hotbar() {
		FOV(90)
    let s = inventory.size
    let s2 = s/2

    ctx2.fillStyle = "white"
    ctx2.font = "14px VT323"
    ctx2.textAlign = "right"
		for(let i = 0; i < inventory.hotbar.length; i ++) {
      let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  let y = height - inventory.size
			if(inventory.hotbar[i].id) {
				drawIcon(x, y, inventory.hotbar[i].id, inventory.hotbar[i])
        if(survival && inventory.hotbar[i].amount>1) ctx2.fillText(inventory.hotbar[i].amount, x+(s/2), y+(s/2))
			}
		}
    if(touchScreen && screen === "play"){
      i++
      let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
      let y = height - inventory.size
      ctx.fillStyle = "#0a0"
      ctx.fillRect(x-s2, y-s2, s,s)
      ctx.textAlign = "center"
      var prev = ctx.textBaseline
      ctx.textBaseline = "middle";
      ctx.fillStyle = "white"
      ctx.fillText("...",x,y)
      ctx.textBaseline = prev;
    }
	}
	function hud() {
		if (p.spectator) {
			return
		}

		hotbar()

		let s = inventory.size
    let s2 = s / 2
		let x = width / 2 + 0.5
		let y = height / 2 + 0.5
    let maxX = width / 2 - inventory.hotbar.length / 2 * s + 9.5 * s + 25
    
    textSize(10)

		// Crosshair
		if (!p.spectator) {
			ctx.lineWidth = 1
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.moveTo(x - 10, y)
			ctx.lineTo(x + 10, y)
			ctx.moveTo(x, y - 10)
			ctx.lineTo(x, y + 10)
			ctx.stroke()
		}
    
    //Attack indicator
    if(attackCooldown > 0){
      var c = attackCooldown * 16
      ctx.drawImage(images.attackIndicatorCrosshair, 0,0,16,4, x-16,y+10,32,8)
      ctx.drawImage(images.attackIndicatorCrosshair, 16,0,c,4, x-16,y+10,c*2,8)
    }

		//Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5

		ctx.strokeStyle = "black"
		ctx.lineWidth = 2
		ctx.beginPath()
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= 9; i++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		ctx.strokeStyle = "white"
		ctx.lineWidth = 2
		ctx.beginPath()

		ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s)

    if(survival){
      var iw = 18
      var pw = 2 //pixel width
      var pw2 = pw/2
      var iw2 = iw/2
      var dw = iw2 - pw2
      var iy = y-iw-4
      var ih = iw+2
      //Health bar
      var outline = (healEffect < 40 && healEffect > 30) || (healEffect < 20 && healEffect > 10)
      if((loseHealthEffect < 60 && loseHealthEffect > 50) || (loseHealthEffect < 40 && loseHealthEffect > 30) || (loseHealthEffect < 20 && loseHealthEffect > 10)) outline = true
      var heartNum = Math.floor(p.health)
      let wither = witherEffect > 0
      let i
      for(i=0; i<heartNum; i+=2){
        var heartX = (i * dw) + x;
        var offY = p.health < 5 ? (round(Math.random())*2)-1 : 0
        if(heartNum === i+1){
          ctx.drawImage(images[wither ? "witherHalfHeart": (freezeEffect === 140 ? "freezeHalfHeart" : "halfHeart")], heartX, iy+offY, iw, iw);
        }else{
          ctx.drawImage(images[wither ? "witherHeart" : (freezeEffect === 140 ? "freezeHeart" : "heart")], heartX, iy+offY, iw, iw);
        }
        if(outline){
          ctx.drawImage(images.whiteHeart, heartX, iy, iw, iw);
        }
      }
      for(; i<20; i+=2){
        var heartX = (i * dw) + x;
        var offY = p.health < 5 ? (round(Math.random())*2)-1 : 0
        ctx.drawImage(images.deadHeart, heartX, iy+offY, iw, iw);
        if(outline){
          ctx.drawImage(images.whiteHeart, heartX, iy+offY, iw, iw);
        }
      }
      //Hunger bar
      for(i=0; i<p.food; i+=2){
        var offY = (p.foodJitter === 0)? round(Math.random())*2 : 0
        var X = maxX - ((i+4) * iw2)
        if(p.food === i+1){
          ctx.drawImage(images.halfDrumstick, X, iy+offY, iw, iw);
        }else{
          ctx.drawImage(images.drumstick, X, iy+offY, iw, iw);
        }
      }
      for(; i<20; i+=2){
        var offY = (p.foodJitter === 0)? round(Math.random())*2 : 0
        var X = maxX - ((i+4) * iw2)
        ctx.drawImage(images.drumstickBG, X, iy+offY, iw, iw);
      }
      //Oxygen bar
      if(p.oxygen !== 20){
        for(i=0; i<p.oxygen; i+=2){
          var bubbleX = (maxX - (iw*11)) + (i * iw2)
          if(p.oxygen === i+1){
            ctx.drawImage(images.bubblePop, bubbleX, iy-ih, iw, iw);
          }else{
            ctx.drawImage(images.bubble, bubbleX, iy-ih, iw, iw);
          }
        }
      }
    }
    
    if(freezeEffect > 0){
      var opacity = freezeEffect / 140
      ctx.globalAlpha = opacity
      ctx.drawImage(images.freezeEffect,0,0,width,height)
      ctx.globalAlpha = 1
    }
    
    if(inventory.showName > 0){
      ctx.globalAlpha = inventory.showName > 1 ? 1 : inventory.showName
      var Y = y - (s*1.5)
      ctx.font = "18px VT323"
      var slot = inventory.hotbar[inventory.hotbarSlot]
      var name = slot && slot.id && blockData[slot.id].name
      if(name){
        var w = ctx.measureText(name).width + 20
        var X = (width / 2) - (w/2)
        fill(0)
        ctx.fillRect(X,Y,w,s)
        fill(255)
        ctx.textBaseline = "Middle"
        ctx.fillText(name, X+10,Y+s2)
        ctx.textBaseline = "Alphabetic"
      }
      ctx.globalAlpha = 1
    }
    
    ctx.fillStyle = "white"
    ctx.font = "10px VT323"
    
		let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
		+ "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
		+ "Render Time: " + analytics.displayedRenderTime + "ms\n"
		+ "Tick Time: " + analytics.displayedTickTime + "ms\n"
		+ "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
		+ "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
		+ "FPS: " + analytics.fps//*temp*/ + "   atk-cdn_"+attackCooldown+",start_"+attackCooldownStart+",time_"+attackCooldownTime

		if (p.autoBreak) {
			text("Super breaker enabled", 5, height - 89, 12)
		}
    if (p.autoBuild) {
			text("Hyper builder enabled", 5, height - 101, 12)
		}
    if (multiplayer) {
			let closest = Infinity
			let cname = "Yourself"
			for (let name in players) {
				let pos = players[name]
        if(pos.dimension === world.type){
          let distance = sqrt((pos.x - p2.x)*(pos.x - p2.x) + (pos.y+1 - p2.y)*(pos.y+1 - p2.y) + (pos.z - p2.z)*(pos.z - p2.z))
          if (distance < closest) {
            closest = distance
            cname = pos.username
          }
        }
			}
      if(cname === "Yourself") closest = 0
      var info = round(closest)+" blocks away"
      if(closest === 0) info = "Right here"
			text(`Closest player: ${cname} (${info})`, 5, height - 113, 12)
		}

		ctx.textAlign = 'right'
		text(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0)
		ctx.textAlign = 'left'
		text(str, 5, height - 77, 12)
    
    
	}
  window.invScroll = 0;
  let draggingInvBar = false
  let invHeight = 0
  var barW = 20
  var invBarOffset = 0
  var barH = 0
	function drawInv(nodraw) {
		let x = 0
		let y = 0
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13

		gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		ctx.fillStyle = "rgb(127, 127, 127)"
		ctx.fillRect(0, 0, canvas.width, canvas.height)
    ctx2.clearRect(0, 0, canvas.width, canvas.height)
		FOV(90)

    let count = 1;
    if(survival){
      count = invLength
    }else{
      for (let i = 1; i < BLOCK_COUNT; i++) {
        if(!blockData[i].hidden)count ++;
      }
    }
    invHeight = (Math.ceil(count / perRow) * s)
    let invWinH = s * 9;

    // Scrollbar
    if(survival){invScroll = 0}else{
      barH = height * (invWinH/invHeight);
      if(draggingInvBar){
        invScroll = map(mouseY-invBarOffset, (barH/2), height-(barH/2), 0, invHeight);
        if(invScroll > invHeight) invScroll = invHeight
        if(invScroll < 0) invScroll = 0
      }
      var barYCent = map(invScroll, 0, invHeight, (barH/2), height-(barH/2));
      var barTop = barYCent - (barH/2);
      fill(100)
      ctx.fillRect(width-barW-2, 0, barW+2, height)
      fill(200)
      ctx.fillRect(width-barW, barTop, barW-2, barH)
    }

		// Draw the grid
    ctx.translate(0, -(invScroll % s))
		ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
		for (y = 0; y < 10; y++) {
			ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s)
			ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s)
		}
		y--
		for (x = 0; x < perRow + 1; x++) {
			ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2)
			ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s)
		}
    ctx.translate(0, invScroll % s)

		// Hotbar
		x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= inventory.hotbar.length; i ++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			x += s * overHot
			ctx.lineWidth = 2
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.strokeRect(x, y, s, s)
		}
    
		//Box highlight in inv
		let overInv = Math.round(((mouseY + invScroll) - 50) / s) * perRow + Math.round((mouseX - 50) / s)
		if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow * s + 50 - s2
			y = (overInv / perRow | 0) * s + 50 - s2
      y -= invScroll
      if(mouseY < s*9.5){
        ctx.lineWidth = 2
        ctx.strokeStyle = "white"
        ctx.beginPath()
        ctx.strokeRect(x, y, s, s)
      }
		}

		if (inventory.holding && inventory.holding.id) {
			drawIcon(mouseX, mouseY, inventory.holding.id, inventory.holding)
		}
    
    if(survival){
      ctx2.fillStyle = "white"
      ctx2.font = "14px VT323"
      ctx2.textAlign = "right"
      for (let i = 0; i < invLength; i++) {
        if(invItems[i] && invItems[i].id){
          x = (i) % perRow * s + 50
          y = ((i) / perRow | 0) * s + 50
          drawIcon(x, y - invScroll, invItems[i].id, invItems[i])
          if(inventory.spreaded.length && inventory.spreaded.includes(i)){
            ctx.fillStyle = "rgb(180,180,180)"
            ctx.fillRect(x+1-s2,y+1-s2,s-2,s-2)
          }else ctx2.fillText(invItems[i].amount, x+s2, y+s2)
        }
      }
    }else{
      let invIdx = 0;
      for (let i = 1; i < BLOCK_COUNT; i++) {
        invIdx ++;
        if(blockData[i].hidden){
          while(blockData[i].hidden) i++
        }

        x = (invIdx - 1) % perRow * s + 50
        y = ((invIdx - 1) / perRow | 0) * s + 50
        y -= invScroll
        if(y < s*9.5 && y > 0){
          drawIcon(x, y, i)
        }
      }
    }
    
    if(screen === "inventory"){
      let offX = width - s*4
      let offY = s*2
      //draw grid
      ctx.lineWidth = 1
      ctx.strokeStyle = "black"
      ctx.beginPath()
      let y = s*2+offY
      let x
      for(x=0; x<3; x++){
        ctx.moveTo(x*s+offX, offY)
        ctx.lineTo(x*s+offX, y)
      }
      x = s*2+offX
      for(y=0; y<3; y++){
        ctx.moveTo(offX, y*s+offY)
        ctx.lineTo(x, y*s+offY)
      }
      ctx.stroke()

      //icons
      ctx2.font = "14px VT323"
      ctx2.textAlign = "right"
      ctx2.fillStyle = "white"
      for(y=0; y<2; y++){
        for(x=0; x<2; x++){
          let idx = (y*3) + x
          if(inventory.crafting[idx] && inventory.crafting[idx].id){
            let X = x*s+offX, Y = y*s+offY
            drawIcon(X+s2,Y+s2, inventory.crafting[idx].id, inventory.crafting[idx])
            ctx2.fillText(inventory.crafting[idx].amount, X+s, Y+s)
          }
        }
      }

      x = Math.floor((mouseX - offX) / s)
      y = Math.floor((mouseY - offY) / s)
      let over = (y * 3) + x
      if(!(x >= 0 && x < 2 && y >= 0 && y < 2)){
        over = -1
      }else if(over > -1 && over < 9){
        ctx.lineWidth = 2
        ctx.strokeStyle = "white"
        ctx.strokeRect(x*s+offX, y*s+offY, s,s)
      }

      x = offX + (s/2)
      y = offY + (s*3)
      over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
      ctx.lineWidth = over?2:1
      ctx.strokeStyle = over?"white":"black"
      ctx.strokeRect(x,y, s,s)
      if(inventory.craftingRes && inventory.craftingRes.id){
        drawIcon(x+s2, y+s2, inventory.craftingRes.id, inventory.craftingRes)
        ctx2.font = "14px VT323"
        ctx2.textAlign = "right"
        ctx2.fillStyle = "white"
        ctx2.fillText(inventory.craftingRes.amount, x+s, y+s)
      }

      ctx.drawImage(gl.canvas,0,0)

      if(inventory.craftingRes && inventory.craftingRes.id){
        let name = blockData[inventory.craftingRes.id].name
        if(name !== "" && over){
          ctx.textAlign = "left"
          ctx.font = "16px VT323";
          var w = ctx.measureText(name).width;
          fill(0)
          ctx.fillRect(mouseX, mouseY, w+20, 20);

          fill(255);
          ctx.fillText(name, mouseX+10, mouseY+13+2);
        }
      }
    }
    
		hotbar()
		//hud()
		ctx.drawImage(gl.canvas, 0, 0)
    
    // show block name on hover
    if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow
			y = (overInv / perRow | 0)
      
      var wrongidx = x+(y*perRow)+1;
      var idx=1;
      if(survival){
        idx = wrongidx - 1
      }else{
        for(var i=1; i<wrongidx; i++){
          idx++;
          if(blockData[i+1] && blockData[i+1].hidden){
            /*let i2 = idx
            while(blockData[i2] && blockData[i2].hidden){
              i2++
              idx++
            }*/
            idx++
          }
        }
      }
      let name;
      if(survival){
        let id = invItems[idx] ? invItems[idx].id : 0
        name = id ? blockData[id].name : "";
      }else{
        name = blockData[idx] ? blockData[idx].name : "";
      }
      if((name !== "") && mouseY<s*9.5){
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10, mouseY+13+2);
      }
		}
    
    //show name on hover for hotbar
    x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5
    if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
      let slot = inventory.hotbar[overHot]
      let name = slot && slot.id && blockData[slot.id].name
      name = name || ""
      if(name !== ""){
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10, mouseY+13+2);
      }
		}
    
    if(!nodraw)ctx.drawImage(canvas2, 0,0)
	}
	function clickInv(dontRedraw,mouse) {
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13
		let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
    
    if(!survival){
      var idx = 0;
      for(var i=1; i<over+1; i++){
        if(!blockData[i]) break;

        idx ++;
        if(blockData[i+1] && blockData[i+1].hidden)idx++;
      }
      over = idx;
    }
    
    let count = survival ? invLength : BLOCK_COUNT - 1
    
    //for crafting
    let offX = width - s*4
    let offY = s * 2
    let craftResX = offX+(s/2)
    let craftResY = offY+(s*3)
    
		let x = width / 2 - 9 / 2 * s + 25
		let y = height - s * 1.5
		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			let temp = inventory.hotbar[overHot]
			inventory.hotbar[overHot] = inventory.holding
			inventory.holding = temp
		} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
      if(survival){
        if(!invItems[over]) invItems[over] = {id:0,amount:0}
        if(mouse === 2 && inventory.holding.amount > 1){
          let holding = inventory.holding
          let slot = invItems[over]
          if(holding.id){
            var canSplit = holding.id === slot.id && slot.amount < blockData[slot.id].stackSize
            if(!slot.id){
              canSplit = true
              slot.id = holding.id
              slot.amount = 0
            }
            if(canSplit){
              slot.amount ++
              holding.amount --
              if(holding.amount <= 0) holding.id = 0
            }
          }
        }else{
          if(invItems[over] && invItems[over].id){
            let temp = inventory.holding
            if(temp.id === invItems[over].id && temp.amount < blockData[temp.id].stackSize && invItems[over].amount < blockData[invItems[over].id].stackSize){ //stacking together
              let stackSize = blockData[invItems[over].id].stackSize
              while(temp.amount > 0){
                temp.amount--
                invItems[over].amount ++
                if(invItems[over].amount >= blockData[invItems[over].id].stackSize) break
              }
              if(temp.amount <= 0){
                temp.id = 0
              }
            }else{
              inventory.holding = invItems[over]
              if(temp && temp.id){
                invItems[over] = temp
              }else invItems[over] = {id:0,amount:0}
            }
          }else if(inventory.holding){
            invItems[over] = inventory.holding
            inventory.holding = 0
            inventory.spreadStart = over
            inventory.spreadPlace = "invSpace"
          }
        }
      }else{
			  inventory.holding = {id:over + 1, amount:blockData[over+1].stackSize}
      }
		} else if(screen === "inventory" && mouseX>offX && mouseX<offX+(s*2) && mouseY>offY && mouseY<offY+(s*2)){
      //inv crafting grid
      let X = Math.floor((mouseX - offX) / s)
      let Y = Math.floor((mouseY - offY) / s)
      let idx = (Y*3)+X
      if(mouse === 2 && inventory.holding.amount > 1){
        if(!inventory.crafting[idx]) inventory.crafting[idx] = {id:0,amount:0}
        let holding = inventory.holding
        let slot = inventory.crafting[idx]
        if(holding.id){
          var canSplit = holding.id === slot.id && slot.amount < blockData[slot.id].stackSize
          if(!slot.id){
            canSplit = true
            slot.id = holding.id
            slot.amount = 0
          }
          if(canSplit){
            slot.amount ++
            holding.amount --
            if(holding.amount <= 0) holding.id = 0
          }
        }
      }else{
        let temp = inventory.holding
        inventory.holding = inventory.crafting[idx]
        inventory.crafting[idx] = temp
      }
      
      let arr = inventory.crafting.map((v) => v?v.id:0)
      let recipe = inventory.craftingStr = arr.join(",")
      if(crafts[recipe]){
        inventory.craftingRes = crafts[recipe]
      }else{
        var shapeless = shapelessCraft(arr)
        if(shapeless){
          inventory.craftingRes = crafts[shapeless]
        }else{
          inventory.craftingRes = 0
        }
      }
    }else if(screen === "inventory" && mouseX>craftResX && mouseX<craftResX+s && mouseY>craftResY && mouseY<craftResY+s && inventory.craftingRes && inventory.craftingRes.id){
      //inv crafting output
      inventory.holding = Object.assign({}, inventory.craftingRes)
      for(let i=0; i<9; i++){
        let block = inventory.crafting[i]
        if(block && block.id){
          block.amount --
          if(block.amount < 1)inventory.crafting[i].id = 0
        }
      }
      var r = inventory.holding && inventory.holding.id
      if(r === blockIds.craftingTable){
        achievment("Benchmaking")
      }
      let arr = inventory.crafting.map((v) => v?v.id:0)
      let recipe = inventory.craftingStr = arr.join(",")
      if(crafts[recipe]){
        inventory.craftingRes = crafts[recipe]
      }else{
        var shapeless = shapelessCraft(arr)
        if(shapeless){
          inventory.craftingRes = crafts[shapeless]
        }else{
          inventory.craftingRes = 0
        }
      }
    }else if(screen === "crafting" && mouseX>offX && mouseX<offX+(s*3) && mouseY>offY && mouseY<offY+(s*3)){}else{
			inventory.holding = 0
		}

		if(!dontRedraw)drawScreens.inventory()
	}
  function moveInv(){
    let s = inventory.size
		let s2 = s / 2
		let perRow = 13
		let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
    
    if(!survival){
      var idx = 0;
      for(var i=1; i<over+1; i++){
        if(!blockData[i]) break;

        idx ++;
        if(blockData[i+1] && blockData[i+1].hidden)idx++;
      }
      over = idx;
    }
    
    let count = survival ? invLength : BLOCK_COUNT - 1
    
    //for crafting
    let offX = width - s*4
    let offY = s * 2
    let craftResX = offX+(s/2)
    let craftResY = offY+(s*3)
    
		let x = width / 2 - 9 / 2 * s + 25
		let y = height - s * 1.5
		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			//hotbar
		} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
      if(survival){
        if(!invItems[over]) invItems[over] = {id:0,amount:0}
        if(inventory.spreadPlace === "invSpace" && inventory.spreadStart > -1 && invItems[inventory.spreadStart].amount > 1 && mouseDown){
          inventory.spreading = true
        }
        if(inventory.spreading && !(invItems[over] && invItems[over].id) && over !== inventory.spreadStart && inventory.spreaded.length < invItems[inventory.spreadStart].amount){
          if(inventory.spreaded.length){
            invItems[over] = invItems[inventory.spreadStart]
            inventory.spreaded.push(over)
          }else{
            invItems[over] = invItems[inventory.spreadStart]
            inventory.spreaded.push(inventory.spreadStart, over)
          }
        }
      }
		}
  }
  function releaseInv(){
    let s = inventory.size
		let s2 = s / 2
		let perRow = 13
		let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
    
    if(!survival){
      var idx = 0;
      for(var i=1; i<over+1; i++){
        if(!blockData[i]) break;

        idx ++;
        if(blockData[i+1] && blockData[i+1].hidden)idx++;
      }
      over = idx;
    }
    
    let count = survival ? invLength : BLOCK_COUNT - 1
    
    //for crafting
    let offX = width - s*4
    let offY = s * 2
    let craftResX = offX+(s/2)
    let craftResY = offY+(s*3)
    
		let x = width / 2 - 9 / 2 * s + 25
		let y = height - s * 1.5
		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			//hotbar
		} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
      if(survival){
        if(!invItems[over]) invItems[over] = {id:0,amount:0}
        if(inventory.spreadPlace === "invSpace" && inventory.spreaded.length){
          //a/b with remainder
          var a=invItems[inventory.spreadStart].amount
          var b=inventory.spreaded.length
          var n=a/b
          var f=floor(n)
          var r=n-f
          n=f
          r=floor(r*b)//sometimes not precise so use floor
          //n = result   r = remainder
          
          var id = invItems[inventory.spreadStart].id
          
          for(var i=0; i<inventory.spreaded.length; i++){
            invItems[inventory.spreaded[i]] = {id:id, amount:n}
          }
          if(r) inventory.holding = {id:id, amount:r}
          
          inventory.spreaded = []
        }
        inventory.spreadStart = -1
        inventory.spreading = false
      }
		}
  }

  function drawCrafting(mouse) {
    drawInv(true, mouse)
    let s = inventory.size
    let s2 = s/2
    
    gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
    
    let offX = width - s*4
    let offY = s * 2
    //draw grid
    ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
    let y = s*3+offY
    let x
    for(x=0; x<4; x++){
      ctx.moveTo(x*s+offX, offY)
      ctx.lineTo(x*s+offX, y)
    }
    x = s*3+offX
    for(y=0; y<4; y++){
      ctx.moveTo(offX, y*s+offY)
      ctx.lineTo(x, y*s+offY)
    }
    ctx.stroke()
    
    //icons
    ctx2.font = "14px VT323"
    ctx2.textAlign = "right"
    ctx2.fillStyle = "white"
    for(y=0; y<3; y++){
      for(x=0; x<3; x++){
        let idx = (y*3) + x
        if(inventory.crafting[idx] && inventory.crafting[idx].id){
          let X = x*s+offX, Y = y*s+offY
          drawIcon(X+s2,Y+s2, inventory.crafting[idx].id, inventory.crafting[idx])
          ctx2.fillText(inventory.crafting[idx].amount, X+s, Y+s)
        }
      }
    }
    
    x = Math.floor((mouseX - offX) / s)
    y = Math.floor((mouseY - offY) / s)
    let over = (y * 3) + x
    if(!(x >= 0 && x < 3 && y >= 0 && y < 3)){
      over = -1
    }else if(over > -1 && over < 9){
      ctx.lineWidth = 2
      ctx.strokeStyle = "white"
      ctx.strokeRect(x*s+offX, y*s+offY, s,s)
    }
    
    x = offX + (s)
    y = offY + (s*4)
    over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    ctx.lineWidth = over?2:1
    ctx.strokeStyle = over?"white":"black"
    ctx.strokeRect(x,y, s,s)
    if(inventory.craftingRes && inventory.craftingRes.id){
      drawIcon(x+s2, y+s2, inventory.craftingRes.id, inventory.craftingRes)
      ctx2.font = "14px VT323"
      ctx2.textAlign = "right"
      ctx2.fillStyle = "white"
      ctx2.fillText(inventory.craftingRes.amount, x+s, y+s)
    }
    
    ctx.drawImage(gl.canvas,0,0)
    
    if(inventory.craftingRes && inventory.craftingRes.id){
      let name = blockData[inventory.craftingRes.id].name
      if(name !== "" && over){
        ctx.textAlign = "left"
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10, mouseY+13+2);
      }
    }
    
    ctx.drawImage(canvas2,0,0)
  }
  
  function clickCrafting(mouse) {
    clickInv(true, mouse)
    
    let s = inventory.size
    let s2 = s/2
    let offX = width - s*4
    let offY = s * 2
    
    let x = offX + (s)
    let y = offY + (s*4)
    //get thing from output
    let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    if(over && inventory.craftingRes && inventory.craftingRes.id){
      inventory.holding = Object.assign({}, inventory.craftingRes)
      for(let i=0; i<9; i++){
        let block = inventory.crafting[i]
        if(block && block.id){
          block.amount --
          if(block.amount < 1)inventory.crafting[i].id = 0
        }
      }
      //achievments
      var r = inventory.holding && inventory.holding.id
      if(r && blockData[r].pickaxe){
        achievment("Time to Mine!")
      }
      if(r === blockIds.stonePickaxe){
        achievment("Getting an Upgrade")
      }
      if(r === blockIds.bread){
        achievment("Bake Bread")
      }
      if(r && blockData[r].sword){
        achievment("Time to Strike!")
      }
      if(r && blockData[r].hoe){
        achievment("Time to Farm!")
      }
    }
    
    //grid
    if(mouseX>offX && mouseX<offX+(s*3) && mouseY>offY && mouseY<offY+(s*3)){
      let X = Math.floor((mouseX - offX) / s)
      let Y = Math.floor((mouseY - offY) / s)
      let idx = (Y*3)+X
      let temp = inventory.holding
      
      if(mouse === 2 && inventory.holding.amount > 1){
        if(!inventory.crafting[idx]) inventory.crafting[idx] = {id:0,amount:0}
        let holding = inventory.holding
        let slot = inventory.crafting[idx]
        if(holding.id){
          var canSplit = holding.id === slot.id && slot.amount < blockData[slot.id].stackSize
          if(!slot.id){
            canSplit = true
            slot.id = holding.id
            slot.amount = 0
          }
          if(canSplit){
            slot.amount ++
            holding.amount --
            if(holding.amount <= 0) holding.id = 0
          }
        }
      }else{
        inventory.holding = inventory.crafting[idx]
        inventory.crafting[idx] = temp
      }
    }
    
    let arr = []
    inventory.crafting.forEach((v) => arr.push(v?v.id:0))
    let recipe = inventory.craftingStr = arr.join(",")
    if(crafts[recipe]){
      inventory.craftingRes = crafts[recipe]
    }else{
      var shapeless = shapelessCraft(arr)
      if(shapeless){
        inventory.craftingRes = crafts[shapeless]
      }else{
        inventory.craftingRes = 0
      }
    }
    
    drawScreens.crafting()
  }
  
  function drawFurnace(){
    drawInv(true)
    let s = inventory.size
    let s2 = s/2
    
    gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
    
    var toPlay
    
    var data = world.getTags(furnaceData.x, furnaceData.y, furnaceData.z)
    if(!data || !(data&&data.furnace)){
      var block = world.getBlock(furnaceData.x, furnaceData.y, furnaceData.z)
      if(blockData[block].name === "furnace"){
        data = {furnace:true, input:0, fuel:0, output:0, smeltStart:0, burnStart:0, canBurn:false, smelting:false}
        world.setTags(furnaceData.x, furnaceData.y, furnaceData.z, data)
      }else toPlay = true //furnace doesn't exsist here
    }
    furnaceData.data = data
    
    data.smelting = data.input && data.fuel && smelts[data.input.id] && smeltFuel[data.fuel.id] && true
    if(data.smelting){
      var smeltTo = smelts[data.input.id]
      var fuel = smeltFuel[data.fuel.id]
      var seconds = (Date.now() - data.smeltStart) / 1000
      var progress = seconds * 20 //ticks
      var burnProgress = (Date.now() - data.burnStart) / 1000
      data.progress = progress / smeltTo.time
      data.burnProgress = 1-(burnProgress / fuel.time)
      if(progress >= smeltTo.time){
        var a = floor(progress/smeltTo.time)
        for(var i=0; i<a; i++){
          data.input.amount --
          if(data.output){
            data.output.amount ++
          }else{
            data.output = {id:smeltTo.id, amount:1}
          }
          if(data.input.amount === 0){
            data.input = 0
            break
          }
        }
        data.smeltStart += (a/20)*smeltTo.time*1000
      }
      if(burnProgress >= fuel.time){
        data.canBurn = false
      }
      if(!data.canBurn){
        var a = floor(burnProgress/fuel.time)
        for(var i=0; i<a; i++){
          data.fuel.amount --
          if(data.fuel.amount === 0){
            data.fuel = 0
            break
          }
        }
        data.burnStart += a*fuel.time*1000
        data.canBurn = true
      }
    }
    
    let offX = width - s*4
    let offY = s * 2
    
    ctx.font = "20px VT323"
    ctx.fillStyle = "white"
    ctx.textAlign = "left"
    ctx.fillText("Furnace", offX, offY - s2)
    
    //font for numbers
    ctx2.font = "14px VT323"
    ctx2.textAlign = "right"
    ctx2.fillStyle = "white"
    
    let x = offX+s2-2
    let y = offY+s
    fill(100)
    ctx.fillRect(x,y,4,s)
    if(data.burnProgress){
      fill(255,data.burnProgress*255,0)
      let h = data.burnProgress*s
      ctx.fillRect(x,y+s-h,4,h)
    }
    
    x = offX+s
    y = offY+s
    ctx.strokeStyle = "black"
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(x+s,y+s2)
    ctx.lineTo(x+s2,y)
    ctx.moveTo(x+s,y+s2)
    ctx.lineTo(x+s2,y+s)
    ctx.stroke()
    y = y+s2-2
    fill(0)
    ctx.fillRect(x,y,s,4)
    if(data.progress){
      fill(255)
      ctx.fillRect(x,y,s*data.progress,4)
    }
    
    //input
    x = offX
    y = offY
    let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    ctx.lineWidth = over?2:1
    ctx.strokeStyle = over?"white":"black"
    ctx.strokeRect(x,y, s,s)
    if(data.input && data.input.id){
      drawIcon(x+s2, y+s2, data.input.id, data.input)
      ctx2.fillText(data.input.amount, x+s, y+s)
    }
    
    //fuel
    x = offX
    y = offY + (s*2)
    over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    ctx.lineWidth = over?2:1
    ctx.strokeStyle = over?"white":"black"
    ctx.strokeRect(x,y, s,s)
    if(data.fuel && data.fuel.id){
      drawIcon(x+s2, y+s2, data.fuel.id, data.fuel)
      ctx2.fillText(data.fuel.amount, x+s, y+s)
    }
    
    //output
    x = offX + (s*2)
    y = offY + s
    over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    ctx.lineWidth = over?2:1
    ctx.strokeStyle = over?"white":"black"
    ctx.strokeRect(x,y, s,s)
    if(data.output && data.output.id){
      drawIcon(x+s2, y+s2, data.output.id, data.output)
      ctx2.fillText(data.output.amount, x+s, y+s)
    }
    
    ctx.drawImage(gl.canvas,0,0)
    
    if(over && data.output && data.output.id){ //this is right aligned so you can see it
      let name = blockData[data.output.id].name
      if(name !== "" && over){
        ctx.textAlign = "left"
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX-w-20, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10-w-20, mouseY+13+2);
      }
    }
    
    ctx.drawImage(canvas2,0,0)
    if(toPlay) play()
  }
  function clickFurnace(mouse){
    let s = inventory.size
    let s2 = s/2
    
    let offX = width - s*4
    let offY = s * 2
    
    var data = furnaceData.data //inventory.furnaceData.data
    let temp
    
    var clicked
    
    //input
    let x = offX
    let y = offY
    let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    if(over){
      temp = data.input
      data.input = inventory.holding
      inventory.holding = temp
      data.smeltStart = Date.now()
      data.burnStart = Date.now()
      clicked = true
    }
    
    //fuel
    x = offX
    y = offY + (s*2)
    over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    if(over){
      temp = data.fuel
      data.fuel = inventory.holding
      inventory.holding = temp
      data.burnStart = Date.now()
      data.smeltStart = Date.now()
      clicked = true
    }
    
    //output
    x = offX + (s*2)
    y = offY + s
    over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    if(over){
      inventory.holding = data.output
      data.output = 0
      clicked = true
    }
    
    if(!clicked)clickInv(true, mouse)
    drawScreens.furnace()
  }

	let unpauseDelay = 0
	function mmoved(e) {
		let mouseS = settings.mouseSense / 30000
		p.rx -= e.movementY * mouseS
		p.ry += e.movementX * mouseS

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2
		}
	}
	function trackMouse(e) {
		if (screen !== "play") {
			cursor("")
			mouseX = e.x
			mouseY = e.y
      if(screen !== "main menu" && !(screen === "furnace" && furnaceData.data.smelting)){
        drawScreens[screen]()
        Button.draw()
        Slider.draw()
        Slider.drag()
      }
		}
    if(screen === "inventory" || screen === "crafting" || screen === "furnace") moveInv()
	}
	document.onmousemove = trackMouse
  
  //added by me from mobile test minekhan with more code
	//https://www.khanacademy.org/computer-programming/mobile-test-minekhan/5100360783052800
	win.pTouch = {x: -100, y: 0};
	canvas.addEventListener("touchstart", function(e) {
    pTouch.x = e.changedTouches[0].pageX;
    pTouch.y = e.changedTouches[0].pageY;
    pTouch.touching = mouseDown=true
    pTouch.touchStart = Date.now()
    pTouch.moved = false
    pTouch.canDig = true
	}, false);
	canvas.addEventListener("touchmove", function(e) {
    e.movementY = -(e.changedTouches[0].pageY - pTouch.y);
    e.movementX = -(e.changedTouches[0].pageX - pTouch.x);
    pTouch.x = e.changedTouches[0].pageX;
    pTouch.y = e.changedTouches[0].pageY;
    mmoved(e);
    pTouch.moved = true
    if(Date.now() - pTouch.touchStart < touchMoveLimit && e.movementX < 10 && e.movementY < 10){
      pTouch.canDig = false
    }
    e.preventDefault();
	}, false);
  var touchend = e => {
    pTouch.touching = mouseDown = false
  }
	canvas.addEventListener("touchend",touchend,false)
  canvas.addEventListener("touchcancel",touchend,false)
  
	document.onpointerlockchange = function() {
		if (doc.pointerLockElement === canvas) {
			doc.onmousemove = mmoved
		} else {
			doc.onmousemove = trackMouse
			if (screen === "play" && !freezeFrame) {
				changeScene("pause")
				unpauseDelay = Date.now() + 1000
			}
		}
		for (let key in Key) {
			Key[key] = false
		}
	}
	canvas.onmousedown = function(e) {
		mouseX = e.x
		mouseY = e.y
		mouseDown = true
		let block, index
		switch(e.button) {
			case 0:
				Key.leftMouse = true
				break
			case 1:
				Key.middleMouse = true
				if (!hitBox.pos || survival) break
				updateHUD = true
				block = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) & 0x3ff
				index = -1
        for(var i=0; i<inventory.hotbar.length; i++){
          if(inventory.hotbar[i].id === block){
            index = i
            break
          }
        }
				if (index >= 0) {
					inventory.hotbarSlot = index
				} else {
					inventory.hotbar[inventory.hotbarSlot].id = block
				}
				break
			case 2:
				Key.rightMouse = true
				break
		}
		if(screen === "play") {
			if (doc.pointerLockElement !== canvas) {
				getPointer()
				p.lastBreak = Date.now()
			} else {
				place = false
				if(e.button === 0) {
					if(Key.control) {
						place = true
					} else if(entHitbox.ent){
				    holding = inventory.hotbar[inventory.hotbarSlot].id
            entClick()
          }else if(!survival){
            changeWorldBlock(0)
					}
				}
				holding = inventory.hotbar[inventory.hotbarSlot].id
				if(e.button === 2 && holding) {
					place = true
				}
				if(place) {
					newWorldBlock()
				}
			}
		} else if (screen === "inventory" || screen === "crafting" || screen === "furnace") {
      if(mouseDown && mouseX >= width-barW){
        draggingInvBar = true
        invBarOffset = mouseY-map(invScroll, 0, invHeight, (barH/2), height-(barH/2))
      }
      if(screen === "crafting")clickCrafting(e.button)
      else if(screen === "furnace")clickFurnace(e.button)
      else clickInv(false, e.button)
		}

		Button.click()
		Slider.click()
	}
	canvas.onmouseup = function(e) {
		switch(e.button) {
			case 0:
				Key.leftMouse = false
				break
			case 1:
				Key.middleMouse = false
				break
			case 2:
				Key.rightMouse = false
				break
		}
		mouseDown = false
		Slider.release()
    
    draggingInvBar = false
    
    if(screen === "inventory" || screen === "crafting" || screen === "furnace") releaseInv()
	}
  
  for(var onscreencontrol in onscreenControls){
	    var onscreencontrolElement = onscreenControls[onscreencontrol]
	    onscreencontrolElement.value = onscreencontrol
	    onscreencontrolElement.onmousedown=function(){
	        canvas.onkeydown({key:this.value})
	    }
	    onscreencontrolElement.onmouseup=function(){
	        canvas.onkeyup({key:this.value})
	    }
	    onscreencontrolElement.addEventListener("touchstart",onscreencontrolElement.onmousedown)
	    onscreencontrolElement.addEventListener("touchend",onscreencontrolElement.onmouseup)
      onscreencontrolElement.addEventListener("touchcancel",onscreencontrolElement.onmouseup)
	}
	onscreenControls[" "].addEventListener("click",function(){
    if (!survival && !p.spectator) {//fly toggle
			if (Date.now() < p.lastJump + 400) {
				p.flying ^= true
			} else {
				p.lastJump = Date.now()
			}
		}
	})
  let lastForward = 0
  onscreenControls.w.addEventListener("touchstart",function(){
			if (Date.now() < lastForward + 400) { //sprint toggle
				player.sprinting = true
			} else {
				lastForward = Date.now()
			}
	})
  onscreenControls.w.addEventListener("touchend",() => p.sprinting = false)
  onscreenControls.w.addEventListener("touchcancel",() => p.sprinting = false)
	onscreenControls[" "].addEventListener("mousedown",function(){
	    Key[" "]=true
	})
	onscreenControls[" "].addEventListener("mouseup",function(){
	    Key[" "]=false
	})
	onscreenControls[" "].addEventListener("touchstart",function(){
	    Key[" "]=true
	})
	onscreenControls[" "].addEventListener("touchend",function(){
	    Key[" "]=false
	})
	
  onscreenControl_Element.onclick = e => {mouseX = e.x; mouseY = e.y}
  
  let changeSlot = () => {
    for(let i = 0; i < inventory.hotbar.length; i ++) {
      let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  let y = height - inventory.size
      
      x -= inventory.size/2
		  y -= inventory.size/2
			if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
			  inventory.hotbarSlot = i
			  holding = inventory.hotbar[inventory.hotbarSlot].id
			  updateHUD = true
			}
		}
    i ++
    let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
    let y = height - inventory.size

    x -= inventory.size/2
    y -= inventory.size/2
    if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
      changeScene("inventory")
    }
  }
	onscreenControl_Element.addEventListener("click",changeSlot)
	onscreenControl_Element.addEventListener("touchend",changeSlot)
  
	canvas.onkeydown = function(e) {
		let k = e.key.toLowerCase()
		if (e.preventDefault && k === " ") {
			e.preventDefault()
		}
		if (e.repeat || Key[k]) {
			return
		}
		Key[k] = true

		if (k === "t") {
			initTextures()
		}

		if (k === controlMap.cycleBlockShapes.key) {
			blockMode = blockMode === CUBE ? SLAB : (blockMode === SLAB ? STAIR : (blockMode === STAIR ? FENCE : (blockMode === FENCE ? WALLPOST : (blockMode === WALLPOST ? WALL : (blockMode === WALL ? WALLU : (blockMode === WALLU ? FENCQ : CUBE))))))
			updateHUD = true
		}

		if (screen === "play") {
			if(k === controlMap.pause.key) {
				releasePointer()
				changeScene("pause")
			}

			if(k === controlMap.superBreaker.key) {
				p.autoBreak = !p.autoBreak
				updateHUD = true
        if(survival) p.autoBreak = false
			}
      if(k === controlMap.hyperBuilder.key) {
				p.autoBuild = !p.autoBuild
				updateHUD = true
        if(survival) p.autoBuild = false
			}

			if (k === controlMap.jump.key && !p.spectator) {
				if (Date.now() < p.lastJump + 400) {
					p.flying ^= true
          if(survival) p.flying = false
				} else {
					p.lastJump = Date.now()
				}
			}

			if (k === controlMap.zoom.key) {
				p.FOV(10, 300)
			}

			if (k === controlMap.sneak.key && !p.flying) {
				p.sneaking = true
				if (p.sprinting) {
					p.FOV(settings.fov, 100)
				}
				p.sprinting = false
				p.speed = 0.03
				p.bottomH = 1.32
			}

			if (k === controlMap.spectator.key && !survival) {
				p.spectator = !p.spectator
				p.flying = true
				p.onGround = false
				updateHUD = true
			}
      if (k === controlMap.thirdPerson.key){
        p.thirdPerson = !p.thirdPerson
      }

			if (k === controlMap.inventory.key) {
				changeScene("inventory")
				releasePointer()
        achievment("Taking Inventory")
			}

			if (k === ";") {
				releasePointer()
				freezeFrame = true
			}
      
      if(k === controlMap.chat.key){
        Messages.showInput()
      }

			if (k === controlMap.dropItem.key && inventory.hotbar[inventory.hotbarSlot] && inventory.hotbar[inventory.hotbarSlot].id) {
				let d = p.direction
        let block = holding || inventory.hotbar[inventory.hotbarSlot].id
        block = block < isCube ? block | blockMode : block
				world.addEntity(new Item(p.x + (d.x), p.y + (d.y), p.z + (d.z), d.x/4, d.y/4, d.z/4, block))
        if(survival){
          inventory.hotbar[inventory.hotbarSlot].amount --
          updateHUD = true
        }
			}

			if(Number(k)) {
				inventory.hotbarSlot = Number(k) - 1
        inventory.showName = 1.5
				holding = inventory.hotbar[inventory.hotbarSlot].id
				updateHUD = true
			}
		} else if (screen === "pause") {
			if(k === controlMap.pause.key) {
				play()
			}
		} else if (screen === "inventory" || screen === "crafting" || screen === "furnace") {
			if (k === controlMap.inventory.key) {
        if(screen === "crafting" || screen === "inventory"){
          for(var i=0; i<9; i++){
            if(inventory.crafting[i] && inventory.crafting[i].id){
              for(var n=0; n<inventory.crafting[i].amount; n++)newInvItem(inventory.crafting[i].id)
              inventory.crafting[i].id = 0
            }
          }
          inventory.craftingRes = 0
        }
				play()
			}
			if (k === controlMap.cycleBlockShapes.key) {
				drawScreens.inventory()
			}
		}
	}
	canvas.onkeyup = function(e) {
		let k = e.key.toLowerCase()
		Key[k] = false
		if(k === "escape" && (screen === "pause" || screen === "inventory" || screen === "options" && previousScreen === "pause") && Date.now() > unpauseDelay) {
			play()
		}
		if (screen === "play") {
			if (k === controlMap.zoom.key) {
				p.FOV(settings.fov, 300)
			}

			if (k === controlMap.sneak.key && p.sneaking) {
				p.sneaking = false
				p.speed = 0.075
				p.bottomH = 1.62
				// p.y += 0.3
			}
		}
	}
	canvas.onblur = function() {
		for (let key in Key) {
			Key[key] = false
		}
		mouseDown = false
		Slider.release()
	}
	canvas.oncontextmenu = function(e) {
		e.preventDefault()
	}
	window.onbeforeunload = e => { 
		if (screen === "play" && Key.control) {
			releasePointer()
			e.preventDefault()
			e.returnValue = "Q is the sprint button; Ctrl + W closes the page."
			return true
		}
	}
	canvas.onwheel = e => {
		e.preventDefault()
		e.stopPropagation()
    if(screen === "play"){
      if (e.deltaY > 0) {
        inventory.hotbarSlot++
      } else if (e.deltaY < 0) {
        inventory.hotbarSlot--
      }
      if (inventory.hotbarSlot > 8) {
        inventory.hotbarSlot = 0
      } else if (inventory.hotbarSlot < 0) {
        inventory.hotbarSlot = 8
      }

      updateHUD = true
      holding = inventory.hotbar[inventory.hotbarSlot].id
    }
    if(screen === "inventory" || screen === "crafting" || screen === "furnace"){
      invScroll += e.deltaY
      if(invScroll < 0) invScroll = 0
      if(invScroll > invHeight) invScroll = invHeight
      drawScreens[screen]()
    }
	}
	document.onwheel = e => {} // Shouldn't do anything, but it helps with a Khan Academy bug somewhat
	window.onresize = e => {
		width = window.innerWidth
		height = window.innerHeight
		canvas.height = height
		canvas.width = width
    ctx.imageSmoothingEnabled = false
    canvas2.width = width
    canvas2.height = height
		gl.canvas.height = height
		gl.canvas.width = width
		gl.viewport(0, 0, width, height)
		initButtons()
		initBackgrounds()
		inventory.size = 40 * min(width, height) / 600
    inventory.ts = inventory.size / 16
		genIcons()
		use3d()
		p.FOV(p.currentFov + 0.0001)

		if (screen === "play") {
			play()
		} else {
			drawScreens[screen]()
			Button.draw()
			Slider.draw()
		}
	}

	function use2d() {
		gl.disableVertexAttribArray(glCache.aTexture)
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aVertex)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.useProgram(program2D)
		
		gl.enableVertexAttribArray(glCache.aVertex2)
		gl.enableVertexAttribArray(glCache.aTexture2)
		gl.enableVertexAttribArray(glCache.aShadow2)
	}
	function use3d() {
		gl.disableVertexAttribArray(glCache.aTexture2)
		gl.disableVertexAttribArray(glCache.aShadow2)
		gl.disableVertexAttribArray(glCache.aVertex2)
		gl.useProgram(program3D)
		
		gl.enableVertexAttribArray(glCache.aVertex)
		gl.enableVertexAttribArray(glCache.aTexture)
		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
	}

	let maxLoad = 1
	function startLoad() {
		// Runs when the loading screen is opened; cache the player's position
		p2.x = p.x
		p2.y = p.y
		p2.z = p.z
		maxLoad = world.loadFrom.length + 9
	}
  function initWebglPrograms(){
    modelView = new Float32Array(16)
		glCache = {}
		win.glCache = glCache
		program3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D)
		program2D = createProgramObject(gl, vertexShaderSrc2D, fragmentShaderSrc2D)
    programPanorama = createProgramObject(gl, vertexShaderSrcPanorama, fragmentShaderSrcPanorama)
    skyboxProgram = createProgramObject(gl, skyboxVertex, skyboxFragment);
		programEntity = createProgramObject(gl, vertexShaderSrcEntity, fragmentShaderSrcEntity)
    programParticle = createProgramObject(gl, vertexShaderSrcParticle, fragmentShaderSrcParticle)
    
    skybox = new Skybox()
		
		gl.useProgram(program2D)
		glCache.uSampler2 = gl.getUniformLocation(program2D, "uSampler")
		glCache.aTexture2 = gl.getAttribLocation(program2D, "aTexture")
		glCache.aVertex2 = gl.getAttribLocation(program2D, "aVertex")
		glCache.aShadow2 = gl.getAttribLocation(program2D, "aShadow")
    
    gl.useProgram(programPanorama)
    glCache.uSamplerPanorama = gl.getUniformLocation(programPanorama, "uSampler")
    glCache.aVertexPanorama = gl.getAttribLocation(programPanorama, "aVertex")
    glCache.textureXPanorama = gl.getUniformLocation(programPanorama, "textureX")
    glCache.textureWPanorama = gl.getUniformLocation(programPanorama, "textureW")
    glCache.textureHPanorama = gl.getUniformLocation(programPanorama, "textureH")
    glCache.resolutionPanorama = gl.getUniformLocation(programPanorama, "u_resolution")
    glCache.uViewPanorama = gl.getUniformLocation(programPanorama,"uView")
    
    gl.useProgram(skyboxProgram)
    glCache.skyboxVertex = gl.getAttribLocation(skyboxProgram, "aVertex");
    glCache.skyboxTime = gl.getUniformLocation(skyboxProgram, "time");
    glCache.skyboxView = gl.getUniformLocation(skyboxProgram, "uView");

		gl.useProgram(programEntity)
		glCache.uSamplerEntity = gl.getUniformLocation(programEntity, "uSampler")
		glCache.uLightLevelEntity = gl.getUniformLocation(programEntity, "uLightLevel")
		glCache.uViewEntity = gl.getUniformLocation(programEntity, "uView")
    glCache.harmEffectEntity = gl.getUniformLocation(programEntity, "harmEffect")
		glCache.aTextureEntity = gl.getAttribLocation(programEntity, "aTexture")
		glCache.aVertexEntity = gl.getAttribLocation(programEntity, "aVertex")
    
    gl.useProgram(programParticle)
		glCache.uSamplerParticle = gl.getUniformLocation(programParticle, "uSampler")
		glCache.uLightLevelParticle = gl.getUniformLocation(programParticle, "uLightLevel")
		glCache.uViewParticle = gl.getUniformLocation(programParticle, "uView")
		glCache.aTextureParticle = gl.getAttribLocation(programParticle, "aTexture")
		glCache.aVertexParticle = gl.getAttribLocation(programParticle, "aVertex")

		gl.useProgram(program3D)
		glCache.uSampler = gl.getUniformLocation(program3D, "uSampler")
		glCache.uPos = gl.getUniformLocation(program3D, "uPos")
		glCache.uDist = gl.getUniformLocation(program3D, "uDist")
		glCache.uTime = gl.getUniformLocation(program3D, "uTime")
		glCache.aShadow = gl.getAttribLocation(program3D, "aShadow")
		glCache.aSkylight = gl.getAttribLocation(program3D, "aSkylight")
		glCache.aBlocklight = gl.getAttribLocation(program3D, "aBlocklight")
		glCache.aTexture = gl.getAttribLocation(program3D, "aTexture")
		glCache.aVertex = gl.getAttribLocation(program3D, "aVertex")
    glCache.skyColor = gl.getUniformLocation(program3D, "skyColor")
    glCache.inWater = gl.getUniformLocation(program3D, "inWater")
    glCache.uTrans = gl.getUniformLocation(program3D, "uTrans")
    
    gl.uniform1i(glCache.uTrans, 0)

		gl.uniform1f(glCache.uDist, 1000)
  }
  win.initWebglPrograms = initWebglPrograms
	function initWebgl() {
		if (!win.gl) {
			let canv = document.createElement('canvas')
			canv.width = ctx.canvas.width
			canv.height = ctx.canvas.height
			canv.style.position = "absolute"
			canv.style.zIndex = -1
			canv.style.top = "0px"
			canv.style.left = "0px"
			gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false })
			let ext = gl.getExtension('OES_element_index_uint')
			if (!ext) {
				alert("Please use a supported browser, or update your current browser.")
			}
			gl.viewport(0, 0, canv.width, canv.height)
			gl.enable(gl.DEPTH_TEST)
			gl.enable(gl.BLEND)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
			win.gl = gl
			glExtensions = []
			const availableExtensions = gl.getSupportedExtensions()
			for (let i = 0; i < availableExtensions.length; i++) {
				const extensionName = availableExtensions[i]
				glExtensions[extensionName.replace(/[A-Z]+_/g, "")] = gl.getExtension(extensionName)
			}
		} else {
			gl = win.gl
		}

		if (!document.body.contains(gl.canvas)) {
			document.body.append(gl.canvas)
		}

		initWebglPrograms()

		//Send the block textures to the GPU
		initTextures()
    initShapes()

    panoramaVertBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, panoramaVertBuffer)
    var data = []
    var rt = Math.PId/360
    var s = sin(-rt), c = cos(-rt)
    for(var deg=0; deg<Math.PId; deg+=rt){
      var s2 = sin(deg+rt), c2 = cos(deg+rt)
      data.push(s,0,c, s2,0,c, s2,1,c2, s,1,c2)
      s = s2, c = c2
    }
    win.panoramaVerts = data
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1,1,1,-1,1,1,-1,-1,1,1,-1,1]), gl.STATIC_DRAW)
    
		// These buffers are only used for drawing the main menu blocks
		sideEdgeBuffers = {}
		for (let side in shapes.cube.verts) {
			let edgeBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapes.cube.verts[side][0]), gl.STATIC_DRAW)
			sideEdgeBuffers[side] = edgeBuffer
		}
		texCoordsBuffers = []
		for (let t in textureCoords) {
			let buff = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buff)
			gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW)
			texCoordsBuffers.push(buff)
		}

		//Bind the Vertex Array Object (VAO) that will be used to draw everything
		indexBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW)

		//Tell it not to render the insides of blocks
		gl.enable(gl.CULL_FACE)
		gl.cullFace(gl.BACK)

		gl.lineWidth(2)
		blockOutlines = false
		gl.enable(gl.POLYGON_OFFSET_FILL)
		gl.polygonOffset(1, 1)
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
	}
  
	function initBackgrounds() {
		// Home screen background
    const HALF_PI = Math.PI / 2
    const blocks = [
      7, 4, 1, 7,
      7, 4, 2, 7,
      7, 4, 3, 7,
      7, 4, 4, 7,
      7, 5, 1, 7,
      7, 5, 2, 7,
      7, 5, 3, 7,
      6, 4, 0, 7,
      6, 4, 1, 7,
      6, 4, 2, 7,
      6, 4, 3, 7,
      6, 4, 4, 7,
      6, 5, 0, 7,
      6, 5, 1, 7,
      6, 5, 2, 7,
      6, 5, 3, 7,
      6, 5, 4, 7,
      6, 6, 3, 7,
      6, 6, 4, 7,
      6, 7, 3, 7,
      5, 0, -1, 1,
      5, 0, 0, 1,
      5, 0, 1, 1,
      5, 0, 2, 1,
      5, 1, 2, 29,
      5, 2, 2, 29,
      5, 3, 2, 29,
      5, 4, 2, 29,
      5, 5, 2, 29,
      5, 6, 2, 29,
      5, 4, 0, 7,
      5, 4, 1, 7,
      5, 4, 3, 7,
      5, 4, 4, 7,
      5, 5, 0, 7,
      5, 5, 1, 7,
      5, 5, 3, 7,
      5, 5, 4, 7,
      5, 6, 1, 7,
      5, 6, 3, 7,
      5, 7, 1, 7,
      5, 7, 2, 7,
      5, 7, 3, 7,
      4, -1, -1, 1,
      4, -1, 0, 1,
      4, -1, 1, 1,
      4, -1, 2, 1,
      4, 0, 3, 1,
      4, 0, 4, 1,
      4, 0, 5, 1,
      4, 0, 6, 1,
      4, 0, 7, 5,
      4, 0, 8, 5,
      4, 0, 9, 5,
      4, 0, 10, 5,
      4, 4, 0, 7,
      4, 4, 1, 7,
      4, 4, 2, 7,
      4, 4, 3, 7,
      4, 4, 4, 7,
      4, 5, 0, 7,
      4, 5, 1, 7,
      4, 5, 2, 7,
      4, 5, 3, 7,
      4, 5, 4, 7,
      4, 6, 1, 7,
      4, 6, 2, 7,
      4, 6, 3, 7,
      4, 7, 4, 7,
      3, -1, -1, 1,
      3, -1, 0, 1,
      3, -1, 1, 1,
      3, -1, 2, 1,
      3, -1, 3, 1,
      3, -1, 4, 1,
      3, 0, 5, 1,
      3, 0, 6, 1,
      3, 0, 7, 1,
      3, 0, 8, 5,
      3, 0, 9, 5,
      3, 0, 10, 5,
      3, 4, 1, 7,
      3, 4, 2, 7,
      3, 4, 3, 7,
      3, 4, 4, 7,
      3, 5, 1, 7,
      3, 5, 2, 7,
      3, 5, 3, 7,
      2, -1, -1, 1,
      2, -1, 0, 1,
      2, -1, 1, 1,
      2, -1, 2, 1,
      2, -1, 3, 1,
      2, -1, 4, 1,
      2, -1, 5, 1,
      2, -1, 6, 1,
      2, -1, 7, 1,
      2, 0, 8, 5,
      2, 0, 9, 5,
      2, 0, 10, 5,
      1, -2, -1, 1,
      1, -2, 0, 1,
      1, -2, 1, 1,
      1, -2, 2, 1,
      1, -2, 3, 1,
      1, -1, 4, 1,
      1, -1, 5, 1,
      1, -1, 6, 1,
      1, -1, 7, 1,
      1, -1, 8, 1,
      1, -1, 9, 5,
      1, -1, 10, 5,
      0, -2, -1, 1,
      0, -2, 0, 1,
      0, -2, 1, 1,
      0, -2, 2, 1,
      0, -2, 3, 1,
      0, -2, 4, 1,
      0, -2, 5, 1,
      0, -1, 6, 1,
      0, -1, 7, 1,
      0, -1, 8, 1,
      0, -1, 9, 5,
      0, -1, 10, 5,
      -1, -2, -1, 1,
      -1, -2, 0, 1,
      -1, -2, 1, 1,
      -1, -2, 2, 1,
      -1, -2, 3, 1,
      -1, -2, 4, 1,
      -1, -2, 5, 1,
      -1, -2, 6, 1,
      -1, -2, 7, 1,
      -1, -1, 8, 1,
      -1, -1, 9, 1,
      -1, -1, 10, 1,
      -2, -2, -1, 1,
      -2, -2, 0, 1,
      -2, -2, 1, 1,
      -2, -2, 2, 1,
      -2, -2, 3, 1,
      -2, -2, 4, 1,
      -2, -2, 5, 1,
      -2, -2, 6, 1,
      -2, -2, 7, 1,
      -2, -2, 8, 1,
      -2, -2, 9, 1,
      -2, -1, 10, 1,
      -3, -2, -1, 1,
      -3, -2, 0, 1,
      -3, -2, 1, 1,
      -3, -2, 2, 1,
      -3, -2, 3, 1,
      -3, -2, 4, 1,
      -3, -2, 5, 1,
      -3, -2, 6, 1,
      -3, -2, 7, 1,
      -3, -2, 8, 1,
      -3, -2, 9, 1,
      -3, -2, 10, 1,
      -3, -2, 11, 1,
      -3, -2, 12, 1,
      -4, -2, -1, 1,
      -4, -2, 0, 1,
      -4, -2, 1, 1,
      -4, -2, 2, 1,
      -4, -2, 3, 1,
      -4, -2, 4, 1,
      -4, -2, 5, 1,
      -4, -2, 6, 1,
      -4, -2, 7, 1,
      -4, -2, 8, 1,
      -4, -2, 9, 1,
      -4, -2, 10, 1,
      -4, -2, 11, 1,
      -4, -2, 12, 1,
      -5, -2, -1, 1,
      -5, -2, 0, 1,
      -5, -2, 1, 1,
      -5, -2, 2, 1,
      -5, -2, 3, 1,
      -5, -2, 4, 1,
      -5, -2, 5, 1,
      -5, -2, 6, 1,
      -5, -2, 7, 1,
      -5, -2, 8, 1,
      -5, -2, 9, 1,
      -5, -2, 10, 1,
      -5, -2, 11, 1,
      -5, -2, 12, 1,
      -6, -2, -1, 1,
      -6, -2, 0, 1,
      -6, -2, 1, 1,
      -6, -2, 2, 1,
      -6, -2, 3, 1,
      -6, -2, 4, 1,
      -6, -2, 5, 1,
      -6, -2, 6, 1,
      -6, -2, 7, 1,
      -6, -2, 8, 1,
      -6, -2, 9, 1,
      -6, -2, 10, 1,
      -6, -2, 11, 1,
      -7, -2, 3, 1,
      -7, -2, 4, 1,
      -7, -2, 5, 1,
      -7, -2, 6, 1,
      -7, -2, 7, 1,
      -7, -2, 8, 1,
      -7, -2, 9, 1,
      -8, -2, 2, 1,
      -8, -2, 3, 1,
      -8, -2, 4, 1,
      -8, -2, 5, 1,
      -8, -2, 6, 1,
      -8, -2, 7, 1,
      -8, -2, 8, 1,
      -8, -1, 8, 33,//birch tree
      -8, 0, 8, 33,
      -9, 1, 10, 7,
      -8, 1, 10, 7,
      -7, 1, 10, 7,
      -10, 1, 9, 7,
      -9, 1, 9, 7,
      -8, 1, 9, 7,
      -7, 1, 9, 7,
      -6, 1, 9, 7,
      -10, 1, 8, 7,
      -9, 1, 8, 7,
      -8, 1, 8, 7,
      -7, 1, 8, 7,
      -6, 1, 8, 7,
      -10, 1, 7, 7,
      -9, 1, 7, 7,
      -8, 1, 7, 7,
      -7, 1, 7, 7,
      -6, 1, 7, 7,
      -9, 1, 6, 7,
      -8, 1, 6, 7,
      -7, 1, 6, 7,
      -9, 2, 10, 7,
      -8, 2, 10, 7,
      -7, 2, 10, 7,
      -10, 2, 9, 7,
      -9, 2, 9, 7,
      -8, 2, 9, 7,
      -7, 2, 9, 7,
      -6, 2, 9, 7,
      -10, 2, 8, 7,
      -9, 2, 8, 7,
      -8, 2, 8, 7,
      -7, 2, 8, 7,
      -6, 2, 8, 7,
      -10, 2, 7, 7,
      -9, 2, 7, 7,
      -8, 2, 7, 7,
      -7, 2, 7, 7,
      -6, 2, 7, 7,
      -9, 2, 6, 7,
      -8, 2, 6, 7,
      -7, 2, 6, 7,
      -7, 3, 8, 7,//topper leaves
      -9, 3, 8, 7,
      -8, 3, 7, 7,
      -8, 3, 9, 7,
      -7, 4, 8, 7,
      -9, 4, 8, 7,
      -8, 4, 7, 7,
      -8, 4, 9, 7,
      3, 1, 8, 141,//cactus
      3, 2, 8, 141,
    ];
    var panoramaMatrix = new Matrix()
    var mainBG = document.createElement("canvas");
    mainBG.width = gl.canvas.width;
    mainBG.height = gl.canvas.height;
    var mainBGRot = 0//-HALF_PI / 3;
    win.mainBGW = 0
    win.renderMainBG = function(){
      //*
      mainBGRot += 0.005;
      if(mainBGRot > Math.PId){
        mainBGRot = 0;
      }/*/
      mainBGRot += 0.001;
      if(mainBGRot > 1){
        mainBGRot = 0;
      }//*/
      
      gl.clearColor(sky[0], sky[1], sky[2], 1.0)
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
      //remove or add the slash to toggle comment
      //can be: //* or /*
      //*
      gl.useProgram(program3D)
      FOV(100)
      initModelView(null, 1, 1.5, 5, -HALF_PI / 25, mainBGRot)//-HALF_PI / 3
      gl.disableVertexAttribArray(glCache.aShadow)
      gl.disableVertexAttribArray(glCache.aSkylight)
      gl.disableVertexAttribArray(glCache.aBlocklight)
      gl.vertexAttrib1f(glCache.aShadow, 1.0)
      gl.vertexAttrib1f(glCache.aSkylight, 1.0)
      gl.vertexAttrib1f(glCache.aBlocklight, 1.0)

      gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])
      for (let i = 0; i < blocks.length; i += 4) {
        block2(blocks[i + 0], blocks[i + 1], blocks[i + 2], blocks[i + 3])
      }

      gl.enableVertexAttribArray(glCache.aShadow)
      gl.enableVertexAttribArray(glCache.aSkylight)
      gl.enableVertexAttribArray(glCache.aBlocklight)/*/
      gl.useProgram(programPanorama)
      panoramaMatrix.identity()//copyMatrix(defaultTransformation)
      panoramaMatrix.scale(width,height,1)
      gl.uniform1i(glCache.uSamplerPanorama, 4)
      gl.uniform1f(glCache.textureXPanorama, mainBGRot)
      gl.uniform2f(glCache.resolutionPanorama, width,height)
      gl.uniformMatrix4fv(glCache.uViewPanorama, false, panoramaMatrix.elements)
      vertexAttribPointer("aVertexPanorama", programPanorama, "aVertex", 3, panoramaVertBuffer)
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0)
      //*/
    }

		// Dirt background
		use2d()
		let aspect = width / height
		let stack = height / 96
		let bright = 0.4
		if (dirtBuffer) {
			gl.deleteBuffer(dirtBuffer)
		}
		dirtBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, dirtBuffer)
		let bgCoords = new Float32Array([
			-1, -1, 0, stack, bright,
			1, -1, stack * aspect, stack, bright,
			1, 1, stack * aspect, 0, bright,
			-1, 1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 1)
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		let pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		dirtbg = ctx.createImageData(width, height)
		dirtbg.data.set(pixels)
    
    // Netherrack background
		bright = 0.4
		if (netherBuffer) {
			gl.deleteBuffer(netherBuffer)
		}
		netherBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, netherBuffer)
		bgCoords = new Float32Array([
			-1, -1, 0, stack, bright,
			1, -1, stack * aspect, stack, bright,
			1, 1, stack * aspect, 0, bright,
			-1, 1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 2) //netherrack textures uses TEXTURE2 so the number is 2
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		netherbg = ctx.createImageData(width, height)
		netherbg.data.set(pixels)
	}
	function initPlayer() {
		p = new Camera()
		p.speed = 0.075
		p.velocity = new PVector(0, 0, 0)
		p.pos = new Float32Array(3)
		p.sprintSpeed = 1.5
		p.flySpeed = 2.5
		p.x = 8
		p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
		p.z = 8
		p.previousX = 8
		p.previousY = 70
		p.previousZ = 8
		p.w = 3 / 8
		p.bottomH = 1.62
		p.topH = 0.18
		p.onGround = false
		p.jumpSpeed = 0.3
		p.sprinting = false
		p.maxYVelocity = 1.5
		p.gravityStength = -0.032
		p.lastUpdate = performance.now()
		p.lastBreak = Date.now()
		p.lastPlace = Date.now()
		p.lastJump = Date.now()
		p.autoBreak = false
    p.autoBuild = false
		p.flying = false
		p.sneaking = false
		p.spectator = false
    p.health = 20
    p.oxygen = 20
    p.food = 20
    p.foodSaturation = 5
    p.foodTimer = 0
    p.foodExhaustion = 0
    p.foodJitter = 0
    p.eatStart = 0
    p.eating = false
    p.lastY = 0 //y the last time it touched the ground
    p.character = new Character(1)
    p.thirdPerson = false
		
		win.player = p
		win.p2 = p2
	}
  function respawn(){
    let spawn = world.spawnPoint

    p.x = spawn.x
    p.z = spawn.z
    /*p.y = 0
      while(world.getBlock(0, p.y, 0)){
        p.y ++;
        if(p.y > maxHeight) break;
      }*/
    p.y = spawn.y

    p.health = 20
    p.oxygen = 20
    witherEffect = 0
    harmEffect = 0
    healEffect = 0
    p.foodSaturation = 5
    p.foodTimer = 0
    p.foodExhaustion = 0
    p.food = 20
    freezeEffect = 0
    dieMessage = username+" died because \\_()_/"
  }
	function initWorldsMenu() {
		while (window.worlds.firstChild) {
			window.worlds.removeChild(window.worlds.firstChild)
		}
		selectedWorld = 0
		window.boxCenterTop.value = ""

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		function addWorld(name, version, size, id, edited, thumbnail) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
      div.innerHTML = "<img class='thumbnail'"+(thumbnail ? (" src='" + thumbnail + "'") : "")+"><div class='thumbnailHover'></div>"
			div.innerHTML += "<strong>" + Messages.format(name) + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
			div.innerHTML += `${size.toLocaleString()} bytes used`
			
			window.worlds.appendChild(div)
		}

		worlds = {}
		if (loadString) {
			try {
				let tempWorld = new World()
				tempWorld.loadSave(loadString)
				let now = Date.now()
				addWorld(`${tempWorld.name} (Pre-loaded)`, tempWorld.version, loadString.length, now)
				worlds[now] = {
					code: loadString,
					id: now
				}
			}
			catch(e) {
				console.log("Unable to load hardcoded save.")
				console.error(e)
			}
		}
		loadFromDB().then(res => {
			if(res && res.length) {
				let index = res.findIndex(obj => obj.id === "settings")
				if (index >= 0) {
					Object.assign(settings, res[index].data) // Stored data overrides any hardcoded settings
					p.FOV(settings.fov)
					res.splice(index, 1)
				}
			}
			
			if (res && res.length) {
				res = res.map(d => d.data).filter(d => d && d.code).sort((a, b) => b.edited - a.edited)
				for (let data of res) {
					addWorld(data.name, data.version, (data.code.length + 60), data.id, data.edited, data.thumbnail)
					worlds[data.id] = data
				}
			}
			window.worlds.onclick = Button.draw
			window.boxCenterTop.onkeyup = Button.draw
		}).catch(e => console.error(e))

		superflat = false
		trees = true
		caves = true
    survival = false
	}
  var servers = {}
  async function initServersMenu() {
		while (window.servers.firstChild) {
			window.servers.removeChild(window.servers.firstChild)
		}
		selectedWorld = null

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		function addWorld(name, id, host, players) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
      div.innerHTML = "<div class='ping'>Pinging...</div>"
			div.innerHTML += "<strong>" + Messages.format(name)+ "</strong>" + br
      div.innerHTML += "Hosted by "+host + br
      div.innerHTML += players.length+" player"+(players.length===1 ? "" : "s")+" online"
			
      servers[id] = {
        id:id,
        name:name,
        host:host
      }
			window.servers.appendChild(div)
		}

		var worlds;
    await getWorlds(pings => {
      if(screen !== "multiplayer menu") return
      var elems = window.servers.querySelectorAll(".world")
      for(var i=0; i<elems.length; i++){
        var el = elems[i]
        var p = el.querySelector(".ping")
        var ping = pings[el.id]
        if(typeof ping === "number"){
          var y
          if(ping > 800) y = 32
          else if(ping > 600) y = 24
          else if(ping > 400) y = 16
          else if(ping > 200) y = 8
          else y = 0
          p.innerHTML = ping+" miliseconds<div class='img' style='background-position:0 "+y+"px;'></div>"
        }else if(ping === "timeout"){
          p.innerHTML = "Ping timed out"
        }else{
          p.innerHTML = "Error"
        }
      }
    }).then(r => worlds=r)
    if(worlds === "notLoggedIn") return changeScene("main menu")
    if(worlds === "offline") return window.servers.innerHTML = "<div class='message'>You are offline. Connect to the internet first.</div>"
    worlds.forEach(r => addWorld(r.name, r.id, r.host, r.players))
    
		window.servers.onclick = Button.draw

		superflat = false
		trees = true
		caves = true
    survival = false
	}
  let marketplace = {}; win.marketplaceData = null
  async function initMarketplace(){
    marketplaceData = await fetch("https://Minekhan.thingmaker.repl.co/maps.json")
    await new Promise((resolve, reject) => {
      marketplaceData.text().then(r => {marketplaceData = JSON.parse(r); resolve()})
    })
    
    marketplace = {}
    window.marketplace.innerHTML = ""
    const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}
    function addWorld(name, version, size, id, edited) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + Messages.format(name) + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
			div.innerHTML += `${size.toLocaleString()} bytes used`
			
			window.marketplace.appendChild(div)
      
      superflat = false
      trees = true
      caves = true
      survival = false
		}
    let tempWorld = new World()
    marketplaceData.forEach(data => {
      let loadString, mod
      if(typeof data === "object"){
        loadString = data.loadString
        mod = data.mod
      }else loadString = data
      
      tempWorld.loadSave(loadString)
		  let now = Date.now()
			addWorld(tempWorld.name, tempWorld.version, loadString.length, now)
			marketplace[now] = {
				code: loadString,
				id: now,
        name: tempWorld.name,
        version: tempWorld.version,
        mod: mod,
			}
    })
    window.marketplace.onclick = Button.draw
  }
  function saveFromMarketplace(){
    let save = marketplace[selectedWorld]
    saveToDB(save.id, {
			id: save.id,
			edited: Date.now(),
			name: save.name,
			version: save.version,
			code: save.code,
      mod: save.mod
		})
    initWorldsMenu()
    changeScene("loadsave menu")
  }
  
  var sounds = {
    click: "click.ogg",
    damage: {
      bigfall: "damage/fallbig.ogg",
      smallfall: "damage/fallsmall.ogg",
      hit1: "damage/hit1.ogg",
      hit2: "damage/hit2.ogg",
      hit3: "damage/hit3.ogg",
      drown1: "damage/drown1.ogg",
      drown2: "damage/drown2.ogg",
      drown3: "damage/drown3.ogg",
      drown4: "damage/drown4.ogg",
      freeze1: "damage/freeze1.ogg",
      freeze2: "damage/freeze2.ogg",
      freeze3: "damage/freeze3.ogg",
      freeze4: "damage/freeze4.ogg",
      freeze5: "damage/freeze5.ogg"
    },
    block: {
      grass: {
        dig1: "grass/dig1.ogg",
        dig2: "grass/dig2.ogg",
        dig3: "grass/dig3.ogg",
        dig4: "grass/dig4.ogg",
        step1: "grass/step1.ogg",
        step2: "grass/step2.ogg",
        step3: "grass/step3.ogg",
        step4: "grass/step4.ogg",
        step5: "grass/step5.ogg",
        step6: "grass/step6.ogg",
      },
      stone: {
        dig1: "stone/dig1.ogg",
        dig2: "stone/dig2.ogg",
        dig3: "stone/dig3.ogg",
        dig4: "stone/dig4.ogg",
        step1: "stone/step1.ogg",
        step2: "stone/step2.ogg",
        step3: "stone/step3.ogg",
        step4: "stone/step4.ogg",
        step5: "stone/step5.ogg",
        step6: "stone/step6.ogg",
      },
      gravel: {
        dig1: "gravel/dig1.ogg",
        dig2: "gravel/dig2.ogg",
        dig3: "gravel/dig3.ogg",
        dig4: "gravel/dig4.ogg",
        step1: "gravel/step1.ogg",
        step2: "gravel/step2.ogg",
        step3: "gravel/step3.ogg",
        step4: "gravel/step4.ogg",
      },
      sand: {
        dig1: "sand/dig1.ogg",
        dig2: "sand/dig2.ogg",
        dig3: "sand/dig3.ogg",
        dig4: "sand/dig4.ogg",
        step1: "sand/step1.ogg",
        step2: "sand/step2.ogg",
        step3: "sand/step3.ogg",
        step4: "sand/step4.ogg",
        step5: "sand/step5.ogg",
      },
      basalt: {
        dig1: "basalt/dig1.ogg",
        dig2: "basalt/dig2.ogg",
        dig3: "basalt/dig3.ogg",
        dig4: "basalt/dig4.ogg",
        dig5: "basalt/dig5.ogg",
        step1: "basalt/step1.ogg",
        step2: "basalt/step2.ogg",
        step3: "basalt/step3.ogg",
        step4: "basalt/step4.ogg",
        step5: "basalt/step5.ogg",
        step6: "basalt/step6.ogg",
      },
      chain: {
        dig1: "chain/dig1.ogg",
        dig2: "chain/dig2.ogg",
        dig3: "chain/dig3.ogg",
        dig4: "chain/dig4.ogg",
        step1: "chain/step1.ogg",
        step2: "chain/step2.ogg",
        step3: "chain/step3.ogg",
        step4: "chain/step4.ogg",
        step5: "chain/step5.ogg",
        step6: "chain/step6.ogg",
      },
      cloth: {
        dig1: "cloth/dig1.ogg",
        dig2: "cloth/dig2.ogg",
        dig3: "cloth/dig3.ogg",
        dig4: "cloth/dig4.ogg",
        step1: "cloth/step1.ogg",
        step2: "cloth/step2.ogg",
        step3: "cloth/step3.ogg",
        step4: "cloth/step4.ogg",
      },
      fungus: {
        dig1: "fungus/dig1.ogg",
        dig2: "fungus/dig2.ogg",
        dig3: "fungus/dig3.ogg",
        dig4: "fungus/dig4.ogg",
        dig5: "fungus/dig3.ogg",
        dig6: "fungus/dig4.ogg",
      },
      glass: {
        dig1: "glass/dig1.ogg",
        dig2: "glass/dig2.ogg",
        dig3: "glass/dig3.ogg",
      },
      lantern: {
        dig1: "lantern/dig1.ogg",
        dig2: "lantern/dig2.ogg",
        dig3: "lantern/dig3.ogg",
        dig4: "lantern/dig4.ogg",
        dig5: "lantern/dig5.ogg",
        dig6: "lantern/dig6.ogg",
        place1: "lantern/place1.ogg",
        place2: "lantern/place2.ogg",
        place3: "lantern/place3.ogg",
        place4: "lantern/place4.ogg",
        place5: "lantern/place5.ogg",
        place6: "lantern/place6.ogg",
      },
      nether_bricks: {
        dig1: "nether_bricks/dig1.ogg",
        dig2: "nether_bricks/dig2.ogg",
        dig3: "nether_bricks/dig3.ogg",
        dig4: "nether_bricks/dig4.ogg",
        dig5: "nether_bricks/dig5.ogg",
        dig6: "nether_bricks/dig6.ogg",
        step1: "nether_bricks/step1.ogg",
        step2: "nether_bricks/step2.ogg",
        step3: "nether_bricks/step3.ogg",
        step4: "nether_bricks/step4.ogg",
        step5: "nether_bricks/step5.ogg",
        step6: "nether_bricks/step6.ogg",
      },
      nether_ore: {
        dig1: "nether_ore/dig1.ogg",
        dig2: "nether_ore/dig2.ogg",
        dig3: "nether_ore/dig3.ogg",
        dig4: "nether_ore/dig4.ogg",
        step1: "nether_ore/step1.ogg",
        step2: "nether_ore/step2.ogg",
        step3: "nether_ore/step3.ogg",
        step4: "nether_ore/step4.ogg",
        step5: "nether_ore/step5.ogg",
      },
      nether_sprouts: {
        dig1: "nether_sprouts/dig1.ogg",
        dig2: "nether_sprouts/dig2.ogg",
        dig3: "nether_sprouts/dig3.ogg",
        dig4: "nether_sprouts/dig4.ogg",
        step1: "nether_sprouts/step1.ogg",
        step2: "nether_sprouts/step2.ogg",
        step3: "nether_sprouts/step3.ogg",
        step4: "nether_sprouts/step4.ogg",
        step5: "nether_sprouts/step5.ogg",
      },
      netherite: {
        dig1: "netherite/dig1.ogg",
        dig2: "netherite/dig2.ogg",
        dig3: "netherite/dig3.ogg",
        dig4: "netherite/dig4.ogg",
        step1: "netherite/step1.ogg",
        step2: "netherite/step2.ogg",
        step3: "netherite/step3.ogg",
        step4: "netherite/step4.ogg",
        step5: "netherite/step5.ogg",
        step6: "netherite/step6.ogg",
      },
      netherrack: {
        dig1: "netherrack/dig1.ogg",
        dig2: "netherrack/dig2.ogg",
        dig3: "netherrack/dig3.ogg",
        dig4: "netherrack/dig4.ogg",
        dig5: "netherrack/dig5.ogg",
        dig6: "netherrack/dig6.ogg",
        step1: "netherrack/step1.ogg",
        step2: "netherrack/step2.ogg",
        step3: "netherrack/step3.ogg",
        step4: "netherrack/step4.ogg",
        step5: "netherrack/step5.ogg",
        step6: "netherrack/step6.ogg",
      },
      netherwart: {
        dig1: "netherwart/dig1.ogg",
        dig2: "netherwart/dig2.ogg",
        dig3: "netherwart/dig3.ogg",
        dig4: "netherwart/dig4.ogg",
        dig5: "netherwart/dig5.ogg",
        dig6: "netherwart/dig6.ogg",
        step1: "netherwart/step1.ogg",
        step2: "netherwart/step2.ogg",
        step3: "netherwart/step3.ogg",
        step4: "netherwart/step4.ogg",
        step5: "netherwart/step5.ogg",
      },
      nylium: {
        dig1: "nylium/dig1.ogg",
        dig2: "nylium/dig2.ogg",
        dig3: "nylium/dig3.ogg",
        dig4: "nylium/dig4.ogg",
        dig5: "nylium/dig5.ogg",
        dig6: "nylium/dig6.ogg",
        step1: "nylium/step1.ogg",
        step2: "nylium/step2.ogg",
        step3: "nylium/step3.ogg",
        step4: "nylium/step4.ogg",
        step5: "nylium/step5.ogg",
        step6: "nylium/step6.ogg",
      },
      roots: {
        dig1: "roots/dig1.ogg",
        dig2: "roots/dig2.ogg",
        dig3: "roots/dig3.ogg",
        dig4: "roots/dig4.ogg",
        dig5: "roots/dig5.ogg",
        dig6: "roots/dig6.ogg",
        step1: "roots/step1.ogg",
        step2: "roots/step2.ogg",
        step3: "roots/step3.ogg",
        step4: "roots/step4.ogg",
        step5: "roots/step5.ogg",
      },
      shroomlight: {
        dig1: "shroomlight/dig1.ogg",
        dig2: "shroomlight/dig2.ogg",
        dig3: "shroomlight/dig3.ogg",
        dig4: "shroomlight/dig4.ogg",
        dig5: "shroomlight/dig5.ogg",
        step1: "shroomlight/step1.ogg",
        step2: "shroomlight/step2.ogg",
        step3: "shroomlight/step3.ogg",
        step4: "shroomlight/step4.ogg",
        step5: "shroomlight/step5.ogg",
        step6: "shroomlight/step6.ogg",
      },
      soul_sand: {
        dig1: "soul_sand/dig1.ogg",
        dig2: "soul_sand/dig2.ogg",
        dig3: "soul_sand/dig3.ogg",
        dig4: "soul_sand/dig4.ogg",
        dig5: "soul_sand/dig5.ogg",
        dig6: "soul_sand/dig6.ogg",
        dig7: "soul_sand/dig7.ogg",
        dig8: "soul_sand/dig8.ogg",
        dig9: "soul_sand/dig9.ogg",
        step1: "soul_sand/step1.ogg",
        step2: "soul_sand/step2.ogg",
        step3: "soul_sand/step3.ogg",
        step4: "soul_sand/step4.ogg",
        step5: "soul_sand/step5.ogg",
      },
      stem: {
        dig1: "stem/dig1.ogg",
        dig2: "stem/dig2.ogg",
        dig3: "stem/dig3.ogg",
        dig4: "stem/dig4.ogg",
        dig5: "stem/dig5.ogg",
        dig6: "stem/dig6.ogg",
        step1: "stem/step1.ogg",
        step2: "stem/step2.ogg",
        step3: "stem/step3.ogg",
        step4: "stem/step4.ogg",
        step5: "stem/step5.ogg",
        step6: "stem/step6.ogg",
      },
      wood: {
        dig1: "wood/dig1.ogg",
        dig2: "wood/dig2.ogg",
        dig3: "wood/dig3.ogg",
        dig4: "wood/dig4.ogg",
        step1: "wood/step1.ogg",
        step2: "wood/step2.ogg",
        step3: "wood/step3.ogg",
        step4: "wood/step4.ogg",
        step5: "wood/step5.ogg",
        step6: "wood/step6.ogg",
      },
      anvil: {
        land: "random/anvil_land.ogg"
      },
      amethyst: {
        dig1: "amethyst/break1.ogg",
        dig2: "amethyst/break2.ogg",
        dig3: "amethyst/break3.ogg",
        dig4: "amethyst/break4.ogg",
        place1: "amethyst/place1.ogg",
        place2: "amethyst/place2.ogg",
        place3: "amethyst/place3.ogg",
        place4: "amethyst/place4.ogg",
        step1: "amethyst/step1.ogg",
        step2: "amethyst/step2.ogg",
        step3: "amethyst/step3.ogg",
        step4: "amethyst/step4.ogg",
        step5: "amethyst/step5.ogg",
        step6: "amethyst/step6.ogg",
        step7: "amethyst/step7.ogg",
        step8: "amethyst/step8.ogg",
        step9: "amethyst/step9.ogg",
        step10: "amethyst/step10.ogg",
        step11: "amethyst/step11.ogg",
        step12: "amethyst/step12.ogg",
        step13: "amethyst/step13.ogg",
        step14: "amethyst/step14.ogg",
      },
      amethyst_cluster: {
        dig1: "amethyst_cluster/break1.ogg",
        dig2: "amethyst_cluster/break2.ogg",
        dig3: "amethyst_cluster/break3.ogg",
        dig4: "amethyst_cluster/break4.ogg",
        place1: "amethyst_cluster/place1.ogg",
        place2: "amethyst_cluster/place2.ogg",
        place3: "amethyst_cluster/place3.ogg",
        place4: "amethyst_cluster/place4.ogg",
      },
    },
    entity: {
      generic: {
        explode1: "random/explode1.ogg",
        explode2: "random/explode2.ogg",
        explode3: "random/explode3.ogg",
        explode4: "random/explode4.ogg",
      },
      tnt: {
        fuse: "random/fuse.ogg"
      },
      item: {
        pickup: "random/plop.ogg",
        break: "random/break.ogg"
      },
    },
    liquid:{
      enter: "liquid/enter.ogg",
      exit: "liquid/exit.ogg",
      splash: "liquid/splash.ogg"
    },
    eat: {
      1: "random/eat1.ogg",
      2: "random/eat2.ogg",
      3: "random/eat3.ogg"
    },
  }
  var soundVolumes = {
    
  }
  win.sounds = sounds
  function loadSoundBuffer(url){
    return new Promise((resolve, reject) => {
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.responseType = 'arraybuffer';
      request.onerror = reject

      request.onload = function() {
        audioCtx.decodeAudioData(request.response, function(buffer) {
          resolve(buffer)
        }, reject);
      }
      request.send();
    })
  }
  async function initAudioCtx(){
    try{
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
    }catch(e) {
      alert('Web Audio API is not supported in this browser');
      return
    }
    
    async function loadSoundsObj(obj){
      for(var i in obj){
        if(typeof obj[i] === "object"){
          loadSoundsObj(obj[i])
        }else{
          var url = "https://data.thingmaker.repl.co/sounds/"+obj[i]
          await loadSoundBuffer(url).then(buffer => {
            obj[i] = buffer
            loadDone()
          }).catch(() => {
            loadDone()
          })
        }
      }
    }
    loadSoundsObj(sounds)
  }
  function playSound(name, start, volume){ //from https://www.html5rocks.com/en/tutorials/webaudio/intro/
    if(!soundOn) return
    var sound
    var soundVol
    if(name.includes(".")){
      sound = sounds
      soundVol = soundVolumes
      name = name.split(".")
      for(var i=0; i<name.length; i++){
        var n = name[i]
        if(sound[n]){
          sound = sound[n]
        }else return
        if(soundVol[n]){soundVol = soundVol[n]}
      }
    }else{
      sound = sounds[name]
      soundVol = soundVolumes[name]
    }
    if(!volume && volume !== 0) volume = 1
    if((typeof soundVol === "object") || (!soundVol && soundVol !== 0)) soundVol = 1
    volume *= soundVol
    var buffer = sound
    if(audioCtx && (typeof buffer !== "string") && volume > 0){
      var source = audioCtx.createBufferSource();
      source.buffer = buffer;
      if( (!(volume || volume === 0)) || volume === 1){
        source.connect(audioCtx.destination);
      }else{
        var gainNode = audioCtx.createGain();
        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.value = volume;
      }
      source.start(start ? audioCtx.currentTime + (start/1000) : 0);
    }
  }
  win.playSound = playSound
  function blockSound(blockID, type, x,y,z){
    var block = blockData[blockID]
    var volume = posSound(x,y,z)
    
    var sound
    switch(type){
      case "place":
        sound = block.placeSound || block.digSound
        break;
      case "dig":
        sound = block.digSound
        break;
      case "step":
        sound = block.stepSound
        break;
      case "breaking":
        sound = block.stepSound
        break;
      case "land":
        sound = block.landSound || block.digSound
    }
    if(typeof sound === "function") return sound()
    if(Array.isArray(sound)){
      sound = sound[Math.floor(Math.random()*sound.length)]
    }
    if(sound){
      playSound(sound, 0, volume)
    }
  }
  win.blockSound = blockSound
  function hitSound(){
    var i = Math.ceil(Math.random()*3)
    playSound("damage.hit"+i)
  }
  function drownHurtSound(){
    var i = Math.ceil(Math.random()*4)
    playSound("damage.drown"+i)
  }
  function freezeHurtSound(){
    var i = Math.ceil(Math.random()*5)
    playSound("damage.freeze"+i)
  }
  win.hitSound = hitSound
  var explodeSounds = ["entity.generic.explode1", "entity.generic.explode2", "entity.generic.explode3", "entity.generic.explode4"]
  function explodeSound(x,y,z){
    var sound = explodeSounds[Math.floor(Math.random()*explodeSounds.length)]
    playSound(sound, 0, posSound(x,y,z))
  }
  win.explodeSound = explodeSound
  function posSound(x,y,z){
    var volume = 1
    if((x || x===0) && (y || y===0) && (z || z===0)){
      var falloff = volume > 16 ? 16*volume : 16
      var dist = dist3(x,y,z, p2.x, p2.y, p2.z)
      volume = dist > falloff ? volume - ((dist - falloff) / 10) : volume
      if(volume < 0) volume = 0
    }
    return volume
  }
  function eatSound(){
    var i = Math.ceil(Math.random()*3)
    playSound("eat."+i)
  }
  
  let maxStartLoad = 0, loaded = 0
  win.allLoaded = false
  function findObjValueAmount(obj){
    for(var i in obj){
      if(typeof obj[i] === "object"){
        findObjValueAmount(obj[i])
      }else maxStartLoad ++
    }
  }
  findObjValueAmount(sounds)
  for(var image in images) maxStartLoad ++
    
  loadProg.innerHTML = `0% 0/${maxStartLoad}`
  function loadDone(){
    loaded ++
    let percent = Math.floor(loaded * 100 / maxStartLoad)
    loadProg.innerHTML = `${percent}% ${loaded}/${maxStartLoad}`
    loadBar.style.width = percent+"%"
    if(loaded === maxStartLoad){
      loader.classList.add("hidden")
      allLoaded = true
    }
  }
  
  function createNewWorld(){
      dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			world.id = Date.now()
			let name = boxCenterTop.value || "World"
			let number = ""
			while(true) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				} else {
					name = name + number
					break
				}
			}
			world.name = name.replace(/;/g, "\u037e")
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)

      if(survival) setHotbar([0,0,0,0,0,0,0,0,0])
			changeScene("loading")
  }
  function playSelectedWorld(){
    dimensions = {
      overworld: new World(),
      nether: new World("nether")
    }
    world = dimensions.overworld

    let code
    let inv
    let surviv
    let mod
    let nether
    let ent
    if (!selectedWorld) {
      code = boxCenterTop.value
    } else {
      let data = worlds[selectedWorld]
      if (data) {
        code = data.code
        world.id = data.id
        world.edited = data.edited
        inv = data.inv
        surviv = data.surviv
        nether = data.nether
        ent = data.ent
        if(data.achievments) achievments = data.achievments
        playersInv = data.playersInv || {}
        try{
          world.mod = data.mod
          mod = Object.constructor("return "+data.mod)()
        }catch(e){console.log("error loading mod: "+e)}
      }
    }

    if (code) {
      try {
        world.loadSave(code)
        world.id = world.id || Date.now()
      }
      catch(e) {
        alert("Unable to load save")
        return
      }
    }
    if (nether) {
      let world = dimensions.nether
      try {
        world.loadSave(nether)
        world.id = world.id || Date.now()
      }
      catch(e) {
        alert("Unable to load save")
        return
      }
    }
    if(inv){
      world.loadInv(inv)
    }else if(survival) setHotbar([0,0,0,0,0,0,0,0,0])
    if(surviv) world.loadSurvivStr(surviv)
    if(ent){
      for(var i=0; i<ent.length; i++){
        let world = getWorld(ent[i].dimension)
        world.posEntity(ent[i])
      }
    }
    if(mod){
      try{mod()}catch(e){console.log(e)}
    }
    
    changeScene("loading")
  }
  
  function setupHelp(){
    //Setup images
    var divs = document.querySelectorAll("div[img]")
    for(var i=0; i<divs.length; i++){
      var d = divs[i]
      d.style.backgroundSize = "100%"
      d.style.imageRendering = "pixelated"
      d.style.display = "inline-block"
      d.style.verticalAlign = "middle"
      var img = d.getAttribute("img")
      var w, h
      if(img === "heart"){
        w = h = 18
        d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAXElEQVQoU3XQQRKAIAiF4Z97ua8j19572UCSTytWjHwCgzGi9dQAzfEHj/YrwOJXgFqhFGl8pw4GepUXdADbBzqBvXeKnVaYwE0uPkEFuZcOio4+QqY8J5igAi9cnpgXB7uKmTQAAAAASUVORK5CYII=)"
      }else if(img === "halfHeart"){
        w = h = 18
        d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAY0lEQVQoU4WOwQ3AMAgDzS50i/zbkTtAxmCXVLiBoKhS+YDMYSxYNeYoAOoMF7xGVVWVopl5E14R6B1ojctjQgEuqPz9hG4A5w/ETBUMp5opPBJ0KAAmL1/S8XrF3O0Qwf34AVFaJQc+FQukAAAAAElFTkSuQmCC)"
      }else if(img === "deadHeart"){
        w = h = 18
        d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAT0lEQVQoU62OwQ3AMAwCz1N4//E8RSqjuiVRn/ULocMQvLduGYBr2uhbmSlRVbgGQqkx7esjO/QvtG3yyq6aTeNv2wYQdYwV6MAXpOozfAGB1SIH1uYKrgAAAABJRU5ErkJggg==)"
      }
      var a = parseInt(d.getAttribute("amount"))
      if(a){
        d.style.backgroundSize = (100/a)+"% 100%"
        d.style.width = (w * a)+"px"
      }else d.style.width = w+"px"
      d.style.height = h+"px"
    }

    //Setup collapsibles
    var coll = document.getElementsByClassName("collapsible");
    for (var i = 0; i < coll.length; i++) {
      var c = coll[i]
      var title = document.createElement("div")
      title.classList.add("title")
      title.innerHTML = c.getAttribute("title")
      var content = document.createElement("div")
      content.classList.add("content")
      content.innerHTML = c.innerHTML

      c.innerHTML = ""
      c.appendChild(title)
      c.appendChild(content)

      content.style.maxHeight = "0px"
      title.addEventListener("click", function() {
        var content = this.nextElementSibling
        this.classList.toggle("active")
        if (content.style.maxHeight !== "0px"){
          content.style.maxHeight = "0px";
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
        }
      })
    }
    
    //Set recipes collapsible
    var recipes = document.querySelector("#recipes .content")
    var size = inventory.size
    var s2 = size/2
    var icons = {}
    var ix = -s2, iy = s2
    function addIcon(id){
      ix += size
      if(ix > gl.canvas.width - s2){
        ix = s2
        iy += size
      }
      drawIcon(ix, iy, id)
      icons[id] = [ix,iy]
    }
    use3d()
    FOV(90)
    gl.clearColor(0, 0, 0, 0)
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
    var ic = document.createElement("canvas")
    ic.width = ic.height = size
    var ictx = ic.getContext("2d")
    var rhtml = ""
    for(var c in crafts){
      var r = crafts[c]
      var arr = c.split(",")
      rhtml += "<div class='recipe'>"
      rhtml += r.name+"<br><br>"
      rhtml += "<div class='grid'>"
      //Grid
      for(var a=0; a<arr.length; a++){
        var id = parseInt(arr[a])
        if(id) {
          if(!icons[id]){
            addIcon(id)
            var xy = icons[id]
            ictx.clearRect(0,0,size,size)
            ictx.drawImage(gl.canvas, xy[0]-s2,xy[1]-s2, size,size, 0,0,size,size)
            icons[id] = ic.toDataURL()
          }
          var img = icons[id]
          rhtml += "<img src='"+img+"' style='width:"+size+"px;height:"+size+"px;' title='"+blockData[id].name+"'>"
        }else{
          rhtml += "<div style='width:"+size+"px;height:"+size+"px;'></div>"
        }
        if(a%3===2 && a !== 8){
          rhtml += "<br>"
        }
      }
      rhtml += "</div>"
      //Result
      var id = r.id
      if(!icons[id]){
        addIcon(id)
        var xy = icons[id]
        ictx.clearRect(0,0,size,size)
        ictx.drawImage(gl.canvas, xy[0]-s2,xy[1]-s2, size,size, 0,0,size,size)
        icons[id] = ic.toDataURL()
      }
      var img = icons[id]
      rhtml += "<br><div class='result' style='margin-left:"+size+"px;margin-top:"+size+"px;'>"
      rhtml += "<img src='"+img+"' style='width:"+size+"px;height:"+size+"px;' title='"+blockData[id].name+"'>"
      rhtml += "<div class='number'>"+r.amount+"</div>"
      rhtml += "</div></div>"
    }
    recipes.innerHTML = rhtml
  }
	
	function initEverything() {
		console.log("Initializing world.")

		setSeed(Math.random() * 2000000000 | 0)
    console.log("worldSeed "+worldSeed)

    win.islandGenerator = new Generator();
    
		generatedChunks = 0

    crack.shape = shapes.cube

		initWebgl()
    constVersion(version)
    initPlayer()
    fetch("https://server.thingmaker.repl.co/getuser",{credentials:'include'}).then(r => r.text()).then(r => {
      username = r || "Steve"
      p.character.changeBlock(abs(r.hashCode()) % 80 + 1)
    })

		message.innerHTML = ".>a/<etisbew ym>'oc.lper.rekamgniht.www//:sptth'=ferh a< tuo kcehc oslA>rb<>a/<etisbew s'draliW no nahKeniM ot kniL>'nahkenim/nuf.dralliw//:sptth'=ferh a<>rb<.>a<etisbew s'dralliW>'nuf.dralliw//:sptth'=ferh a< tuo kcehc ot>rb<erus eb ,siht ekil uoy fI>rb<.dralliW yb >a/<nahKeniM>\"wen_\"=tegrat \"8676731005517465/cm/sc/gro.ymedacanahk.www//:sptth\"=ferh a< fo>rb<ffo-nips a si margorp sihT".split("").reverse().join("")
    
    crack.entity = new crackEntity("crack1",0,0,0)
    for(var i=0; i<crack.length; i++){crack.entity.cacheTexture(crack[i])}

		initBackgrounds()
		
    initEntitys()
    
		drawScreens[screen]()
		Button.draw()
		Slider.draw()

		p.FOV(settings.fov)
		initWorldsMenu()
    initMarketplace()
		initButtons()
    
    initAudioCtx()
    
    setupHelp()
    
    // See if a user followed a link here.
		if (urlParams.has("target")) {
			changeScene("multiplayer menu")
			initMultiplayer(urlParams.get("target"))
		}
	}

	// Define all the scene draw functions
  let clear,dirt,nether
	(function() {
    var splashs = [
      "Multiplayer!",
      "Survival!",
      "Flowers? Make a garden!",
      "Also go to my website:\nwww.thingmaker.repl.co",
      "Nether!",
      "Can't break bedrock.",
      "Chat with a slash!",
      "Watch out from\nthe falling sand!",
      "Hard Parkour!",
      "MineKhan is on youtube!",
      "Original by Willard.",
      "Log => 4 planks\n2 Planks => 4 sticks\n1 stick + 1 coal\n=\ntorch",
      "Annoying cactus!",
      "Nice looking flowers.",
      "I like watermelon.",
      "Have you played\nMinecraft?",
      "So, you read splash text.",
      document.documentElement.outerHTML.split("\n").length+" lines of code.",
      "Island world type\nhas a volcano.",
      "Have you realized\npunching wood\nhurts your hand?",
      "Don't make a tnt\ncube over\nsomeone's mansion.",
      "Awesome!",
      "Fun!",
      "Build!",
      "Mine!",
      "Craft!",
      "Would you like a potion of fun?",
      "Falling anvils are\neven more annoying\nthan sand!",
      "No tnt!!!",
      "Don't mess\naround with\nuranium!!!",
      "Why does my\nhouse have a\nhole in the\nroof???",
      "www.thingmaker.repl.co",
      "1C2o3l4o5r6m7a8t9iac",
      "Using WebGL!",
      "Who has awesome hair?",
      "Supercalifragilisticexpialidocious!",
      "Really really fun!",
      "Not kidding",
      "Punch diamonds!",
      "Very long useless text,\nglorbouirewsoytuderkoilsykrojeticfilistikmensuiklit",
      "Play for 10 hours!",
      "Also try VVVVVV!",
      "Also try Super Meat Boy!",
      "Also try Terraria!",
      "Also try Mount And Blade!",
      "Also try Project Zomboid!",
      "Also try World of Goo!",
      "Also try Limbo!",
      "Also try Pixeljunk Shooter!",
      "Also try Braid!",
      "Why are you reading this???",
      "Really. You read\n splash text.",
      "Umm... Why are\nthe trees floating?",
      "No robots",
      "Kick 'em up!",
      "Gotta eat some soup!",
      "Disgusting soup.",
      "This is a very\ncool splash.",
      "!sdrawkcaB", "Hey, you!", "Can render 400,000 blocks!", "Updates incoming", "No hidden fees!", "Hippopotamus!", "Gotta catch them all!", "Not greyscale", "qwertyuiopasdfghjklzxcvbnm", "Nope.", "Sometimes, having a giant monitor is really helpful.", "igpay atinlay", "Five more minutes?", "Also try GameChiefCraft", "Also try Ultimate Platformer", "What's the opposite of right? Wrong!", "Feeling snackish? I know the feeling.", "Hey look! It's invisible!", "LG logo is pacman!", "Don't mine bedrock", "Cross-platform, if you build the platform"
    ]
    let splash = ""
    function rdmSplash(){
      splash = splashs[Math.floor(Math.random()*splashs.length)]
    }
    win.rdmSplash = rdmSplash
    win.setSplash = function(s){
      splash = splashs[s]
    }
    rdmSplash()
    setInterval(() => rdmSplash(), 60000)
		function drawTitle() {
			let title = "MINEKHAN"
      let titleWidth = images.minekhan.width*1.6
      let titleHeight = images.minekhan.height*1.6
			let subtext = "JAVASCRIPT EDITION"
			let font = "VT323,monospace"
			strokeWeight(1)
			ctx.textAlign = 'center'

			/*
      ctx.font = "bold 110px " + font
			fill(/*30*-/70)
			text(title, width / 2, 158)
			//fill(40)
			text(title, width / 2, 155)
			ctx.font = "bold 111px " + font
			//fill(50)
			text(title, width / 2, 152)
			//fill(70)
			text(title, width / 2, 150)
			//fill(90)
			ctx.font = "bold 112px " + font
			text(title, width / 2, 148)
			fill(110)
			text(title, width / 2, 145)*/
      ctx.drawImage(images.minekhan, width/2 - (titleWidth/2), 145 - titleHeight, titleWidth,titleHeight)

			ctx.font = "bold 32px " + font
			fill(50)
			text(subtext, width / 2-1, 180)
			text(subtext, width / 2+1, 180)
			text(subtext, width / 2, 179)
			text(subtext, width / 2, 181)
			ctx.font = "bold 32px " + font
			fill(150)
			text(subtext, width / 2, 180)
      
      fill(230,220,0)
			ctx.translate(width/2 + 280,170)
			ctx.rotate(-Math.PI/8);
      var s = (size/40)*6+25
			ctx.font = "bold "+s+"px " + font
			text(splash, 0,0, s)
			ctx.rotate(Math.PI/8);
			ctx.translate(-(width/2+280),-170)
		}
    clear = () => ctx.clearRect(0, 0, canvas.width, canvas.height)
    dirt = () => ctx.putImageData(dirtbg, 0, 0)
    nether = () => ctx.putImageData(netherbg, 0, 0)

    var size = 0
    var sizes = 0
    var sizess = 1
		drawScreens["main menu"] = () => {
      clear()
      sizes += sizess
      if((sizes > 5) || (sizes < -5)){
        sizess = -sizess
      }
      size += sizes
			drawTitle()
			fill(220)
			ctx.font = "18px VT323"
			ctx.textAlign = 'left'
			text("MineKhan " + version, 2, height - 2)
      ctx.textAlign = "right"
      text("Do not plagarize.", width - 2, height - 2)
		}

		drawScreens.play = () => {
      ctx2.clearRect(0,0,width,height)
      
      var now = Date.now()
      tick = false
      if(now - lastTick > 50){
        lastTick = now
        tick = true
      }
      
      p.rz = 0
      
      if(survival && p.y < 0){
        if(now-lastBlockHarm > 500){
          lastBlockHarm = now
          damage(4, username+" fell out of the world.")
        }
      }
      
      if(controlMap.place.pressed && holding && blockData[holding].edible && (blockData[holding].eatWhenFull||(!survival) ? true : p.food < 20)){
        var block = blockData[holding]
        if(p.eating){
          var time = now - p.eatStart
          if(now - eatSoundTimer > 250){
            eatSoundTimer = now
            eatSound()
          }
          if(time > 1610){
            p.eating = false
            p.food += block.food
            p.foodSaturation += block.saturation
            if(survival && inventory.hotbar[inventory.hotbarSlot]){
              inventory.hotbar[inventory.hotbarSlot].amount --;
              updateHUD = true
            }
          }
        }else{
          p.eating = true
          p.eatStart = now
        }
      }else if(p.eating) p.eating = false
      if(p.sneaking || p.eating){
        p.sprinting = false
				p.speed = 0.03
				p.bottomH = 1.32
      }else if(!p.sprinting){
        p.sneaking = false
				p.speed = 0.075
				p.bottomH = 1.62
      }
      
      for(var i=0; i<9; i++){
        if(inventory.hotbar[i].id && inventory.hotbar[i].amount < 1){
          inventory.hotbar[i] = 0
          holding = inventory.hotbar[inventory.hotbarSlot].id
          updateHUD = true
        }
        if(inventory.hotbar[i].id && inventory.hotbar[i].animation > 1){
          inventory.hotbar[i].animation -= 0.04
          if(inventory.hotbar[i].animation < 1) inventory.hotbar[i].animation = 1
          updateHUD = true
        }
        if(inventory.hotbar[i] && (blockData[inventory.hotbar[i].id].pickaxe || blockData[inventory.hotbar[i].id].sword || blockData[inventory.hotbar[i].id].shovel || blockData[inventory.hotbar[i].id].axe || blockData[inventory.hotbar[i].id].hoe)){
          if(inventory.hotbar[i].durability <= 0){
            inventory.hotbar[i] = 0
            holding = inventory.hotbar[inventory.hotbarSlot].id
            playSound("entity.item.break")
            updateHUD = true
          }else if(!inventory.hotbar[i].durability){
            inventory.hotbar[i].durability = blockData[inventory.hotbar[i].id].durability
          }
        }
      }
      
      if((now - attackCooldownStart) / 1000 * 20 > attackCooldownTime){
        if(attackCooldown !== 0) updateHUD = true
        attackCooldown = 0
      }else{
        let prog = (now - attackCooldownStart) / 1000 * 20
        attackCooldown = prog / attackCooldownTime
        updateHUD = true
      }
      
      standingOn = world.getBlock(p2.x,p2.y-2,p2.z)
      
			controls()
			runGravity()
      
      if(survival){
        cracks()
      }
      if(witherEffect>0){
        witherEffect --;
        if(survival && now-lastBlockHarm > witherTime){
          lastBlockHarm = now
          loseHealthEffect = 60
          damage(witherDamage, username+" got withered. Ew.")
        }
      }
      
      if(survival && tick){
        if(powder){
          freezeEffect ++
          if(freezeEffect > 140){
            freezeEffect = 140
            if(now - lastFreezeHealth > 2000 && survival){
              lastFreezeHealth = now
              loseHealthEffect = 60
              damage(1,username+" froze to death.", false, "freeze")
            }
          }else{
            lastFreezeHealth = now
            updateHUD = true
          }
        }else if(freezeEffect > 0){
          freezeEffect --
          updateHUD = true
        }
      }
      
      /*if(now - lastHeal > healTime) {
        lastHeal = now
        if(p.health < 20){
          p.health += 1
          healEffect = 40
          updateHUD = true
        }
      }*/
      
      if(survival){
        if(p.foodSaturation > p.food) p.foodSaturation = p.food
        /*if(p.food > 17 || p.food === 0){
          var timer = now - p.foodTimer
          if(timer >= 4000){
            p.foodTimer = now
            if(p.food === 0){
              p.health --
              harmEffect = 40
              hitSound()
              updateHUD = true
            }else if(p.foodSaturation > 0 && p.health < 20){
              p.health ++
              healEffect = 40
              updateHUD = true
            }
          }*/
          /*if((timer === 500 || timer === 0) && p.food >= 20 && p.health < 20 && p.foodExhaustion > 0){
            var heal = min(p.foodSaturation/6, 1)
            p.health += heal
            if(p.food > 18){
              p.foodExhaustion += heal*6
            }
            healEffect = 40
            updateHUD = true
          }
        }*/
        var healTimer = now-lastHeal
        if(p.health < 20){
          var heal
          if(p.foodSaturation > 0 && p.food === 20 && healTimer >= 500){
            heal = 1
          }else if(p.food >= 18 && healTimer >= 4000){
            heal = 1
          }
          if(heal){
            lastHeal = now
            p.health += heal
            healEffect = 40
            updateHUD = true
          }
          if(p.food < 18 && p.food > 0) lastHeal = now
        }
        if(p.health > 1 && p.food <= 0 && healTimer >= 4000){
          lastHeal = now
          damage(1, username+" starved to death.")
        }
        if(p.foodExhaustion >= 4){
          p.foodExhaustion = 0
          p.foodSaturation --
          if(p.foodSaturation <= 0){
            p.food --
          }
        }
        if(p.food > 20) p.food = 20
        if(p.food < 0) p.food = 0
        if(p.foodSaturation < 0) p.foodSaturation = 0
        
        if(tick){
          if(p.foodSaturation <= 0 || p.foodJitter > -1){
            p.foodJitter ++
            if(p.foodJitter > 10) p.foodJitter = -1
            updateHUD = true
          }else{
            p.foodJitter = -1
          }
        }
      }
      
      var blockHere = world.getBlock(p2.x, p2.y, p2.z)
      inWater = 0
      if(blockHere === blockIds.Water) inWater = 1
      if(blockHere === blockIds.Lava) inWater = 2
      
      var blockAtFeet = world.getBlock(p2.x, p2.y-1, p2.z)
      if(!p.flying && controlMap.jump.pressed && ((blockHere && blockData[blockHere].ladder) || (blockAtFeet && blockData[blockAtFeet].ladder))){
        p.velocity.y = 0
        p.y += 0.04
      }
      if(survival){
        if(liquid && blockHere === blockIds.Water){
          if(p.oxygen > 0){
            if(now - lastLoseOxygen > 1000){
              p.oxygen --
              lastLoseOxygen = now
              updateHUD = true
            }
          }else{
            if(now-lastBlockHarm > 500){
              lastBlockHarm = now
              damage(1, username+" drowned.",false, "drown")
            }
          }
        }else if(p.oxygen < 20 && now - lastGetOxygen > 300){
          lastGetOxygen = now
          p.oxygen = (Math.floor(p.oxygen/2)*2) + 2
          updateHUD = true
        }
      }
			if(p.health > 20) {
			  p.health = 20;
			}
      if(p.oxygen > 20) {
			  p.oxygen = 20;
			}
      
      if(harmEffect > 0){
        harmEffect --
        p.rz = max(harmEffect-20,0) / 200
        p.character.harmEffect = harmEffect
        updateHUD = true
      }
      if(healEffect > 0){
        healEffect --
        updateHUD = true
      }
      if(loseHealthEffect > 0){
        loseHealthEffect --
        updateHUD = true
      }
      
			resolveContactsAndUpdatePosition(now)

      if(p.health < 5 && tick) updateHUD = true //for hearts shaking
			if (updateHUD) {
				clear()
				gl.clearColor(0, 0, 0, 0)
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
				hud()
				ctx.drawImage(gl.canvas, 0, 0)
				updateHUD = false
				freezeFrame = false

				gl.clearColor(sky[0], sky[1], sky[2], 1.0)
			}
			defineWorld()
      
      if(harmEffect > 0){
        fill(255,0,0, harmEffect)
        ctx.fillRect(0,0,width,height)
      }
      if(portalEffect > 0){
        fill(255,0,255, portalEffect)
        ctx.fillRect(0,0,width,height)
        updateHUD = true
        portalEffect --
      }
      
      if(mouseDown && touchScreen){
			  ctx.beginPath()
        fill(255)
        strokeWeight(2)
        ellipse(pTouch.x, pTouch.y, 70,70)
        ctx.stroke()
        if(pTouch.digProg > 0){
          ctx.beginPath()
          let r = pTouch.digProg * 70
          ellipse(pTouch.x, pTouch.y, r,r)
          ctx.fill()
        }
        updateHUD=true
      }
      
      if(survival)ctx.drawImage(canvas2,0,0)
      
      if(p.health < 1){
        die()
        
        drawScreens.dead()
        Button.draw()
        Slider.draw()
      }
      
      if(titleOpacity > 0){
        titleOpacity --
        let alpha = titleOpacity/100
        ctx.font = "80px VT323"
        ctx.textAlign = "center"
        ctx.fillStyle = titleColor
        ctx.globalAlpha = alpha > 1 ? 1 : alpha
        text(title, width/2, height/2, 80)
        if(subtitle){
          ctx.font = "40px VT323"
          text(subtitle, width/2, height/2+50, 40)
        }
        ctx.globalAlpha = 1
        updateHUD = true
      }
      if(sideMessageTime > 0){
        sideMessageTime --
        var x
        var w = 200
        if(sideMessageTime > 540){
          x = 1 - ((sideMessageTime - 540) / 60)
        }else if(sideMessageTime > 60){
          x = 1
        }else{
          x = sideMessageTime / 60
        }
        x = width - (x * w)
        ctx.clearRect(width-w,0,w,50)
        ctx.fillStyle = "#223"
        ctx.fillRect(x, 0,w,50)
        ctx.textBaseline = "top"
        ctx.fillStyle = "white"
        ctx.font = "10px VT323"
        ctx.fillText(sideMessageTitle, x+5, 5, w-10)
        ctx.fillStyle = "#aaa"
        ctx.fillText(sideMessageContent, x+5, 20, w-10)
        ctx.textBaseline = "alphabetic"
      }
      if(inventory.showName > 0){
        inventory.showName -= 0.02
        updateHUD = true
      }
      
      if((controlMap.forward.pressed || controlMap.backward.pressed || controlMap.left.pressed || controlMap.right.pressed) && p.onGround){
        let limit = 500
        if(p.sprinting) limit = 350
        if(now - lastStepSound > limit){
          lastStepSound = now
          blockSound(standingOn, "step")
        }
      }
		}

    drawScreens.dead = () => {
      ctx.drawImage(gl.canvas, 0, 0)
      
      ctx.fillStyle = "rgba(255,0,0,50%)"
      ctx.fillRect(0,0,width,height)
      
      fill(0)
      ctx.font = "50px Arial"
      ctx.textAlign = "center"
      ctx.fillText("You died", width/2, 100)
      
      ctx.font = "20px Arial"
      ctx.fillText(dieMessage, width/2, 140)
    }
    
		drawScreens.loading = () => {
      world = dimensions.overworld
			// This is really stupid, but it basically works by teleporting the player around to each chunk I'd like to load.
			// If chunks loaded from a save aren't generated, they're deleted from the save, so this loads them all.
			let frameStart = win.performance.now()+1
			let sub = maxLoad - world.loadFrom.length - 9
            if (superflat === "island") {
                if (win.islandGenerator.stage < 10) {
                    if (!win.islandGenerator.seedSet) {
                        win.islandGenerator.SetSeed(noiseProfile.seed)
                    }
                    win.islandGenerator.Generate(frameStart);
                }   else {
                    let standing = true
        			if (world.loadFrom.length) {
        				let load = world.loadFrom[0]
        				p.x = load.x * 16
        				p.y = load.y * 16
        				p.z = load.z * 16
        				standing = false
        			} else {
        				p.x = p2.x
        				p.y = p2.y
        				p.z = p2.z
        
        				let cx = p.x >> 4
        				let cz = p.z >> 4
        
        				for (let x = cx - 1; x <= cx + 1; x++) {
        					for (let z = cz - 1; z <= cz + 1; z++) {
        						if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
        							standing = false
        						} else {
        							sub++
        						}
        					}
        				}
        			}
        
        			if (standing) {
        				play()
        				return
        			}
			        world.tick()
                }
            }   else {
                let standing = true
    			if (world.loadFrom.length) {
    				let load = world.loadFrom[0]
    				p.x = load.x * 16
    				p.y = load.y * 16
    				p.z = load.z * 16
    				standing = false
    			} else {
    				p.x = p2.x
    				p.y = p2.y
    				p.z = p2.z
    
    				let cx = p.x >> 4
    				let cz = p.z >> 4
    
    				for (let x = cx - 1; x <= cx + 1; x++) {
    					for (let z = cz - 1; z <= cz + 1; z++) {
    						if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
    							standing = false
    						} else {
    							sub++
    						}
    					}
    				}
    			}
    
    			if (standing) {
    				play()
    				return
    			}
		        world.tick()
          }

			let progress = Math.round( (superflat==="island"?50:100) * sub / maxLoad)
			if(superflat === "island")progress += Math.round((win.islandGenerator.stage/9.0+win.islandGenerator.h/win.islandGenerator.size*3/9)*50)
			
			dirt()
			fill(255)
			textSize(25)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
		}
    drawScreens.netherLoading = () => {
      world = dimensions.nether
			let frameStart = win.performance.now()+1
			let sub = maxLoad - world.loadFrom.length - 9
      let standing = true
      if (world.loadFrom.length) {
        let load = world.loadFrom[0]
        p.x = load.x * 16
        p.y = load.y * 16
        p.z = load.z * 16
        standing = false
      } else {
        p.x = p2.x
        p.y = p2.y
        p.z = p2.z

        let cx = p.x >> 4
        let cz = p.z >> 4

        for (let x = cx - 1; x <= cx + 1; x++) {
          for (let z = cz - 1; z <= cz + 1; z++) {
            if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
              standing = false
            } else {
              sub++
            }
          }
        }
      }

      if (standing) {
        play()
        return
      }
      world.tick()

			let progress = Math.round(100 * sub / maxLoad)
			
			nether()
			fill(255)
			textSize(25)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
		}

		drawScreens.inventory = drawInv
    
    drawScreens.crafting = drawCrafting
    
    drawScreens.furnace = drawFurnace

		drawScreens.pause = () => {
			strokeWeight(1)
			clear()

			textSize(50)
			fill(0, 0, 0)
			ctx.textAlign = 'center'
			text("Paused", width / 2, 60)
		}

		drawScreens.options = () => {
			clear()
		}
    drawScreens.help = () => {
      dirt()
      ctx.textAlign = 'center'
			textSize(25)
			fill(255)
			text("Help", width / 2, 40)
    }
		drawScreens["creation menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Create New World", width / 2, 20)
		}
		drawScreens["loadsave menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Select World", width / 2, 20)
		}
    drawScreens["broken world"] = () => {
      dirt()
			ctx.textAlign = 'center'
			fill(255)
			textSize(25)
			text("This world is an old world.\nIt might be broken.\nAre you sure you want to load it?", width / 2, height / 2 - 50, 25)
    }
    drawScreens["multiplayer menu"] = () => {
      dirt()
			ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Select server", width / 2, 20)
    }
    drawScreens["multiplayer connecting"] = () => {
      dirt()
			ctx.textAlign = 'center'
			fill(255)
			textSize(25)
			text("Connecting...", width / 2, height / 2)
    }
		drawScreens.editworld = dirt
    drawScreens.marketplace = () => {
      dirt()
      ctx.textAlign = 'center'
			textSize(18)
			fill(255)
			text("Marketplace", width / 2, 20)
    }
	})()

	// Give the font time to load and redraw the homescreen
	setTimeout(e => {
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
	}, 100)

	let debugMenu = false
	function gameLoop() {
		let frameStart = performance.now()
		if (!gl) {
			initEverything()
			releasePointer()
		}

    if(allLoaded){
      if(screen === "options"){
        if(previousScreen === "main menu"){
          if(analytics.frames % 2 === 0)renderMainBG()
        }
      }
      if(screen === "main menu"){
        if(analytics.frames % 2 === 0)renderMainBG()
        drawScreens[screen]()
        Button.draw()
        Slider.draw()
      }
      
      if (screen === "play" || screen === "loading" || screen === "netherLoading") {
        drawScreens[screen]()
        if(touchScreen && screen === "play") Button.draw()
      }
       
      if(screen === "furnace" && furnaceData.data.smelting){
        drawScreens[screen]()
      }
    }

		if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
			analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1)
			analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1)
			analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1)
			analytics.fps = round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate))
			analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1)
			analytics.frames = 0
			analytics.totalRenderTime = 0
			analytics.totalTickTime = 0
			analytics.totalFrameTime = 0
			analytics.worstFrameTime = 0
			analytics.lastUpdate = Date.now()
			updateHUD = true
		}

		analytics.frames++
		analytics.totalFrameTime += performance.now() - frameStart
		analytics.worstFrameTime = max(performance.now() - frameStart, analytics.worstFrameTime)
		win.raf = requestAnimationFrame(gameLoop)
	}
	return gameLoop
}

var init = MineKhan()
if (window.parent.raf) {
	window.cancelAnimationFrame(window.parent.raf)
	console.log("Canceled", window.parent.raf)
}
init()


	</script>
    
    <script>
function hcyl(bottom, height, radius, id) {
    let radsq = radius * radius
    let innerRadsq = (radius - 1.2) * (radius - 1.2)
    height += bottom
    for (let x = -radius; x <= radius; x++) {
        for (let y = bottom; y < height; y++) {
            for (let z = -radius; z <= radius; z++) {
                let d = x * x + z * z
                if (d < radsq && d >= innerRadsq) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function cyl(bottom, height, radius, id) {
    let radsq = radius * radius
    height += bottom
    for (let x = -radius; x <= radius; x++) {
        for (let y = bottom; y < height; y++) {
            for (let z = -radius; z <= radius; z++) {
                let d = x * x + z * z
                if (d < radsq) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function sphereoid(w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d
    let w3 = (w - 1.5) * (w - 1.5)
    let h3 = (h - 1.5) * (h - 1.5)
    let d3 = (d - 1.5) * (d - 1.5)

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                let n2 = x * x / w3 + y * y / h3 + z * z / d3
                if (n < 1 && n2 >= 1) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function sphereoidAt(X,Y,Z,w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d
    let w3 = (w - 1.5) * (w - 1.5)
    let h3 = (h - 1.5) * (h - 1.5)
    let d3 = (d - 1.5) * (d - 1.5)

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                let n2 = x * x / w3 + y * y / h3 + z * z / d3
                if (n < 1 && n2 >= 1) {
                    world.setBlock(X + x, Y + y, Z + z, id)
                }
            }
        }
    }
}
function ball(X,Y,Z,w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                if (n < 1) {
                    world.setBlock(X + x, Y + y, Z + z, id)
                }
            }
        }
    }
}

function explode(x,y,z, r){
  /*world.setBlock(x,y,z,blockIds.air);
  for(var i=radius; i>0; i--){
    sphereoidAt(x,y,z,i,i,i, blockIds.air)
  }*/
  //ball(x,y,z,r,r,r,0)
  world.setBlock(x,y,z, 0)
  let w2 = r * r
  let h2 = w2
  let d2 = w2
  for (let Y = -r; Y < r; Y++) {
    for (let X = -r; X <= r; X++) {
      for (let Z = -r; Z <= r; Z++) {
        let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
        if (n < 1) {
          if(world.getBlock(X + x, Y + y, Z + z) === blockIds.tnt){
            blockData[blockIds.tnt].explode(X+x,Y+y,Z+z)
          }
          world.setBlock(X + x, Y + y, Z + z, 0)
        }
      }
    }
  }
  for(var i=0; i<world.entities.length; i++){
    var ent = world.entities[i]
    var dist = dist3(x,y,z, ent.x, ent.y, ent.z)
    if(dist <= r){
      ent.velx = ent.x - x; ent.velx = ((Math.sign(ent.velx)*r)-ent.velx)/10
      ent.vely = ent.y - y; ent.vely = ((Math.sign(ent.vely)*r)-ent.vely)/10
      ent.velz = ent.z - z; ent.velz = ((Math.sign(ent.velz)*r)-ent.velz)/10
    }
  }
  var p = player
  var dist = dist3(x,y,z, p.x, p.y, p.z)
  if(dist <= r){
    p.velocity.x = p.x - x; p.velocity.x = ((Math.sign(p.velocity.x)*r)-p.velocity.x)/10
    p.velocity.y = p.y - y; p.velocity.y = ((Math.sign(p.velocity.y)*r)-p.velocity.y)/10
    p.velocity.z = p.z - z; p.velocity.z = ((Math.sign(p.velocity.z)*r)-p.velocity.z)/10
  }
  explodeSound(x,y,z)
}
function fall(x,y,z,b){
  if(world.getBlock(x,y-1,z)) return
  setTimeout(() => {
    world.setBlock(x,y,z, 0)
    world.addEntity(new BlockEntity(b, x,y,z, true))
  }, 100)
}
function blockParticles(block,x,y,z,amount){
  for(var i=0; i<amount; i++) world.particles.push(new BlockParticle(blockData[block].textures[2], x,y,z))
}

if (("serviceWorker" in navigator) && location.origin === "https://minekhan.thingmaker.repl.co") {
  window.addEventListener("load", function() {
    navigator.serviceWorker
      .register("/sw.js")
      .then(res => console.log("service worker registered"))
      .catch(err => console.log("service worker not registered", err))
  })
}

function scrollToEl(id){
  var el = document.getElementById(id)
  if(el) el.scrollIntoView()
}
    </script>
	</body>
</html>